---
title: "바이브 코딩 완벽 마스터 가이드 - 게임부터 앱까지"
created: '2025-10-12'
last_modified: '2025-10-12'
tags:
  - 개발/바이브코딩
  - AI/Claude
  - AI/GPT5
  - 게임개발/가이드
  - 앱개발/가이드
  - 초보자/완벽가이드
status: "완료"
type: "가이드"
priority: "high"
---

# 바이브 코딩 완벽 마스터 가이드 - 게임부터 앱까지

## 📋 목차

1. [[#이야기로 시작하기 - 코딩 없이 게임을 만든다고]]
2. [[#바이브 코딩이란 무엇인가]]
3. [[#필요한 도구 준비하기]]
4. [[#핵심 원칙 - 계획이 전부다]]
5. [[#1단계 - 게임 디자인 문서 작성]]
6. [[#2단계 - 기술 스택 선정]]
7. [[#3단계 - 구현 계획 수립]]
8. [[#4단계 - 메모리 뱅크 구축]]
9. [[#5단계 - 실제 구현하기]]
10. [[#6단계 - 세부 기능 추가하기]]
11. [[#버그 해결과 막힘 돌파하기]]
12. [[#프로 팁과 도구 활용]]
13. [[#실전 워크플로우 완벽 정리]]
14. [[#자주 묻는 질문]]
15. [[#용어 설명]]

---

## 이야기로 시작하기 - 코딩 없이 게임을 만든다고?

### 🎮 지훈이의 꿈

지훈이는 어릴 때부터 비행 게임을 좋아했습니다.
"내가 직접 비행 게임을 만들 수 있다면 얼마나 좋을까?"

하지만 현실은:
- 프로그래밍 언어 배우기: 최소 6개월
- 3D 그래픽: 또 6개월
- 물리 엔진: 또 6개월
- 네트워크 멀티플레이: 또 1년...

**"도대체 언제 게임을 만들지...?"**

### 🚀 2025년, 모든 것이 바뀌었다

지훈이는 **바이브 코딩**을 발견했습니다.

```
지훈: "AI야, 비행기가 서로 싸우는 3D 게임 만들어줘."
AI: "네! 어떤 기술 스택을 사용할까요?"
지훈: "가장 간단하고 강력한 걸로."
AI: "ThreeJS와 WebSocket으로 시작하겠습니다."

[30분 후]
AI: "기본 비행 메커니즘 완성했습니다. 테스트해보세요!"
```

**30일 후, 지훈이는 멀티플레이 비행 게임을 완성했습니다.**

### 💡 바이브 코딩의 마법

```
전통적인 개발:
코드를 한 줄 한 줄 작성
  ↓
버그와 싸우기 (몇 주)
  ↓
다시 코드 수정
  ↓
6개월 후 반쯤 완성

바이브 코딩:
아이디어 설명
  ↓
AI가 구현
  ↓
테스트 → 피드백
  ↓
AI가 개선
  ↓
1개월 후 완성!
```

### 🎯 이 가이드가 보여줄 것

- ✅ 게임이나 앱을 **30일 안에** 만드는 방법
- ✅ AI를 **최대한 활용**하는 전략
- ✅ **막힐 때** 돌파하는 기술
- ✅ **프로처럼** 프로젝트 관리하기

**코딩 경험? 필요 없습니다!**
**필요한 건 명확한 아이디어와 끈기뿐입니다.**

---

## 바이브 코딩이란 무엇인가?

### 🎨 "분위기"로 코딩한다

**Vibe Coding** = **Vibe** (분위기, 느낌) + **Coding** (코딩)

```
당신: "비행기 게임 만들고 싶어.
      플레이어끼리 서로 쏘고,
      날씨도 변하고,
      구름 사이로 날아다니는 느낌?"

AI: "알겠습니다!
     3D 공중전 게임이군요.
     날씨 시스템과 물리 엔진이 필요하겠네요.
     ThreeJS로 시작하겠습니다."
```

### 🎪 요리로 이해하기

#### 전통 코딩 = 요리학교 졸업 후 직접 요리

```
1. 요리학교 4년 다니기
2. 레시피 정확히 외우기
3. 직접 칼질, 불 조절
4. 실수하면 처음부터
```

#### 바이브 코딩 = AI 셰프와 협업

```
당신: "매콤달콤한 닭요리 만들어줘,
      약간 바삭하게,
      색은 예쁘게 빨갛게"

AI 셰프: "치킨 타코스는 어때요?"

당신: "좋아! 근데 좀 더 매워"

AI 셰프: "고추 2배로 늘렸습니다!"
```

### 🔑 바이브 코딩 vs 전통 코딩

**전통 코딩:**
```javascript
// 비행기 이동 코드 직접 작성
function moveAirplane(airplane, direction) {
  const speed = 10;
  if (direction === 'forward') {
    airplane.position.z += speed * deltaTime;
    airplane.rotation.x = Math.PI / 12;
  }
  // ... 100줄 더...
}
```

**바이브 코딩:**
```
당신: "비행기가 앞으로 갈 때 살짝 위로 기울어지게 해줘"
AI: [완벽한 코드 작성]
```

### 💪 바이브 코딩이 가능한 이유

**2024년 이전:**
```
AI: "게임? 코드 짜는 법 알려줄게요..."
개발자: "직접 코딩해야 하네..."
❌ 여전히 어려움
```

**2025년 (현재):**
```
AI (GPT-5, Claude 4.5):
- 수백만 개 게임 코드 학습함
- 게임 엔진 전문가 수준
- 버그도 스스로 고침
- 전체 프로젝트 관리 가능

개발자: "이렇게 만들어줘"
AI: [완벽히 구현]
✅ 혁명적 변화!
```

### 🎯 바이브 코딩으로 만들 수 있는 것

**게임:**
```
✅ 2D 플랫포머 (슈퍼마리오 스타일)
✅ 3D 슈팅 게임
✅ 멀티플레이 온라인 게임
✅ 퍼즐 게임
✅ RPG
✅ 레이싱 게임
```

**앱:**
```
✅ 쇼핑몰 웹사이트
✅ SNS 플랫폼
✅ 업무 관리 도구
✅ 채팅 앱
✅ 대시보드
✅ 모바일 앱
```

### ⚠️ 중요한 제한사항

```
바이브 코딩이 어려운 것:
❌ AAA급 대작 게임 (수십 명이 몇 년 걸리는)
❌ 초고도 최적화 필요한 프로그램
❌ 완전히 새로운 알고리즘 개발

바이브 코딩이 완벽한 것:
✅ 인디 게임 (1-2명이 만드는)
✅ 프로토타입 빠르게 제작
✅ 웹 앱, 모바일 앱
✅ 아이디어 검증
```

### 🌟 성공의 비결

```
90%: 계획과 소통
  - 명확한 아이디어
  - 단계별 계획
  - AI와 효과적인 대화

10%: 코딩 실력
  - AI가 대부분 처리
  - 간단한 버그 수정만 필요
```

---

## 필요한 도구 준비하기

### 🧰 필수 도구 2가지 중 1개 선택

#### 옵션 1: Claude Code (추천!)

**무엇인가요?**
- Anthropic의 Claude AI 탑재
- 최신 모델: Claude Sonnet 4.5
- 매우 똑똑하고 대화가 자연스러움

**설치:**
```bash
# 방법 1: VSCode 확장 프로그램
1. VSCode 열기
2. 확장 프로그램 검색: "Claude Code"
3. 설치 후 로그인

# 방법 2: CLI (터미널)
npm install -g claude-code
claude --version
```

**가격:**
```
무료 플랜:
- 제한적 사용
- 학습용으로 충분

Pro 플랜 ($20/월):
- 무제한 사용
- 더 빠른 응답
```

#### 옵션 2: Codex CLI

**무엇인가요?**
- OpenAI의 GPT-5 Codex 모델
- 코딩에 특화됨
- 매우 정확한 코드 생성

**설치:**
```bash
npm install -g codex-cli
codex --version
```

**가격:**
```
OpenAI API 키 필요
사용량 기반 과금
```

### 🔧 보조 도구들

#### 1. VSCode (필수)

**무엇인가요?**
- 마이크로소프트의 코드 편집기
- 무료
- 가장 인기 있는 개발 도구

**다운로드:**
```
https://code.visualstudio.com
→ Download 클릭
→ 설치 파일 실행
```

#### 2. Node.js (필수)

**무엇인가요?**
- JavaScript 실행 환경
- 웹 서버 구동
- npm으로 패키지 관리

**설치:**
```
https://nodejs.org
→ LTS 버전 다운로드
→ 설치

확인:
node --version
npm --version
```

#### 3. Git (필수)

**무엇인가요?**
- 코드 버전 관리 도구
- 실수해도 되돌릴 수 있음!

**설치:**
```
https://git-scm.com
→ Download 클릭

확인:
git --version
```

#### 4. Superwhisper (선택, 하지만 강추!)

**무엇인가요?**
- 음성을 텍스트로 변환
- AI에게 **말로** 지시할 수 있음!

**왜 좋은가:**
```
타이핑:
"비행기가 앞으로 갈 때
살짝 위로 기울어지게 하고,
속도는 현재의 1.5배로,
부스터 효과음도 추가해줘"
→ 타이핑 시간: 1분

음성 (Superwhisper):
똑같은 말을 자연스럽게 말하기
→ 소요 시간: 10초!
```

**설치:**
```
https://superwhisper.com
Mac 전용
$20 일회성 구매
```

### 🎨 게임/앱 리소스 도구

#### 이미지 생성

**Nano Banana (스프라이트)**
```
용도: 2D 게임 캐릭터, 아이템
사용: ChatGPT와 연동
```

**Midjourney / DALL-E**
```
용도: 배경, 컨셉 아트
```

#### 사운드 생성

**ElevenLabs**
```
용도: 효과음, 음성
특징: AI 음성 생성
```

**Suno**
```
용도: 배경 음악
특징: AI 작곡
```

#### 비디오 생성

**Sora 2**
```
용도: 트레일러, 컷신
특징: AI 비디오 생성
```

### ✅ 설치 체크리스트

```
필수 도구:
□ Claude Code 또는 Codex CLI 설치
□ VSCode 설치
□ Node.js 설치
□ Git 설치

선택 도구:
□ Superwhisper (음성 입력)

계정:
□ Claude AI 계정 (또는 OpenAI)
□ GitHub 계정 (코드 저장용)

확인:
□ 터미널에서 명령어 실행 가능
  - claude --version
  - node --version
  - git --version
```

---

## 핵심 원칙 - 계획이 전부다

### 🎯 가장 중요한 규칙

> **"AI에게 계획을 맡기지 마라!"**

#### 나쁜 예시 ❌

```
개발자: "비행 게임 만들어줘"
AI: "네! 시작하겠습니다"
    [파일 100개 생성]
    [코드 10,000줄 작성]
    [구조 엉망]

1주일 후:
개발자: "여기 수정해줘"
AI: "어디를 수정해야 할지 모르겠습니다...
     코드가 너무 복잡해졌어요"

결과: 프로젝트 망함 💀
```

#### 좋은 예시 ✅

```
개발자: [게임 디자인 문서 작성]
        [기술 스택 선정]
        [단계별 계획 수립]

개발자: "1단계만 구현해줘:
        비행기 하나가 화면에 나타나고
        키보드로 움직일 수 있게"

AI: [정확히 1단계만 구현]

개발자: [테스트 완료]
        "좋아! 이제 2단계"

결과: 체계적으로 완성! 🎉
```

### 🏗️ 집 짓기로 이해하기

#### 계획 없이 (AI에게 맡김)

```
당신: "집 지어줘"
건축가: "네!"
      [막 짓기 시작]
      [거실이 침실보다 작음]
      [화장실이 2층에 없음]
      [계단이 너무 가파름]

결과: 살 수 없는 집
```

#### 계획 후 (단계별 지시)

```
당신: [설계도 작성]
      [자재 목록 작성]
      [단계별 일정표 작성]

당신: "1단계: 기초 공사"
건축가: [기초 완성]

당신: [검사]
      "2단계: 1층 골조"
건축가: [1층 완성]

결과: 완벽한 집!
```

### 📋 바이브 코딩의 계획 단계

```
1. 게임 디자인 문서 (GDD)
   또는 제품 요구사항 문서 (PRD)
   ↓
   "무엇을 만들 것인가"

2. 기술 스택 문서
   ↓
   "어떤 기술로 만들 것인가"

3. 구현 계획 문서
   ↓
   "어떤 순서로 만들 것인가"

4. 메모리 뱅크 구축
   ↓
   "AI가 언제든 참조할 수 있는 지식 저장소"

5. 단계별 구현
   ↓
   "하나씩 완성하며 진행"
```

### 🎓 왜 계획이 중요한가?

#### 이유 1: AI의 맥락 제한

```
AI의 한계:
- 한 번에 처리 가능한 정보량 제한
- 이전 대화를 잊어버릴 수 있음
- 전체 구조를 한눈에 보지 못함

해결책:
문서로 명확히 정리
→ AI가 언제든 참조 가능
```

#### 이유 2: 일관성 유지

```
계획 없이:
1주차: 파일 구조 A로 개발
2주차: AI가 갑자기 구조 B로 변경
3주차: 두 구조가 충돌
→ 엉망진창

계획 있으면:
문서에 "파일 구조 A 사용" 명시
→ AI가 계속 일관되게 따름
```

#### 이유 3: 디버깅 용이

```
문제 발생 시:

계획 없으면:
"어디서부터 잘못됐지...?"
[모든 코드 뒤지기]

계획 있으면:
progress.md 확인
→ "아, 5단계에서 문제구나"
→ 정확한 위치 파악
```

### 💡 계획의 황금 원칙

**원칙 1: 작게 나누기**
```
❌ "게임 만들기" (너무 큼)
✅ "비행기 1대 화면에 표시" (적당함)
```

**원칙 2: 테스트 포함**
```
각 단계마다:
- 구현할 내용
- 테스트 방법
- 성공 기준
```

**원칙 3: 문서로 기록**
```
머릿속 계획 (X)
→ 당신도 잊고, AI도 모름

Markdown 문서 (O)
→ 언제든 확인 가능
```

---

## 1단계 - 게임 디자인 문서 작성

### 📜 게임 디자인 문서(GDD)란?

**쉽게 말하면:**
- 게임의 "설계도"
- 만들 게임이 어떤 것인지 설명
- 영화로 치면 "시놉시스"

**비유:**
```
레스토랑 오픈 계획서
- 어떤 음식? (한식, 양식, 중식...)
- 분위기는? (캐주얼, 고급...)
- 타겟 고객? (가족, 직장인...)
- 특별한 점? (뷔페, 코스...)

게임 디자인 문서
- 어떤 게임? (슈팅, RPG, 퍼즐...)
- 플레이 방식? (1인, 멀티, 턴제...)
- 타겟 플레이어? (초보, 하드코어...)
- 핵심 재미? (전략, 스피드, 스토리...)
```

### 🎮 GDD 작성 방법

#### STEP 1: 아이디어 정리

**먼저 자유롭게 생각해보세요:**

```
예시: 비행 게임 아이디어

Q: 어떤 게임?
A: 전투기로 공중전하는 게임

Q: 왜 재미있을까?
A: 실시간으로 친구와 대결
   멋진 곡예 비행
   미사일 피하는 스릴

Q: 어떤 느낌?
A: 긴장감 있고 스피디한
   하늘을 자유롭게 나는
   Top Gun 영화 같은

Q: 핵심 기능?
A: 비행기 조종
   미사일 발사
   체력 관리
   실시간 멀티플레이
```

#### STEP 2: GPT-5나 Claude에게 요청

**프롬프트 예시:**

```
다음 게임 아이디어를 바탕으로
간단한 게임 디자인 문서(GDD)를
Markdown 형식으로 작성해줘:

게임 제목: Sky Warriors
장르: 3D 공중 슈팅
플레이어: 멀티플레이 (2-4명)

핵심 아이디어:
- 전투기를 조종해서 다른 플레이어와 공중전
- 실시간 대전
- 간단한 조작 (키보드/마우스)
- 5분 안에 한 게임 끝남

재미 요소:
- 스피드감 있는 비행
- 미사일 발사와 회피
- 곡예 비행 기술
- 친구와 경쟁

필수 기능:
1. 비행기 조종 (전후좌우, 회전)
2. 미사일 발사
3. 체력 바
4. 멀티플레이 (2-4명)
5. 간단한 맵 (하늘, 구름)

제외할 것:
- 복잡한 업그레이드 시스템
- 스토리 모드
- 싱글 플레이 AI

참고 게임:
- Ace Combat (비행 느낌)
- War Thunder (단순화 버전)

문서에 포함할 것:
- 게임 개요
- 핵심 게임플레이
- 플레이어 경험
- 필수 기능 리스트
- 기술적 요구사항
- 성공 지표

너무 자세하지 않게,
핵심만 담은 2-3페이지 분량으로.
```

#### STEP 3: AI 응답 예시

```markdown
# Sky Warriors - Game Design Document

## 1. 게임 개요
- **제목**: Sky Warriors
- **장르**: 3D 멀티플레이 공중 슈팅
- **플랫폼**: 웹 브라우저 (PC)
- **플레이어**: 2-4명 동시 대전
- **세션 시간**: 5분

## 2. 핵심 게임플레이
플레이어는 전투기를 조종하여 공중에서
다른 플레이어와 대결합니다.

**목표**:
상대 전투기를 격추하여 가장 많은 킬 획득

**조작**:
- W/S: 전진/후진
- A/D: 좌우 회전
- Q/E: 상하 회전
- Space: 미사일 발사
- Shift: 부스터

## 3. 핵심 기능
### 3.1 비행 시스템
- 6자유도 비행 (3축 이동 + 3축 회전)
- 물리 기반 비행 (속도, 관성)
- 실속 메커니즘

### 3.2 전투 시스템
- 기본 기관총 (무한 탄약)
- 미사일 (재장전 필요)
- 타겟 락온 시스템
- 체력 시스템 (100 HP)

### 3.3 멀티플레이
- WebSocket 기반 실시간 동기화
- 최대 4명 동시 플레이
- 자동 매칭 또는 방 생성

### 3.4 환경
- 구름이 있는 하늘
- 낮/밤 사이클
- 간단한 날씨 효과

## 4. 플레이어 경험
- **입문 (0-5분)**: 기본 조작 익히기
- **숙련 (5-30분)**: 곡예 비행 마스터
- **전문 (30분+)**: 전략적 대결

## 5. 기술 스택 후보
- ThreeJS (3D 렌더링)
- WebSocket (네트워크)
- Express (서버)
- Cannon.js (물리 엔진)

## 6. 성공 지표
- 1게임 평균 시간: 5분
- 조작 학습 시간: < 2분
- 서버 지연: < 100ms
- 동시 접속자: 4명 안정적 지원
```

#### STEP 4: 검토 및 수정

**확인할 것:**
```
□ 핵심 재미가 명확한가?
□ 기능 범위가 적당한가? (너무 크지 않은가?)
□ 만들 수 있는 수준인가?
□ 우선순위가 있는가?
```

**수정 예시:**
```
원래: "날씨 효과 (비, 눈, 천둥)"
→ 너무 복잡함

수정: "기본 날씨 효과 (구름만)"
→ 나중에 추가 가능
```

### 📱 앱을 만든다면? PRD 작성

**GDD 대신 PRD (Product Requirements Document)**

**프롬프트 예시:**

```
다음 앱 아이디어를 바탕으로
제품 요구사항 문서(PRD)를 작성해줘:

앱 이름: TaskFlow
유형: 할 일 관리 웹 앱

핵심 아이디어:
- 개인 할 일 관리
- 팀과 공유 가능
- 간단하고 직관적
- Notion의 단순 버전

주요 기능:
1. 할 일 생성/수정/삭제
2. 체크박스로 완료 표시
3. 카테고리별 분류
4. 팀원과 공유
5. 간단한 통계

타겟 유저:
- 프리랜서
- 소규모 팀 (2-5명)
- 복잡한 도구 싫어하는 사람

문서 형식:
- 문제 정의
- 솔루션
- 핵심 기능
- 유저 플로우
- 기술 요구사항
```

### 💡 GDD/PRD 작성 팁

**TIP 1: 처음엔 단순하게**
```
❌ 50가지 기능
✅ 5가지 핵심 기능만

나중에 추가하면 됨!
```

**TIP 2: "하지 않을 것" 명시**
```
포함: 멀티플레이
제외: 싱글 AI 대전

→ AI가 불필요한 기능 안 만듦
```

**TIP 3: 참고 사례 제시**
```
"XX 게임 같은 느낌"
"YY 앱처럼 간단하게"

→ AI가 방향성 이해
```

**TIP 4: 파일로 저장**
```
파일명: game-design-document.md
위치: 프로젝트 폴더
형식: Markdown

→ AI가 언제든 참조 가능
```

### ✅ 1단계 완료 체크리스트

```
□ 게임/앱 아이디어 명확히 정리
□ GPT-5 또는 Claude에게 GDD/PRD 요청
□ AI가 생성한 문서 검토
□ 너무 복잡한 부분 단순화
□ game-design-document.md 파일로 저장
□ 핵심 기능 5개 이하로 정리
□ "하지 않을 것" 목록 작성
```

---

## 2단계 - 기술 스택 선정

### 🔧 기술 스택이란?

**쉬운 비유:**
```
집 짓기 재료 선택
- 벽돌? 나무? 철근 콘크리트?
- 지붕은? 타일? 함석?

게임/앱 만들기 기술 선택
- 3D는? ThreeJS? BabylonJS?
- 서버는? Express? FastAPI?
- 데이터베이스는? MongoDB? PostgreSQL?
```

**왜 중요한가:**
```
잘못된 선택:
나무로 50층 빌딩 짓기 (불가능)
대포로 모기 잡기 (과함)

올바른 선택:
적합한 재료
적합한 도구
→ 빠르고 안정적
```

### 🎮 게임 기술 스택 예시

#### 3D 게임 (비행 게임 같은)

**프롬프트:**
```
다음 게임을 만들기 위한
최적의 기술 스택을 추천해줘.
가장 간단하면서도 강력한 조합으로:

게임 타입: 3D 멀티플레이 공중전
플랫폼: 웹 브라우저
필수 기능:
- 3D 렌더링
- 실시간 멀티플레이
- 물리 엔진
- 서버-클라이언트 통신

고려사항:
- 초보자도 이해 가능
- 문서가 풍부할 것
- 커뮤니티 활발할 것
- 무료일 것

각 기술에 대해:
- 무엇인지
- 왜 선택했는지
- 대안은 무엇인지
설명해줘
```

**AI 응답 예시:**

```markdown
# Sky Warriors - 기술 스택

## 프론트엔드 (클라이언트)

### ThreeJS
**역할**: 3D 그래픽 렌더링
**이유**:
- WebGL 기반 (브라우저에서 3D)
- 가장 인기 있는 JS 3D 라이브러리
- 문서 풍부, 예제 많음
- 학습 곡선 완만

**대안**:
- BabylonJS: 더 무겁지만 기능 많음
- PixiJS: 2D 전용

### Cannon.js
**역할**: 물리 엔진
**이유**:
- ThreeJS와 완벽 호환
- 충돌 감지, 중력 시뮬레이션
- 가볍고 빠름

**대안**:
- Ammo.js: 더 정교하지만 무거움
- Oimo.js: 비슷한 수준

## 백엔드 (서버)

### Node.js + Express
**역할**: 웹 서버
**이유**:
- JavaScript로 통일 (프론트와 같은 언어)
- 비동기 처리 우수
- 설정 간단

**대안**:
- Python Flask: 간단하지만 성능↓
- Go: 빠르지만 학습 곡선↑

### WebSocket (Socket.io)
**역할**: 실시간 통신
**이유**:
- 매우 낮은 지연시간
- 멀티플레이 필수
- 자동 재연결

**대안**:
- WebRTC: P2P에 좋지만 복잡
- HTTP 폴링: 느리고 비효율

## 데이터 저장

### MongoDB
**역할**: 데이터베이스
**이유**:
- 설정 간단
- JSON 형태로 저장 (JS와 자연스러움)
- 스키마 유연

**대안**:
- PostgreSQL: 관계형 DB, 더 복잡
- Redis: 매우 빠르지만 메모리 기반

## 개발 도구

### Vite
**역할**: 빌드 도구
**이유**:
- 매우 빠른 개발 서버
- 핫 리로드 (코드 수정 즉시 반영)
- 설정 최소화

### Git
**역할**: 버전 관리
**이유**:
- 코드 백업
- 실수 시 되돌리기
- 협업 가능

## 전체 구조

```
Client (브라우저)
  ├─ ThreeJS (3D 렌더링)
  ├─ Cannon.js (물리)
  └─ Socket.io-client (통신)
         ↕ WebSocket
Server (Node.js)
  ├─ Express (웹 서버)
  ├─ Socket.io (통신)
  └─ MongoDB (데이터)
```

## 추가 라이브러리

### Tween.js
**역할**: 애니메이션
부드러운 움직임

### Stats.js
**역할**: 성능 모니터링
FPS 확인
```

#### 2D 게임

**더 간단한 스택:**
```
프론트:
- PixiJS (2D 그래픽)
- Matter.js (2D 물리)

백엔드:
- Node.js + Express
- Socket.io

더 간단함!
```

### 📱 앱 기술 스택 예시

#### 할 일 관리 앱

**프롬프트:**
```
할 일 관리 웹 앱 기술 스택 추천:

기능:
- 할 일 CRUD
- 유저 인증
- 실시간 동기화
- 팀 공유

요구사항:
- 반응형 (모바일/PC)
- 빠른 개발
- 확장 가능
- 무료/저렴
```

**AI 응답 예시:**
```markdown
# TaskFlow - 기술 스택

## 프론트엔드
### React
- 컴포넌트 기반
- 재사용 쉬움
- 풍부한 라이브러리

### TailwindCSS
- 빠른 스타일링
- 반응형 쉬움
- 커스텀 간단

## 백엔드
### Next.js
- React + 서버 통합
- API 라우트 간편
- SEO 우수

### Supabase
- Firebase 대체
- PostgreSQL 기반
- 실시간 DB
- 인증 내장
- 무료 티어 관대

## 배포
### Vercel
- Next.js 최적화
- 자동 배포
- 무료 플랜
```

### 🎯 기술 스택 선정 원칙

**원칙 1: 단순함 우선**
```
복잡한 스택:
Django + Vue + GraphQL + K8s
→ 설정만 1주일

단순한 스택:
Next.js + Supabase
→ 설정 1시간
```

**원칙 2: 통일성**
```
좋음:
프론트: JavaScript (React)
백엔드: JavaScript (Node.js)
→ 한 언어로 통일

나쁨:
프론트: JavaScript
백엔드: Python
DB: Java
→ 언어 3개 섞임
```

**원칙 3: 문서 풍부**
```
ThreeJS: 공식 문서 + 1000개 예제
→ 막히면 바로 찾아봄

희귀한 라이브러리: 문서 거의 없음
→ 막히면 해결 어려움
```

### 💡 스택 선정 팁

**TIP 1: AI에게 물어보기**
```
"이 기술 스택 어때?"
→ AI가 장단점 분석
→ 대안 제시
```

**TIP 2: 프로토타입 우선**
```
처음: 가장 간단한 스택
검증 후: 필요시 업그레이드
```

**TIP 3: 저장하기**
```
파일명: tech-stack.md
내용: 각 기술의 역할과 이유
→ AI 참조용
```

### ✅ 2단계 완료 체크리스트

```
□ GDD/PRD 기반으로 필요 기능 파악
□ AI에게 기술 스택 추천 요청
□ 각 기술의 역할 이해
□ 대안 기술 확인
□ 가장 간단한 조합 선택
□ tech-stack.md 파일로 저장
□ 학습 자료 URL 메모
```

---

## 3단계 - 구현 계획 수립

### 📋 구현 계획이란?

**쉬운 비유:**
```
여행 계획
- 1일차: 공항 → 호텔
- 2일차: 관광지 A
- 3일차: 관광지 B
- 4일차: 호텔 → 공항

구현 계획
- 1단계: 화면에 오브젝트 표시
- 2단계: 키보드로 조작
- 3단계: 충돌 감지
- 4단계: 멀티플레이
```

### 🎯 좋은 구현 계획의 특징

**특징 1: 작은 단계**
```
❌ 나쁜 계획:
1단계: 게임 완성

✅ 좋은 계획:
1단계: 비행기 1대 화면에 표시
2단계: 키보드로 움직이기
3단계: 카메라 따라다니게
4단계: 미사일 발사
5단계: 충돌 감지
...
```

**특징 2: 테스트 포함**
```
각 단계마다:
- 무엇을 구현
- 어떻게 테스트
- 성공 기준
```

**특징 3: 코드 없음!**
```
❌ 코드 포함:
1단계: const airplane = new THREE.Mesh(...)

✅ 지시사항만:
1단계: ThreeJS로 비행기 모델을 화면 중앙에 표시.
       테스트: 브라우저에서 비행기가 보이는가?
```

### 🎮 구현 계획 작성하기

#### STEP 1: AI에게 요청

**프롬프트:**
```
다음 문서들을 참고해서
상세한 구현 계획을 작성해줘:

[game-design-document.md 내용 붙여넣기]

[tech-stack.md 내용 붙여넣기]

요구사항:
1. 단계는 작고 구체적으로 (10-20단계)
2. 각 단계는 1-3시간 안에 완료 가능
3. 코드 없이 지시사항만
4. 각 단계마다 테스트 방법 포함
5. 기본 게임만 (세부 기능은 나중에)
6. 의존성 고려 (A 완성 후 B 가능)

형식:
## 1단계: [제목]
**목표**: [달성할 것]
**작업**:
- [구체적 지시 1]
- [구체적 지시 2]
**테스트**:
- [확인 방법 1]
- [확인 방법 2]
**성공 기준**:
- [측정 가능한 기준]
```

#### STEP 2: AI 응답 예시

```markdown
# Sky Warriors - 구현 계획

## 0단계: 프로젝트 설정
**목표**: 개발 환경 구축
**작업**:
- Node.js 프로젝트 초기화 (npm init)
- 필요한 패키지 설치:
  - threejs, cannon-es, socket.io
  - express, vite
- 기본 폴더 구조 생성:
  - /client (프론트엔드)
  - /server (백엔드)
  - /shared (공통 코드)
**테스트**:
- npm start로 서버 실행
- 브라우저에서 localhost:3000 접속
- "Hello World" 표시 확인
**성공 기준**:
- 에러 없이 서버 실행
- 브라우저에서 화면 표시

---

## 1단계: 3D 씬 기본 설정
**목표**: ThreeJS로 빈 3D 공간 만들기
**작업**:
- ThreeJS Scene 생성
- PerspectiveCamera 추가
- WebGLRenderer 설정
- 기본 조명 (AmbientLight + DirectionalLight)
- 60fps 렌더링 루프
**테스트**:
- 브라우저 F12 콘솔에 에러 없음
- 검은 화면이 표시됨 (아직 오브젝트 없음)
**성공 기준**:
- 콘솔에 "Scene initialized" 로그
- FPS 카운터 표시 (Stats.js 사용)

---

## 2단계: 비행기 모델 표시
**목표**: 화면에 비행기 1대 표시
**작업**:
- 비행기 형태 만들기 (기본 도형 조합)
  - 동체: BoxGeometry
  - 날개: PlaneGeometry
  - 꼬리날개: PlaneGeometry
- 재질 설정 (MeshPhongMaterial, 회색)
- 씬 중앙 (0, 0, 0)에 배치
- 카메라를 비행기 뒤에 위치 (0, 5, 10)
**테스트**:
- 브라우저에서 비행기 모델이 보이는가?
- 마우스로 화면을 드래그하면 시점 변경되는가?
  (OrbitControls 추가)
**성공 기준**:
- 비행기가 명확히 식별 가능
- 3D 공간에서 비행기 주변을 돌아볼 수 있음

---

## 3단계: 키보드 입력 처리
**목표**: 키보드 입력 감지 시스템
**작업**:
- keydown, keyup 이벤트 리스너 등록
- 눌린 키 상태 저장 객체 생성
  keys = { w: false, a: false, s: false, d: false, ... }
- 콘솔에 키 상태 출력
**테스트**:
- W 키 누르면 콘솔에 "W pressed" 출력
- W 키 떼면 "W released" 출력
**성공 기준**:
- 모든 필요한 키(W,A,S,D,Q,E,Space,Shift) 감지
- 동시에 여러 키 눌림 처리

---

## 4단계: 비행기 기본 이동
**목표**: 키보드로 비행기 움직이기
**작업**:
- W/S 키: Z축 이동 (앞/뒤)
- A/D 키: Y축 회전 (좌/우)
- 속도 변수 추가 (speed = 0.5)
- 매 프레임마다 키 상태 확인하여 위치 업데이트
**테스트**:
- W 누르면 비행기가 앞으로 이동
- S 누르면 뒤로 이동
- A 누르면 좌회전
- D 누르면 우회전
**성공 기준**:
- 부드러운 이동 (끊김 없음)
- 여러 키 동시 입력 시 조합 동작

---

## 5단계: 3D 회전 (피치, 롤)
**목표**: Q/E 키로 상하 회전
**작업**:
- Q/E 키: X축 회전 (위/아래)
- 회전 속도 설정 (rotationSpeed = 0.05)
- Euler 각도로 회전 적용
**테스트**:
- Q 누르면 기수가 위로
- E 누르면 기수가 아래로
**성공 기준**:
- 자연스러운 비행기 움직임
- 360도 회전 가능

---

## 6단계: 카메라 추적
**목표**: 카메라가 비행기를 따라다님
**작업**:
- 카메라를 비행기 뒤쪽 상대 위치에 고정
  offset = (0, 3, 8)
- 매 프레임 비행기 회전에 맞춰 오프셋 조정
- 카메라가 항상 비행기를 바라보게
  (camera.lookAt(airplane.position))
**테스트**:
- 비행기 이동 시 카메라가 따라옴
- 비행기 회전 시 카메라도 회전
- 비행기가 항상 화면 중앙
**성공 기준**:
- 부드러운 카메라 움직임
- 비행기가 화면 밖으로 나가지 않음

---

## 7단계: 간단한 환경 추가
**목표**: 하늘과 땅 추가
**작업**:
- Sky: 파란색 배경 (scene.background)
- Ground: 큰 평면 (PlaneGeometry)
  녹색, 아래쪽에 배치
- Fog 추가 (거리감)
**테스트**:
- 하늘이 파란색
- 바닥이 보임
- 멀리 있으면 흐릿해짐
**성공 기준**:
- 공간감 느껴짐
- 비행기와 환경의 크기 비율 적절

---

## 8단계: 물리 엔진 통합
**목표**: Cannon.js 물리 세계 연결
**작업**:
- Cannon.World 생성
- 중력 설정 (0, -9.8, 0)
- 비행기에 RigidBody 추가
- 매 프레임 물리 시뮬레이션 업데이트
- ThreeJS 오브젝트 위치를 물리 바디와 동기화
**테스트**:
- 비행기에 중력 적용되는가?
  (엔진 끄면 떨어짐)
**성공 기준**:
- 물리 시뮬레이션 60fps
- ThreeJS와 물리 동기화

---

## 9단계: 비행 물리 (양력)
**목표**: 현실적인 비행 느낌
**작업**:
- 속도에 비례한 양력 계산
- 비행기 각도에 따른 양력 방향
- 실속 메커니즘 (속도 너무 느리면 떨어짐)
**테스트**:
- 빠르게 날면 올라감
- 느리면 떨어짐
- 각도 조절로 고도 변경
**성공 기준**:
- 최소 속도 이하에서 실속
- 자연스러운 비행 궤적

---

## 10단계: 부스터 시스템
**목표**: Shift로 가속
**작업**:
- Shift 키 감지
- 속도 1.5배 증가
- 시각 효과 (파티클 또는 색 변경)
- 쿨다운 시스템 (3초 사용, 5초 재충전)
**테스트**:
- Shift로 빨라짐
- 일정 시간 후 원래 속도
- 쿨다운 중 재사용 불가
**성공 기준**:
- UI에 쿨다운 타이머 표시
- 부드러운 속도 전환

---

## 11단계: 서버 기본 설정
**목표**: Express + Socket.io 서버
**작업**:
- Express 서버 생성 (포트 3001)
- Socket.io 초기화
- 클라이언트 연결 처리
- 연결/해제 로그 출력
**테스트**:
- 서버 실행 시 "Server running on 3001" 출력
- 클라이언트 접속 시 "Player connected" 로그
**성공 기준**:
- 여러 클라이언트 동시 연결 가능
- 연결 해제 시 정리

---

## 12단계: 위치 동기화
**목표**: 플레이어 위치 서버에 전송
**작업**:
- 클라이언트: 0.05초마다 위치 전송
  socket.emit('update', { position, rotation })
- 서버: 모든 클라이언트에 브로드캐스트
- 다른 플레이어 비행기 생성/업데이트
**테스트**:
- 2개 브라우저 창 열기
- 한 창에서 움직이면 다른 창에서 보임
**성공 기준**:
- 지연 < 100ms
- 부드러운 움직임 (보간 적용)

---

## 13단계: 미사일 발사
**목표**: Space로 미사일 발사
**작업**:
- Space 키로 미사일 생성
- 비행기 앞쪽에서 출발
- 직선으로 빠르게 이동
- 3초 후 자동 소멸
**테스트**:
- Space 누르면 미사일 발사
- 미사일이 직선으로 날아감
- 시간 지나면 사라짐
**성공 기준**:
- 재장전 시간 1초
- 화면에 최대 5개까지만

---

## 14단계: 충돌 감지
**목표**: 미사일이 비행기에 맞으면 감지
**작업**:
- Cannon.js 충돌 이벤트 리스너
- 미사일과 비행기 충돌 체크
- 충돌 시 콘솔 로그
**테스트**:
- 미사일이 비행기에 맞으면 "Hit!" 출력
**성공 기준**:
- 정확한 충돌 감지
- 관통하지 않음

---

## 15단계: 체력 시스템
**목표**: HP 개념 추가
**작업**:
- 각 플레이어 HP = 100
- 미사일 맞으면 -20
- HP 0이면 리스폰
- UI에 HP 바 표시
**테스트**:
- 미사일 맞으면 HP 감소
- 5발 맞으면 격추
- HP 바가 시각적으로 업데이트
**성공 기준**:
- 정확한 HP 계산
- 모든 플레이어에게 HP 동기화

---

## 16단계: 킬/데스 시스템
**목표**: 점수 기록
**작업**:
- 각 플레이어 킬/데스 카운트
- 격추 시 킬+1, 데스+1
- 서버에서 점수 관리
- UI에 리더보드 표시
**테스트**:
- 상대 격추 시 킬 증가
- 격추당하면 데스 증가
- 리더보드에 실시간 반영
**성공 기준**:
- 정확한 점수 계산
- 순위 정렬

---

## 17단계: 리스폰 시스템
**목표**: 격추 후 부활
**작업**:
- HP 0 시 3초 대기
- 무작위 위치에 리스폰
- HP 100으로 초기화
- 3초간 무적
**테스트**:
- 격추 후 3초 뒤 부활
- 새 위치에서 시작
- 무적 상태 시각 효과
**성공 기준**:
- 다른 플레이어에게 리스폰 보임
- 무적 중 피해 없음

---

## 18단계: 게임 룸 시스템
**목표**: 여러 게임 방
**작업**:
- 방 생성/입장 기능
- 각 방은 독립된 게임 상태
- 최대 4명까지
- 로비 UI
**테스트**:
- 방 생성 후 다른 플레이어 입장
- 다른 방의 플레이어는 안 보임
**성공 기준**:
- 방 간 격리
- 입장/퇴장 처리

---

## 19단계: 기본 UI 완성
**목표**: 필요한 모든 UI
**작업**:
- 메인 메뉴
- 조작법 설명
- HP/부스터 게이지
- 미니맵
- 킬 피드
**테스트**:
- 모든 정보가 명확히 보임
- 게임 중 방해 안 됨
**성공 기준**:
- 직관적인 UI
- 반응형 디자인

---

## 20단계: 최적화 및 폴리싱
**목표**: 성능 개선 및 버그 수정
**작업**:
- 불필요한 렌더링 제거
- 네트워크 패킷 최적화
- 오브젝트 풀링
- 알려진 버그 수정
- 사운드 효과 추가
**테스트**:
- 4명 플레이 시 60fps 유지
- 네트워크 지연 < 100ms
- 크래시 없음
**성공 기준**:
- 안정적인 플레이
- 부드러운 경험
```

#### STEP 3: 검토 및 수정

**확인할 것:**
```
□ 각 단계가 독립적으로 테스트 가능한가?
□ 순서가 논리적인가? (A 없이 B 불가능한 경우)
□ 단계가 너무 크지 않은가? (1-3시간 안에 완료)
□ 테스트 방법이 명확한가?
□ 코드가 아닌 지시사항인가?
```

**AI에게 재확인:**
```
프롬프트:
"이 구현 계획이 명확해?
 각 단계를 이해하는 데 질문 있어?"

AI가 10개 정도 질문함
→ 답변하고 계획 수정
```

### 💡 구현 계획 작성 팁

**TIP 1: "Hello World"부터**
```
1단계: 가장 기본
"화면에 뭔가 표시"

마지막 단계: 완전한 기능
```

**TIP 2: 마일스톤 설정**
```
Phase 1 (1-5단계): 기본 씬
Phase 2 (6-10단계): 단일 플레이
Phase 3 (11-15단계): 멀티플레이
Phase 4 (16-20단계): 완성

각 Phase 끝에 큰 테스트
```

**TIP 3: 의존성 고려**
```
A가 필요한 기능들:
- 2단계: 비행기 표시
- 3단계: 비행기 이동 (2단계 필요)
- 4단계: 카메라 추적 (3단계 필요)

순서 바꾸면 안 됨!
```

### ✅ 3단계 완료 체크리스트

```
□ AI에게 구현 계획 요청
□ 10-20단계로 나눔
□ 각 단계에 테스트 방법 포함
□ 코드 제외, 지시사항만
□ 의존성 확인 (순서 적절)
□ AI에게 명확성 재확인
□ implementation-plan.md 저장
□ 기본 게임만 포함 (세부 기능 제외)
```

---

## 4단계 - 메모리 뱅크 구축

### 🏦 메모리 뱅크란?

**쉬운 비유:**
```
프로젝트 = 회사
메모리 뱅크 = 회사의 문서 보관함

포함되는 것:
- 회사 규정 (게임 디자인 문서)
- 사용 장비 목록 (기술 스택)
- 업무 매뉴얼 (구현 계획)
- 작업 일지 (진행 상황)
- 조직도 (파일 구조)

새 직원(AI)이 오면:
→ 문서 보관함 읽고
→ 회사 이해하고
→ 일 시작
```

### 📁 메모리 뱅크 구조

```
프로젝트 폴더/
│
├── memory-bank/           ← 메모리 뱅크 폴더
│   ├── game-design-document.md
│   ├── tech-stack.md
│   ├── implementation-plan.md
│   ├── progress.md        ← 진행 상황 (빈 파일로 시작)
│   └── architecture.md    ← 파일 설명 (빈 파일로 시작)
│
├── client/                ← 프론트엔드 코드
├── server/                ← 백엔드 코드
├── shared/                ← 공통 코드
└── package.json
```

### 🔨 메모리 뱅크 만들기

#### STEP 1: 프로젝트 폴더 생성

**터미널에서:**
```bash
# 1. 원하는 위치로 이동
cd ~/Documents

# 2. 프로젝트 폴더 생성
mkdir sky-warriors
cd sky-warriors

# 3. VSCode로 열기
code .
```

#### STEP 2: memory-bank 폴더 생성

**VSCode에서:**
```
1. 좌측 탐색기에서 우클릭
2. "New Folder" 선택
3. 이름: memory-bank
4. Enter
```

**또는 터미널에서:**
```bash
mkdir memory-bank
```

#### STEP 3: 문서 파일들 이동

**이미 만든 문서들:**
```
1. game-design-document.md
2. tech-stack.md
3. implementation-plan.md
```

**이동 방법:**
```
드래그 앤 드롭:
바탕화면의 파일들을
→ VSCode의 memory-bank 폴더로

또는 복사:
원본 파일 복사
→ memory-bank에 붙여넣기
```

#### STEP 4: 빈 파일들 생성

**progress.md 생성:**
```markdown
# 진행 상황

## 완료된 단계

(아직 없음)

## 현재 진행 중

(시작 전)

## 다음 단계

1단계: 프로젝트 설정
```

**architecture.md 생성:**
```markdown
# 프로젝트 구조

## 폴더 구조

(아직 생성 안 됨)

## 주요 파일 설명

(구현 시작 후 작성)
```

### 🎯 각 파일의 역할

#### game-design-document.md
```
역할: 게임의 "설계도"
AI가 참조: 기능 추가 시
업데이트: 거의 안 함 (초기 1회)

예시:
"미사일 추가해줘"
→ AI가 GDD 읽고
→ 게임 컨셉과 맞는지 확인
→ 일관성 있게 구현
```

#### tech-stack.md
```
역할: 사용 기술 목록
AI가 참조: 코드 작성 시
업데이트: 거의 안 함

예시:
AI가 자동으로:
"ThreeJS 사용해서 3D 렌더링"
"Socket.io로 통신"
```

#### implementation-plan.md
```
역할: 할 일 목록 (TODO)
AI가 참조: 매 단계마다
업데이트: 가끔 (계획 변경 시)

예시:
"다음 단계 진행해줘"
→ AI가 plan 읽고
→ 현재 어느 단계인지 확인
→ 다음 단계 구현
```

#### progress.md ⭐
```
역할: 작업 일지
AI가 참조: 매 단계 시작 시
업데이트: 매 단계 완료 시

예시:
## 1단계 완료 (2025-10-12)
- ThreeJS 씬 생성 완료
- 카메라 설정 완료
- 렌더링 루프 작동
- 테스트: 브라우저에 검은 화면 표시됨

문제:
- 없음

다음 단계 주의사항:
- 비행기 모델 크기 조정 필요
```

#### architecture.md ⭐
```
역할: 코드 구조 설명서
AI가 참조: 파일 수정 시
업데이트: 주요 파일 추가 시

예시:
## client/src/game.js
- 메인 게임 로직
- ThreeJS 씬 관리
- 렌더링 루프

## client/src/airplane.js
- Airplane 클래스
- 비행기 움직임 로직
- 키 입력 처리

## server/index.js
- Express 서버
- Socket.io 연결 관리
- 플레이어 상태 동기화
```

### 🔐 메모리 뱅크의 힘

#### 힘 1: 맥락 유지

```
문제 상황:
새 채팅 시작
→ AI가 이전 내용 모름

해결:
"memory-bank 읽어줘"
→ AI가 프로젝트 전체 이해
→ 일관성 있게 작업
```

#### 힘 2: 에러 방지

```
없으면:
AI: "React로 만들까요? Vue로 만들까요?"
당신: "응? 정했었는데..."

있으면:
AI가 tech-stack.md 읽고
→ 자동으로 정해진 기술 사용
```

#### 힘 3: 협업 가능

```
팀원이 합류:
1. memory-bank 읽기
2. 프로젝트 전체 이해
3. 바로 작업 시작

AI도 마찬가지:
1. 문서 읽기
2. 컨텍스트 파악
3. 정확한 코드 생성
```

### 💡 메모리 뱅크 활용 팁

**TIP 1: 항상 최신 유지**
```
단계 완료 시마다:
□ progress.md 업데이트
□ architecture.md 업데이트

안 하면:
→ AI가 오래된 정보 참조
→ 꼬임
```

**TIP 2: 명확하게 작성**
```
❌ "버그 수정함"
✅ "충돌 감지 버그 수정:
    미사일이 비행기 뒤에서도
    충돌하던 문제 해결"
```

**TIP 3: AI에게 업데이트 시키기**
```
당신: "1단계 완료했어.
      progress.md에 기록해줘"

AI: [자동으로 작성]

당신: [확인만]
```

### ✅ 4단계 완료 체크리스트

```
□ 프로젝트 폴더 생성
□ memory-bank 폴더 생성
□ game-design-document.md 이동
□ tech-stack.md 이동
□ implementation-plan.md 이동
□ progress.md 빈 파일 생성
□ architecture.md 빈 파일 생성
□ VSCode로 프로젝트 폴더 열기
□ 모든 파일이 제자리에 있는지 확인
```

**폴더 구조 최종 확인:**
```
sky-warriors/
└── memory-bank/
    ├── game-design-document.md     ✅
    ├── tech-stack.md                ✅
    ├── implementation-plan.md       ✅
    ├── progress.md                  ✅
    └── architecture.md              ✅
```

---

## 5단계 - 실제 구현하기

### 🎬 드디어 코딩 시작!

**준비 완료:**
```
✅ 계획 수립 완료
✅ 메모리 뱅크 구축
✅ AI 도구 설치

이제 시작:
→ AI에게 단계별로 지시
→ 테스트
→ 다음 단계
```

### 🚀 첫 번째 프롬프트

#### STEP 1: AI 도구 실행

**VSCode 확장 프로그램 사용:**
```
1. VSCode에서 프로젝트 열기
2. Claude Code 또는 Codex 확장 클릭
3. 채팅 창 열림
```

**또는 터미널 사용:**
```bash
# Claude Code
claude

# 또는 Codex CLI
codex
```

#### STEP 2: 명확성 확인 프롬프트

**첫 프롬프트:**
```
memory-bank 폴더의 모든 문서를 읽어줘.

그리고 implementation-plan.md가
당신에게 명확한지 확인해줘.

100% 명확하게 이해하기 위해
필요한 모든 질문을 해줘.
```

**AI의 반응:**
```
AI: "문서들을 읽었습니다. 몇 가지 질문이 있습니다:

1. 비행기 모델을 직접 만드나요,
   아니면 외부 모델을 import하나요?

2. 물리 엔진의 time step은 어떻게 설정하나요?

3. 네트워크 동기화 빈도는 얼마나 자주인가요?

4. HP 시스템에서 팀킬은 가능한가요?

5. 맵 경계는 어떻게 처리하나요?

...

이 질문들에 답변해주시면
implementation-plan.md를 더 명확하게
업데이트하겠습니다."
```

#### STEP 3: 질문에 답변하기

**답변 예시:**
```
좋은 질문들이에요!

1. 비행기 모델: 직접 만들기 (ThreeJS 기본 도형 조합)
   나중에 3D 모델 교체 가능하게

2. Time step: 고정 60fps (1/60초)

3. 네트워크: 20Hz (0.05초마다)
   위치/회전만, 보간 적용

4. 팀킬: 없음 (일단 FFA만)

5. 맵 경계: 투명 벽 (500x500x500 박스)
   벗어나면 부드럽게 막힘

이 내용으로 implementation-plan.md
업데이트해 줘.
```

### 🎯 실제 구현 프롬프트

#### STEP 4: 첫 단계 시작

**프롬프트 (중요!):**
```
memory-bank의 모든 문서를 읽고,

implementation-plan.md의
1단계 (프로젝트 설정)를 진행해 줘.

주의사항:
- 2단계는 절대 시작하지 마
- 1단계만 완료
- 완료 후 멈추고 내가 테스트할게

내가 테스트를 완료하면:
- progress.md에 완료 내용 기록
- architecture.md에 생성된 파일 설명 추가
```

**왜 이렇게 프롬프트를 작성하나요?**
```
❌ "게임 만들어줘"
→ AI가 혼자 다 만듦
→ 통제 불가능
→ 결과 예측 불가

✅ "1단계만 해줘, 그리고 멈춰"
→ 단계별 확인
→ 문제 조기 발견
→ 완벽한 통제
```

#### STEP 5: AI의 작업

**AI가 하는 일:**
```
1. memory-bank 문서 읽기
2. implementation-plan.md의 1단계 확인
3. 필요한 파일 생성:
   - package.json
   - client/index.html
   - client/src/main.js
   - server/index.js
4. 패키지 설치 명령어 제시
5. 실행 방법 설명
```

**AI의 보고:**
```
AI: "1단계 완료했습니다!

생성된 파일:
- package.json (프로젝트 설정)
- client/index.html (HTML 파일)
- client/src/main.js (클라이언트 진입점)
- server/index.js (서버 파일)

다음 명령어를 실행해주세요:

```bash
npm install
npm run dev
```

브라우저에서 http://localhost:3000 접속하면
'Hello Sky Warriors'가 표시됩니다.

테스트 완료 후 알려주시면
progress.md와 architecture.md를 업데이트하겠습니다."
```

### 🧪 테스트하기

#### STEP 6: 실행 및 테스트

**터미널에서:**
```bash
# 패키지 설치
npm install

# 서버 실행
npm run dev
```

**브라우저에서:**
```
1. Chrome 열기
2. http://localhost:3000 접속
3. "Hello Sky Warriors" 확인
4. F12 눌러 콘솔 확인
   → 에러 없어야 함
```

**성공 기준:**
```
✅ 에러 없이 실행
✅ 브라우저에 메시지 표시
✅ 콘솔에 에러 없음
```

### 📝 완료 기록하기

#### STEP 7: 문서 업데이트

**프롬프트:**
```
1단계 테스트 완료했어!
정상 작동해.

이제:
1. progress.md에 완료 내용 기록
2. architecture.md에 파일 설명 추가

그리고 2단계 시작하지 말고 대기.
```

**AI가 업데이트:**

**progress.md:**
```markdown
# 진행 상황

## 완료된 단계

### 0단계: 프로젝트 설정 (2025-10-12)
**완료 내용**:
- npm 프로젝트 초기화
- 필요한 패키지 설치:
  - express, vite, threejs, cannon-es, socket.io
- 기본 폴더 구조 생성:
  - client/ (프론트엔드)
  - server/ (백엔드)
- Hello World 페이지 작동 확인

**테스트 결과**:
- ✅ npm run dev로 서버 실행
- ✅ localhost:3000에서 "Hello Sky Warriors" 표시
- ✅ 콘솔 에러 없음

**문제 및 해결**:
- 없음

**다음 단계 주의사항**:
- ThreeJS 씬 초기화 시 canvas 요소 확인
```

**architecture.md:**
```markdown
# 프로젝트 구조

## 폴더 구조
```
sky-warriors/
├── memory-bank/          # 문서 저장소
├── client/               # 프론트엔드
│   ├── index.html
│   └── src/
│       └── main.js
├── server/               # 백엔드
│   └── index.js
└── package.json
```

## 주요 파일 설명

### client/index.html
- 메인 HTML 파일
- canvas 요소 포함 (ThreeJS용)
- main.js 로드

### client/src/main.js
- 클라이언트 진입점
- 현재: Hello World 표시
- 다음: ThreeJS 씬 초기화 예정

### server/index.js
- Express 서버
- 정적 파일 제공 (client 폴더)
- 포트 3000에서 실행
```

### 🔄 워크플로우 반복

#### STEP 8: 다음 단계 진행

**Git 커밋 (선택, 하지만 강력 추천!):**
```bash
git add .
git commit -m "✅ 0단계 완료: 프로젝트 설정"
```

**새 채팅 시작:**
```
Claude Code: /clear
Codex: /new
```

**다음 단계 프롬프트:**
```
memory-bank의 모든 문서를 읽고,
progress.md를 보고 지금까지 완료된 작업을 파악한 다음,

implementation-plan.md의
1단계 (3D 씬 기본 설정)를 진행해 줘.

2단계는 시작하지 마.
완료 후 테스트 방법 알려줘.
```

**반복:**
```
1. AI가 구현
2. 테스트
3. 문서 업데이트
4. Git 커밋
5. 다음 단계

→ 전체 구현 계획 완료까지 반복!
```

### 💡 구현 중 팁

**TIP 1: Plan Mode 사용 (Claude Code)**
```
구현 전:
Shift + Tab → Plan Mode

AI가 먼저 계획 설명
→ 당신이 승인
→ 그 다음 구현

실수 방지!
```

**TIP 2: 자주 커밋**
```
각 단계 완료 시:
git commit

이유:
- 실수 시 되돌리기 쉬움
- 진행 상황 명확
- 협업 가능
```

**TIP 3: 막히면 되돌리기**
```
Claude Code:
/rewind

Codex/직접:
git reset --hard HEAD~1

→ 이전 단계로 돌아감
→ 다시 시도
```

**TIP 4: 음성 입력 (Superwhisper)**
```
타이핑 대신:
말로 자연스럽게 지시

"비행기가 너무 빨라,
 속도를 절반으로 줄이고
 회전도 좀 더 부드럽게 해줘"

→ 10배 빠름!
```

### ✅ 5단계 완료 체크리스트

```
□ AI 도구 실행 (Claude Code 또는 Codex)
□ memory-bank 읽기 프롬프트
□ 명확성 확인 (AI 질문에 답변)
□ 0단계 구현 요청
□ 테스트 완료
□ progress.md 업데이트
□ architecture.md 업데이트
□ Git 커밋
□ 다음 단계 진행 준비
```

**워크플로우 이해:**
```
계획 → 구현 → 테스트 → 기록 → 다음 단계
   ↑                                    ↓
   └────────────────────────────────────┘
              반복!
```

---

## 6단계 - 세부 기능 추가하기

### 🎨 기본 게임 완성 후

축하합니다! implementation-plan.md의 모든 단계를 완료했습니다.
이제 기본 게임이 작동합니다:
- ✅ 비행기가 날아다님
- ✅ 멀티플레이 가능
- ✅ 미사일 발사
- ✅ 충돌 감지
- ✅ 점수 시스템

**하지만 아직 부족한 것들:**
```
시각적 완성도:
- 비행기 모델이 너무 단순함
- 하늘이 밋밋함
- 폭발 효과 없음
- 사운드 없음

게임플레이:
- 무기가 하나뿐
- 파워업 없음
- 게임 모드 하나뿐
```

### 🎯 세부 기능 추가 전략

#### 전략 1: 기능별 작은 문서 만들기

**나쁜 방법 ❌:**
```
당신: "비행기 모델을 멋지게 만들어줘"
AI: [뭔가 만듦]
당신: "이게 아닌데..."
AI: "어떻게 하길 원하세요?"
당신: "음... 그냥 멋있게..."
```

**좋은 방법 ✅:**
```
1. feature-airplane-model.md 문서 작성
2. 구체적인 요구사항 명시
3. 참고 이미지 첨부
4. 단계별 구현 계획
5. AI에게 문서 기반으로 구현 요청
```

#### 전략 2: 우선순위 정하기

**충격! 모든 기능을 동시에 추가하면 실패합니다.**

**우선순위 예시:**
```
P0 (필수):
- 비행기 모델 개선
- 폭발 효과

P1 (중요):
- 사운드 효과
- 하늘 개선

P2 (좋으면):
- 파워업
- 새로운 무기

P3 (나중에):
- 게임 모드 추가
- 리플레이 시스템
```

### 🛩️ 실전 예시: 비행기 모델 개선

#### STEP 1: 기능 문서 작성

**파일: feature-airplane-model.md**
```markdown
# 비행기 모델 개선

## 목표
현재 기본 도형으로 만든 비행기를
실제 전투기처럼 보이게 개선

## 참고 이미지
F-16 전투기 (간소화 버전)

## 세부 요구사항

### 동체
- 앞쪽: 뾰족한 노즈콘
- 중간: 조종석 (투명 캐노피)
- 뒤쪽: 엔진 배기구

### 날개
- 메인 날개: 델타형
- 보조익 (ailerons) 표현
- 날개 끝에 미사일 하드포인트

### 꼬리
- 수직 안정판
- 수평 안정판

### 디테일
- 공기 흡입구 (양쪽)
- 랜딩 기어 (접힌 상태)
- 국적 마크 (데칼)

## 구현 계획

### 1단계: 동체 개선
- 원뿔형 노즈 (ConeGeometry)
- 조종석 캐노피 (SphereGeometry + 투명)
- 엔진 노즐 (CylinderGeometry)

**테스트**: 옆에서 봤을 때 전투기 실루엣

### 2단계: 날개 형상
- 델타 날개 (Custom Shape)
- 날개 두께 (Extrude)
- 보조익 컷아웃

**테스트**: 위에서 봤을 때 날개 각도 적절

### 3단계: 꼬리 날개
- 수직 안정판 (BoxGeometry)
- 수평 안정판 (PlaneGeometry)

**테스트**: 뒤에서 봤을 때 균형감

### 4단계: 디테일 추가
- 공기 흡입구
- 랜딩 기어
- 텍스처 (색상, 국적 마크)

**테스트**: 모든 각도에서 디테일 확인

### 5단계: 최적화
- 폴리곤 수 최소화
- LOD (Level of Detail) 적용
- 여러 대 동시에 표시 시 성능 확인

**테스트**: 4대 동시 60fps 유지

## 성공 기준
- 멀리서 봐도 전투기로 인식
- 성능 저하 없음
- 다른 플레이어에게도 동일하게 보임
```

#### STEP 2: 참고 자료 수집

**이미지:**
```
1. F-16 참고 이미지 다운로드
2. 프로젝트 폴더/references/ 저장
3. AI에게 이미지 보여주기
```

**3D 모델 (선택):**
```
무료 3D 모델 사이트:
- Sketchfab (무료 CC 라이선스)
- TurboSquid (무료 섹션)

주의: 라이선스 확인!
```

#### STEP 3: AI에게 구현 요청

**프롬프트:**
```
memory-bank의 모든 문서를 읽고,

@feature-airplane-model.md 파일을 참고해서
비행기 모델을 단계별로 개선해줘.

@references/f16-reference.jpg 이미지를 참고해서
비슷한 느낌으로.

1단계부터 시작.
각 단계마다 내가 확인할게.
```

#### STEP 4: 단계별 검토 및 조정

**1단계 완료 후:**
```
AI: "동체 개선 완료했습니다.
     노즈, 캐노피, 엔진 노즐 추가했어요."

당신: [테스트]
      "노즈가 너무 뾰족해.
       각도를 30도로 완만하게"

AI: [수정]

당신: "좋아! 다음 단계"
```

### 🎨 다른 세부 기능 예시

#### 폭발 효과

**간단한 방법:**
```markdown
# feature-explosion.md

## 구현 방법
1. 파티클 시스템 (ThreeJS Points)
2. 빨강/주황/노랑 색상 믹스
3. 0.5초 동안 확장
4. 점점 투명해짐

## 참고
- YouTube: "ThreeJS particle explosion tutorial"
```

#### 사운드 효과

**무료 사운드:**
```markdown
# feature-sounds.md

## 필요한 사운드
1. 엔진 소리 (루프)
2. 미사일 발사
3. 폭발
4. 히트마커

## 사운드 소스
- Freesound.org
- ZapSplat (무료 플랜)

## 구현
- Howler.js 라이브러리 사용
- 거리에 따른 볼륨 조절
```

#### 하늘 개선

**레벨별 접근:**

**레벨 1 (가장 간단):**
```
Skybox with gradient
- CSS gradient 배경
- 위: 진한 파랑
- 아래: 연한 파랑
```

**레벨 2 (중간):**
```
구름 추가
- 평면 스프라이트 여러 개
- 랜덤 배치
- 살짝 움직임
```

**레벨 3 (고급):**
```
Volumetric clouds
- 셰이더 사용
- 실시간 그림자
- 날씨 변화
```

### 💡 세부 기능 추가 팁

**TIP 1: 한 번에 하나씩**
```
❌ 동시에 10개 기능
→ 뭐가 문제인지 파악 어려움

✅ 하나씩 완성
→ 문제 생기면 바로 원인 파악
```

**TIP 2: 항상 백업**
```
새 기능 추가 전:
git commit -m "비행기 모델 개선 시작 전"

새 기능 완료 후:
git commit -m "비행기 모델 개선 완료"

문제 생기면:
git reset --hard [이전 커밋]
```

**TIP 3: 선택적 적용**
```
새 기능을 조건부로:

if (ENABLE_NEW_AIRPLANE_MODEL) {
  // 새 모델
} else {
  // 기존 모델 (백업)
}

→ 문제 생기면 즉시 끌 수 있음
```

### ✅ 6단계 완료 체크리스트

```
□ 추가할 기능 목록 작성
□ 우선순위 지정 (P0, P1, P2, P3)
□ 각 기능별 feature-xxx.md 문서 작성
□ 참고 자료 수집 (이미지, 예제)
□ 한 번에 하나씩 구현
□ 각 기능 완료 시 Git 커밋
□ 문제 생기면 되돌리기 준비
```

---

## 버그 해결과 막힘 돌파하기

### 🐛 버그는 친구다

**마인드셋 전환:**
```
❌ "또 버그야... 난 못해"
✅ "버그 발견! 고치면 한 단계 성장"

버그 = 학습 기회
```

### 🔍 체계적인 디버깅 프로세스

#### STEP 1: 버그 재현하기

**재현 가능한가?**
```
항상 발생: 쉬움 (재현 가능)
가끔 발생: 어려움 (조건 파악 필요)
한 번만 발생: 매우 어려움 (무시 가능?)
```

**재현 단계 기록:**
```markdown
# Bug Report

## 버그 설명
미사일이 가끔 벽을 통과함

## 재현 방법
1. 게임 시작
2. 비행기를 벽 가까이 이동
3. 벽을 향해 미사일 발사
4. 10번 중 3번 정도 통과함

## 예상 동작
미사일이 벽에 막혀야 함

## 실제 동작
가끔 벽을 통과함

## 환경
- 브라우저: Chrome 120
- OS: macOS
- 플레이어 수: 2명
```

#### STEP 2: 문제 위치 좁히기

**이진 탐색 방식:**
```
전체 코드가 문제?
→ 절반 주석 처리
   → 문제 남음? 왼쪽 절반이 문제
   → 문제 사라짐? 오른쪽 절반이 문제

반복해서 범위 좁히기
```

**콘솔 로그 활용:**
```javascript
// 미사일 발사 시
console.log('미사일 발사', missile.position);

// 충돌 감지 시
console.log('충돌 체크', missile.position, wall.position);

// 충돌 발생 시
console.log('충돌 발생!');

→ 어느 로그가 안 찍히는지 확인
```

#### STEP 3: AI에게 도움 요청

**효과적인 버그 보고 프롬프트:**
```
이런 버그가 발생했어:
[버그 설명]

재현 방법:
[단계별 재현 방법]

관련 코드:
```javascript
[문제가 있을 것 같은 코드]
```

콘솔 로그:
```
[에러 메시지 또는 로그]
```

스크린샷:
[버그가 보이는 스크린샷 첨부]

원인이 뭘까? 어떻게 고쳐?
```

### 🚫 자주 발생하는 버그 패턴

#### 버그 1: 타이밍 문제

**증상:**
```
"가끔" 작동 안 함
"처음엔" 되는데 "나중에" 안 됨
```

**원인:**
```javascript
// 나쁜 코드
if (airplane.model) {
  // 모델 사용
}

// 문제: model이 아직 로드 안 됐을 수 있음
```

**해결:**
```javascript
// 좋은 코드
airplane.model.addEventListener('load', () => {
  // 모델 로드 완료 후 실행
});

// 또는 Promise
await airplane.loadModel();
// 이제 안전하게 사용
```

#### 버그 2: 동기화 문제 (멀티플레이)

**증상:**
```
"내 화면에선" 맞았는데
"상대 화면에선" 안 맞음
```

**원인:**
```
클라이언트 예측과 서버 권한 불일치
```

**해결:**
```
원칙: 서버가 진실
1. 클라이언트에서 충돌 감지 (즉시 피드백)
2. 서버에 전송
3. 서버에서 재검증
4. 서버 결과를 모든 클라이언트에 전송
5. 클라이언트는 서버 결과로 업데이트
```

#### 버그 3: 메모리 누수

**증상:**
```
시간 지날수록 점점 느려짐
브라우저 탭이 멈춤
```

**원인:**
```javascript
// 나쁜 코드
function shootMissile() {
  const missile = new Missile();
  // missile을 scene에 추가
  // ❌ 제거 안 함!
}

// 미사일이 계속 쌓임
```

**해결:**
```javascript
// 좋은 코드
function shootMissile() {
  const missile = new Missile();
  scene.add(missile);

  setTimeout(() => {
    scene.remove(missile);
    missile.geometry.dispose();
    missile.material.dispose();
    // ✅ 완전히 제거
  }, 3000);
}
```

### 🛠️ 막힘 돌파 전략

#### 전략 1: /rewind (Claude Code)

```
상황: AI가 잘못된 방향으로 코드 작성

해결:
1. /rewind 명령어
2. 이전 상태로 돌아감
3. 프롬프트 수정해서 다시 시도
```

#### 전략 2: Git Reset

```bash
# 상황: 여러 단계 진행했는데 다 잘못됨

# 해결 1: 마지막 커밋으로
git reset --hard HEAD~1

# 해결 2: 특정 커밋으로
git log  # 커밋 목록 확인
git reset --hard [커밋 해시]
```

#### 전략 3: 전체 코드베이스 공유

**막혔을 때:**
```
1. RepoPrompt 사용
   → repoprompt.com
   → 전체 코드를 하나의 텍스트로

2. GPT-5 또는 Claude에게:
   "이 프로젝트 전체 코드야.
    [문제 설명]
    어디가 문제일까?"

3. 새로운 시각으로 문제 파악
```

#### 전략 4: BrowserTools

**자동 에러 수집:**
```
1. BrowserTools 확장 설치
2. 브라우저 에러 자동 수집
3. 스크린샷 자동 캡처
4. AI에게 자동 전송

→ 수동 복붙 불필요!
```

### 💡 디버깅 팁

**TIP 1: 에러 메시지를 두려워하지 마**
```
에러 메시지 = 지도

"이 줄에 문제 있어요"
"이런 타입이어야 하는데 저런 타입이에요"

→ 정확한 위치와 원인 알려줌
```

**TIP 2: 절반씩 주석 처리**
```
100줄 코드 중 어디가 문제?

1. 50줄 주석 처리
   문제 남음? → 위쪽 50줄이 문제
   문제 사라짐? → 아래쪽 50줄이 문제

2. 25줄 주석 처리
   (반복)

3. 정확한 줄 찾기
```

**TIP 3: 최소 재현 예제 만들기**
```
복잡한 프로젝트에서 버그?

→ 최소한의 코드로 버그 재현
→ 다른 요소 제거
→ 핵심만 남김

→ 문제 파악 쉬워짐
```

### ✅ 디버깅 체크리스트

```
버그 발생 시:
□ 재현 가능한가?
□ 재현 단계 기록
□ 에러 메시지 전체 복사
□ 콘솔 로그 확인 (브라우저 + 터미널)
□ 관련 코드 파악
□ AI에게 구조화된 질문
□ 해결 후 Git 커밋 (수정 내용 기록)

막혔을 때:
□ /rewind 또는 git reset 고려
□ 전체 코드베이스 공유
□ 커뮤니티에 질문 (Discord, Reddit)
□ 하루 쉬고 다음날 다시 (진짜 효과적!)
```

---

## 프로 팁과 도구 활용

### 🎯 Claude Code 고급 기능

#### /rewind - 시간 되돌리기

**언제 사용:**
```
- AI가 잘못된 방향으로 코드 작성
- 실험하다 망침
- 이전이 더 나았음
```

**사용법:**
```
/rewind

→ 이전 상태로 돌아감
→ 프롬프트 수정
→ 다시 시도
```

#### Custom Commands - 자주 쓰는 명령어 저장

**예시 1: 코드 분석 명령어**
```
/explain [코드 부분]

실제 프롬프트:
"[코드 부분]이 어떻게 작동하는지 깊이 분석해줘.

 다음을 포함해서:
 1. 전체 흐름
 2. 각 함수 역할
 3. 의존성
 4. 잠재적 문제점

 분석 완료 후 내가 수정 작업 알려줄게."
```

**예시 2: 에러 해결 명령어**
```
/debug [에러 메시지]

실제 프롬프트:
"다음 에러를 분석하고 해결 방법 제시해줘:
 [에러 메시지]

 관련 있을 것 같은 코드 찾아서
 문제 파악하고 수정 방법 알려줘."
```

#### /compact - 맥락 압축

**언제 사용:**
```
대화가 너무 길어졌는데
이전 내용이 필요할 때
```

**효과:**
```
긴 대화 히스토리를 요약으로 압축
→ 토큰 절약
→ 이전 맥락 유지
```

### 🚀 --yolo 모드 (위험하지만 빠름)

**일반 모드:**
```
AI: "파일 3개를 수정하려고 해요. 괜찮아요?"
당신: "네"
AI: [수정]
AI: "파일 5개를 더 만들려고 해요. 괜찮아요?"
당신: "네"
AI: [생성]
...
```

**--yolo 모드:**
```bash
claude --dangerously-skip-permissions
# 또는
codex --yolo
```

```
AI: [확인 없이 바로 실행]
AI: [파일 수정/생성]
AI: [완료 보고]

→ 10배 빠름!
⚠️ 하지만 위험!
```

**언제 사용:**
```
✅ 프로토타입 빠르게 만들 때
✅ 중요하지 않은 파일 수정
✅ Git 커밋 자주 해서 백업된 상태

❌ 중요한 프로덕션 코드
❌ 처음 시도하는 복잡한 작업
```

### 🎨 리소스 생성 도구 활용

#### 2D 스프라이트 - Nano Banana

**무엇:**
```
ChatGPT + Nano Banana 플러그인
→ 게임 캐릭터, 아이템 스프라이트 생성
```

**프롬프트 예시:**
```
"픽셀 아트 스타일로
 32x32 크기의
 빨간색 전투기 스프라이트
 위에서 본 시점"
```

#### 음악 - Suno

**사용법:**
```
1. suno.ai 접속
2. 장르/분위기 선택
3. 생성 (무료: 5곡/일)
4. 다운로드 → 프로젝트에 추가
```

**프롬프트 예시:**
```
"Epic orchestral battle music
 fast tempo
 electronic elements
 game soundtrack"
```

#### 효과음 - ElevenLabs

**사용법:**
```
1. elevenlabs.io 접속
2. Sound Effects 메뉴
3. "explosion sound" 입력
4. 생성 및 다운로드
```

### 💬 음성 입력 - Superwhisper

**설정:**
```
1. Superwhisper 설치
2. 단축키 설정 (예: Cmd+Shift+Space)
3. AI 도구 채팅창 활성화
4. 단축키 → 말하기 → 자동 입력
```

**실전 활용:**
```
[단축키 누름]
당신: "비행기 속도가 너무 느린 것 같아.
      기본 속도를 10에서 15로 올리고,
      부스터 사용 시 25로 해줘.
      그리고 가속도도 좀 더 부드럽게"
[자동으로 텍스트 입력됨]
```

**장점:**
```
- 타이핑보다 10배 빠름
- 자연스러운 설명 가능
- 생각하면서 말하기 가능
```

### 🎬 효율적인 프롬프트 작성법

#### 깊은 사고 유도 프롬프트

**일반 프롬프트:**
```
"충돌 감지 개선해줘"
```

**프로 프롬프트:**
```
"충돌 감지를 개선해줘.

시간을 충분히 가지고 깊이 생각해.
나는 급하지 않아.
중요한 건 정확하게 구현하는 거야.

내 요청이 명확하지 않으면 질문해줘."
```

#### Claude 전용: 사고 깊이 조절

```
think          → 기본 사고
think hard     → 더 깊은 사고
think harder   → 매우 깊은 사고
ultrathink     → 최대 깊이 사고

예시:
"ultrathink

물리 엔진의 충돌 감지를 완벽하게 구현해줘.
모든 엣지 케이스를 고려해."
```

### 🔧 디버깅 도구

#### Chrome DevTools 활용

**Performance 탭:**
```
1. F12 → Performance
2. Record 클릭
3. 게임 플레이
4. Stop
5. 어느 함수가 오래 걸리는지 확인

→ 최적화할 부분 파악
```

**Network 탭:**
```
1. F12 → Network
2. WS (WebSocket) 필터
3. 메시지 확인

→ 서버 통신 디버깅
```

#### ThreeJS Inspector

**설치:**
```
Chrome 웹 스토어:
"Three.js Developer Tools" 검색
```

**기능:**
```
- Scene 계층 구조 확인
- 오브젝트 위치/회전 실시간 조절
- 재질/텍스처 확인
- 성능 분석
```

### ✅ 프로 팁 체크리스트

```
□ Custom Commands 설정
□ --yolo 모드 조건부 사용
□ 음성 입력 도구 활용
□ 깊은 사고 유도 프롬프트 사용
□ 리소스 생성 AI 활용
□ 브라우저 DevTools 숙지
□ ThreeJS Inspector 설치
```

---

## 9. 실전 워크플로우 완벽 정리

### 📋 전체 개발 흐름 한눈에

**처음부터 끝까지:**
```
1주차: 계획 및 문서화
└─ GDD 작성
└─ Tech Stack 선정
└─ Implementation Plan 작성
└─ Memory Bank 구성

2-4주차: 기본 게임 구현
└─ Step 1 구현 → 테스트 → 커밋
└─ Step 2 구현 → 테스트 → 커밋
└─ ...
└─ Step N 구현 → 테스트 → 커밋

5-6주차: 세부 기능 추가
└─ Feature 1 구현
└─ Feature 2 구현
└─ ...

7주차: 버그 수정 및 최적화
└─ 버그 리스트 작성
└─ 하나씩 해결
└─ 성능 최적화

8주차: 배포 준비
└─ 최종 테스트
└─ 배포
```

### 🔄 매일의 개발 루틴

#### 아침 (30분)
```
□ Git pull (팀 작업 시)
□ memory-bank/progress.md 읽기
   → 어제까지 뭐 했는지 확인
□ 오늘 할 작업 정하기
□ Claude Code / Codex 실행
```

#### 개발 시간 (2-4시간)
```
□ 새 대화 시작 (/new 또는 /clear)
□ 프롬프트:
   "memory-bank 모든 파일 읽고,
    progress.md에서 이전 작업 확인하고,
    implementation-plan의 Step X 진행해줘.

    테스트 완료 후 progress.md 업데이트하고,
    architecture.md에 아키텍처 변경사항 기록해줘."

□ AI 작업 → 테스트
□ 문제 있으면 수정 요청
□ 완료되면 Git 커밋
```

#### 저녁 (30분)
```
□ 오늘 작업 점검
□ progress.md에 요약 작성
□ 내일 할 일 메모
□ Git push (팀 작업 시)
```

### 🎯 상황별 워크플로우

#### 상황 1: 새로운 기능 추가

**프로세스:**
```
1. feature-[기능명].md 문서 작성
   □ 목표
   □ 요구사항
   □ 구현 단계
   □ 각 단계별 테스트

2. 참고 자료 수집
   □ 이미지
   □ 비슷한 예제 코드
   □ 튜토리얼 링크

3. Git 브랜치 생성 (선택)
   git checkout -b feature/[기능명]

4. AI에게 단계별 구현 요청
   /new
   "memory-bank 모든 파일 읽고,
    @feature-[기능명].md 참고해서
    단계별로 구현해줘.
    각 단계마다 내가 확인할게."

5. 각 단계 테스트 및 조정

6. 완료 후 커밋
   git commit -m "feat: [기능명] 구현"

7. 메인 브랜치 병합 (선택)
   git checkout main
   git merge feature/[기능명]
```

#### 상황 2: 버그 발견

**프로세스:**
```
1. 버그 재현 확인
   □ 항상 발생?
   □ 특정 조건에서만?

2. bugs/bug-[설명].md 작성
   □ 버그 설명
   □ 재현 방법
   □ 예상 동작 vs 실제 동작
   □ 에러 로그
   □ 스크린샷

3. AI에게 분석 요청
   /new
   "@bugs/bug-[설명].md 참고해서
    원인 분석해줘.

    관련 있을 것 같은 코드:
    ```
    [의심가는 코드 복사]
    ```

    해결 방법 제시해줘."

4. 제안된 해결책 적용

5. 테스트
   □ 버그 재현 안 됨 확인
   □ 다른 부분에 영향 없는지 확인

6. 커밋
   git commit -m "fix: [버그 설명] 해결"
```

#### 상황 3: 막혔을 때

**프로세스:**
```
1. 10분 휴식
   □ 자리에서 일어나기
   □ 산책 또는 스트레칭

2. 문제 재정의
   □ 정확히 뭐가 막혔는지
   □ 목표가 명확한지
   □ 다른 방법은 없는지

3. 외부 도움

   Option A: 전체 코드 분석
   → RepoPrompt로 전체 코드 텍스트화
   → GPT-5나 Claude에게 상황 설명

   Option B: 커뮤니티
   → Discord/Reddit에 질문
   → 구체적인 재현 예제 포함

   Option C: 방향 전환
   → 다른 기능부터 구현
   → 나중에 다시 시도

4. /rewind 또는 Git reset
   → 이전 상태로 돌아가기
   → 다른 접근 시도
```

### 📊 진행 상황 추적

#### progress.md 관리

**구조:**
```markdown
# 프로젝트 진행 상황

## 2025-10-12
### 완료
- ✅ Step 5: 충돌 감지 시스템 구현
  - Cannon.js 물리 엔진 통합
  - 미사일-비행기 충돌 감지
  - 비행기-지형 충돌 감지
  - 테스트: 모든 충돌 정상 감지

### 문제 및 해결
- 🐛 미사일이 가끔 벽 통과
  - 원인: 물리 업데이트 주기가 렌더링보다 느림
  - 해결: fixedTimeStep 0.016으로 조정

### 다음 단계
- Step 6: 점수 시스템 구현

## 2025-10-11
...
```

#### architecture.md 관리

**구조:**
```markdown
# 프로젝트 아키텍처

## 폴더 구조
```
project/
├── client/
│   ├── src/
│   │   ├── game/          # 게임 로직
│   │   ├── network/       # 네트워킹
│   │   ├── rendering/     # 렌더링
│   │   └── physics/       # 물리
│   └── assets/            # 에셋
└── server/
    ├── src/
    │   ├── game-server.js # 게임 서버
    │   └── room.js        # 방 관리
    └── ...
```

## 주요 파일 설명

### client/src/game/Game.js
- 메인 게임 클래스
- 게임 루프 관리
- 입력 처리
- 의존성: Renderer, PhysicsEngine, NetworkClient

### client/src/network/NetworkClient.js
- 서버 연결 관리
- 메시지 송수신
- 의존성: Socket.io-client

...
```

### 🔄 Git 워크플로우

#### 커밋 전략

**커밋 메시지 규칙:**
```
feat: 새로운 기능 추가
fix: 버그 수정
docs: 문서 수정
style: 코드 포맷팅
refactor: 리팩토링
test: 테스트 추가
chore: 기타 작업

예시:
git commit -m "feat: 비행기 모델 개선 (동체, 날개, 꼬리)"
git commit -m "fix: 미사일 벽 통과 버그 해결"
git commit -m "docs: implementation-plan Step 6 완료 표시"
```

#### 브랜치 전략 (선택)

**간단한 프로젝트:**
```
main 브랜치만 사용
→ 모든 작업 직접 커밋
→ 단계별로 자주 커밋
```

**팀 프로젝트:**
```
main (안정 버전)
├── feature/airplane-model
├── feature/explosion-effects
└── bugfix/missile-collision

각 기능/버그 수정을 브랜치로
완료 후 main에 병합
```

### ⚡ 효율 최적화 팁

**TIP 1: 템플릿 프롬프트 저장**
```
자주 쓰는 프롬프트를 파일로:

templates/prompt-new-step.txt:
"memory-bank의 모든 파일을 읽고,
progress.md에서 이전 작업을 확인한 후,
implementation-plan.md의 Step X를 진행해줘.

테스트 완료 후:
1. progress.md 업데이트
2. architecture.md에 구조 변경사항 기록

Step X+1은 내가 확인 후 시작해."

→ 복사 붙여넣기로 빠르게 사용
```

**TIP 2: 대화 히스토리 관리**
```
새로운 단계마다 /new 또는 /clear
→ 맥락 초기화
→ memory-bank에서 다시 로드
→ AI가 혼란 없이 작업

예외: 같은 파일 계속 수정 시
→ 대화 유지
→ 맥락 활용
```

**TIP 3: 작업 단위 작게**
```
큰 작업을 작은 단위로:

❌ "게임 전체 완성해줘"
   → 너무 큼, 뭘 먼저 할지 모름

✅ "Step 1만 구현해줘"
   → 명확함, 테스트 가능

✅ "비행기 동체만 개선해줘"
   → 구체적, 검증 쉬움
```

### ✅ 워크플로우 체크리스트

**매일 시작 시:**
```
□ memory-bank/progress.md 읽기
□ 오늘 목표 정하기 (1-2개만)
□ Git status 확인
□ 개발 환경 실행 (npm run dev 등)
```

**작업 중:**
```
□ 한 번에 하나의 작업만
□ 자주 테스트
□ 에러 발생 시 즉시 해결
□ 진행 상황 메모
```

**작업 완료 후:**
```
□ 테스트 통과 확인
□ Git 커밋
□ progress.md 업데이트
□ architecture.md 업데이트 (구조 변경 시)
```

**하루 마무리:**
```
□ 모든 변경사항 커밋 확인
□ 내일 할 일 메모
□ 메모리 정리 (memory-bank 파일들 정리)
```

---

## 10. 자주 묻는 질문 (FAQ)

### 💻 기술 관련

**Q1: 앱을 만들고 싶은데, 게임과 같은 방법인가요?**

**A:**
네, 거의 동일합니다!

차이점:
```
게임:
- GDD (Game Design Document)
- 게임 메카닉 중심
- 실시간 인터랙션

앱:
- PRD (Product Requirements Document)
- 비즈니스 로직 중심
- 데이터 관리 중심
```

프로세스는 동일:
```
1. PRD 작성 (대신 GDD)
2. Tech Stack 선정
3. Implementation Plan
4. Memory Bank 구성
5. 단계별 구현
```

추가 팁:
```
앱 프로토타입 먼저 만들기:
- v0.dev
- Lovable.dev
- Bolt.new

→ 프로토타입 생성
→ GitHub에 push
→ 클론해서 로컬에서 계속 개발
```

---

**Q2: 비행기 모델이 30개 프롬프트나 필요하다고요?**

**A:**
네, 복잡한 3D 모델은 한 번에 안 됩니다!

**잘못된 기대:**
```
당신: "멋진 전투기 만들어줘"
AI: [뭔가 만듦]
당신: "...이게 뭐야"
```

**현실적인 접근:**
```
feature-airplane.md 작성:
1. 동체 개선
2. 날개 형상
3. 꼬리 날개
4. 디테일 추가
5. 최적화

각 단계마다:
- 구현
- 테스트
- 피드백
- 조정

총 30번의 대화 = 5단계 × 6번 조정
```

**팁:**
```
한 번에 완벽한 결과 기대 ❌
점진적 개선 접근 ✅

"노즈를 더 뾰족하게"
"날개 각도를 20도로"
"공기 흡입구를 양쪽에"

→ 구체적인 피드백
→ 원하는 결과에 도달
```

---

**Q3: Claude Code / Codex CLI가 Cursor보다 나은 이유는?**

**A:**
개인 취향이지만, 몇 가지 장점이 있습니다:

**Claude Code 장점:**
```
1. Claude Sonnet 4.5 최적화
   → Cursor보다 더 나은 통합

2. 터미널에서 실행
   → 모든 IDE 사용 가능
   → 원격 서버 SSH 접속 후 사용
   → 더 많은 워크플로우

3. 강력한 커스터마이징
   → Custom Commands
   → Sub-agents
   → Hooks

4. 저렴한 플랜으로 시작 가능
   → Claude Pro가 아니어도 OK
```

**Codex CLI 장점:**
```
1. GPT-5 최적화
   → Cursor보다 더 나은 GPT-5 활용

2. 빠른 응답 속도

3. 강력한 멀티에이전트 시스템
```

**Cursor 장점:**
```
1. UI가 직관적
2. IDE 통합 (VSCode 기반)
3. 초보자 친화적
```

**결론:**
```
초보자 → Cursor로 시작
익숙해지면 → Claude Code / Codex CLI
```

---

**Q4: 멀티플레이 서버를 어떻게 설정하나요?**

**A:**
AI에게 물어보세요! 진심입니다.

**프롬프트:**
```
"Node.js와 Socket.io로
멀티플레이 게임 서버 만들고 싶어.

클라이언트:
- ThreeJS로 만든 비행기 게임
- 최대 8명 플레이어

서버:
- 플레이어 위치 동기화
- 미사일 발사/충돌 서버 검증
- 방 생성/입장 기능

tech-stack.md와 game-design-document.md 참고해서
서버 구조 제안하고
step-by-step으로 구현해줘."
```

**AI가 알려줄 것:**
```
1. Express + Socket.io 서버 설정
2. 방(Room) 관리 시스템
3. 플레이어 상태 동기화
4. 서버 권한 검증 (안티치트)
5. 배포 방법 (Heroku, Railway 등)
```

**로컬 테스트:**
```bash
# 서버 실행 (터미널 1)
cd server
npm start
# → http://localhost:3000

# 클라이언트 실행 (터미널 2)
cd client
npm run dev
# → http://localhost:5173

# 테스트: 브라우저 여러 개 열기
```

---

**Q5: Git을 처음 써보는데 어렵지 않나요?**

**A:**
기본 명령어 5개만 알면 됩니다!

**필수 명령어:**
```bash
# 1. 초기화 (프로젝트 시작할 때 한 번)
git init
git add .
git commit -m "Initial commit"

# 2. 저장 (작업 완료할 때마다)
git add .
git commit -m "feat: 비행기 모델 개선"

# 3. 되돌리기 (실수했을 때)
git reset --hard HEAD~1  # 마지막 커밋 취소

# 4. 확인
git status  # 현재 상태
git log     # 커밋 히스토리

# 5. GitHub 연동 (선택)
git remote add origin [GitHub URL]
git push -u origin main
```

**더 배우고 싶다면:**
```
AI에게:
"Git 기초 사용법 알려줘.
초보자가 바이브 코딩하면서
사용할 명령어 위주로."

→ 맞춤형 설명 들을 수 있음
```

---

**Q6: 프롬프트를 잘 못 쓰는데 괜찮나요?**

**A:**
괜찮습니다! 대화하듯이 쓰면 됩니다.

**나쁜 예 ❌:**
```
"코드"
"고쳐"
"안 돼"
```

**좋은 예 ✅:**
```
"비행기 속도가 너무 느린 것 같아.
좀 더 빠르게 만들어줄래?"

"이 코드:
[코드 복사]
를 보면 뭐가 문제인지 모르겠어.
설명해줄 수 있어?"

"충돌 감지가 가끔 안 돼.
벽에 부딪혔는데 통과할 때가 있어.
왜 그런 거고 어떻게 고쳐?"
```

**더 좋은 프롬프트 팁:**
```
추가 문구:
"시간을 충분히 갖고 생각해줘.
내가 요청한 걸 정확히 이해했는지
질문이 있으면 먼저 물어봐."

→ AI가 더 신중하게 작업
→ 결과가 더 좋음
```

---

**Q7: 에러가 너무 많이 나서 포기하고 싶어요**

**A:**
정상입니다! 모든 개발자가 겪는 과정이에요.

**마인드셋 전환:**
```
❌ "에러 = 내가 못하는 것"
✅ "에러 = 배울 기회"

AI 시대:
→ 에러 메시지 복사
→ AI에게 붙여넣기
→ 해결책 받기
→ 적용
→ 배우기

예전:
→ 에러 검색
→ Stack Overflow 뒤지기
→ 몇 시간 삽질
→ 포기
```

**실전 예시:**
```
에러 발생:
TypeError: Cannot read property 'position' of undefined

당신이 할 일:
1. 에러 메시지 전체 복사
2. AI에게:
   "이런 에러가 났어:
   [에러 붙여넣기]

   관련 코드:
   [코드 복사]

   뭐가 문제고 어떻게 고쳐?"

3. AI가 설명 + 해결책 제시
4. 적용
5. 해결!
```

**포기하고 싶을 때:**
```
1. 하루 쉬기
   → 다음날 보면 쉽게 해결

2. 다른 것부터 하기
   → 나중에 다시 시도

3. 커뮤니티에 물어보기
   → Discord, Reddit

중요: 모든 프로 개발자도
       매일 에러와 싸웁니다!
```

---

**Q8: 이 방법으로 실제 상용 게임/앱을 만들 수 있나요?**

**A:**
네! 하지만 추가 작업이 필요합니다.

**바이브 코딩으로 가능:**
```
✅ MVP (Minimum Viable Product)
✅ 프로토타입
✅ 인디 게임/앱
✅ 개인 프로젝트
✅ 포트폴리오
```

**상용화를 위해 추가 필요:**
```
1. 보안
   - 입력 검증
   - 데이터 암호화
   - 서버 보안

2. 최적화
   - 번들 사이즈 최소화
   - 로딩 속도 개선
   - 메모리 관리

3. 테스팅
   - 자동화 테스트
   - 부하 테스트
   - 다양한 기기 테스트

4. 운영
   - 모니터링
   - 에러 추적
   - 업데이트 시스템
```

**프로세스:**
```
1단계: 바이브 코딩으로 MVP
2단계: 사용자 피드백
3단계: AI + 전문가 협업으로 개선
4단계: 상용 배포

또는:

바이브 코딩으로 프로토타입
→ 투자 유치
→ 팀 꾸리기
→ 전문 개발
```

---

### ✅ FAQ 요약

```
□ 앱도 같은 방법으로 만들 수 있음 (PRD 사용)
□ 복잡한 기능은 여러 프롬프트 필요
□ Claude Code/Codex CLI > Cursor (고급 사용자)
□ 서버 설정도 AI에게 물어보면 됨
□ Git 기본 명령어 5개면 충분
□ 프롬프트는 대화하듯이 자연스럽게
□ 에러는 정상! AI에게 물어보면 해결
□ 상용화는 가능하지만 추가 작업 필요
```

---

## 11. 용어 설명 (가나다 순)

### ㄱ

**가속도 (Acceleration)**
- **의미**: 속도의 변화율
- **게임에서**: 비행기가 점점 빠르게 날아가는 효과
- **예시**: 부스터 사용 시 가속도가 높아져서 빠르게 가속됨

**게임 디자인 문서 (GDD - Game Design Document)**
- **의미**: 게임의 모든 요소를 설명하는 청사진
- **포함 내용**: 게임 메카닉, 스토리, 캐릭터, 레벨 디자인
- **비유**: 건물을 짓기 전 설계도
- **연관**: [[#1단계 - 게임 디자인 문서 (GDD) 만들기]]

**게임 루프 (Game Loop)**
- **의미**: 게임이 실행되는 동안 반복되는 핵심 사이클
- **구성**: 입력 처리 → 게임 상태 업데이트 → 렌더링
- **주기**: 보통 60fps (초당 60번)

**구름 (Clouds)**
- **기술**: Skybox, 스프라이트, 또는 Volumetric rendering
- **구현**: 평면 이미지 여러 개 또는 3D 볼륨 셰이더
- **연관**: [[#하늘 개선]]

**글로벌 상태 (Global State)**
- **의미**: 앱 전체에서 공유되는 데이터
- **예시**: 사용자 로그인 정보, 게임 점수
- **주의**: 너무 많으면 관리 어려움

### ㄴ

**네트워킹 (Networking)**
- **의미**: 여러 컴퓨터 간 데이터 통신
- **게임에서**: 멀티플레이를 위한 플레이어 위치/행동 동기화
- **기술**: WebSocket, Socket.io
- **연관**: [[#4단계 - 멀티플레이 서버 설정하나요?]]

**노즈콘 (Nose Cone)**
- **의미**: 비행기 또는 미사일의 뾰족한 앞부분
- **역할**: 공기 저항 감소
- **3D 모델링**: ConeGeometry로 표현

### ㄷ

**델타 날개 (Delta Wing)**
- **의미**: 삼각형 모양의 날개
- **특징**: 전투기에서 자주 사용 (F-16, F-22)
- **3D 모델링**: Custom Shape + Extrude

**동기화 (Synchronization)**
- **의미**: 여러 클라이언트의 게임 상태를 일치시키는 것
- **문제**: 네트워크 지연 (Latency)
- **해결**: 클라이언트 예측 + 서버 검증
- **연관**: [[#버그 2 - 동기화 문제]]

**디버깅 (Debugging)**
- **의미**: 코드의 버그를 찾아서 수정하는 과정
- **도구**: 콘솔 로그, 브레이크포인트, DevTools
- **연관**: [[#체계적인 디버깅 프로세스]]

### ㄹ

**랜딩 기어 (Landing Gear)**
- **의미**: 비행기의 바퀴
- **게임에서**: 디테일 표현용 (보통 접힌 상태)

**레이캐스팅 (Raycasting)**
- **의미**: 가상의 광선을 쏴서 충돌을 감지하는 기술
- **사용**: 클릭 감지, 시야 판정, 총알 궤적
- **ThreeJS**: Raycaster 클래스

**렌더링 (Rendering)**
- **의미**: 3D 데이터를 2D 화면에 그리는 과정
- **엔진**: ThreeJS, Babylon.js
- **최적화**: LOD, Frustum Culling, Occlusion Culling

**로컬 스토리지 (Local Storage)**
- **의미**: 브라우저에 데이터를 저장하는 방법
- **용량**: 약 5-10MB
- **사용**: 설정 저장, 진행 상황 저장

**리팩토링 (Refactoring)**
- **의미**: 기능은 그대로 두고 코드 구조를 개선하는 것
- **목적**: 가독성, 유지보수성 향상
- **원칙**: 작은 단위로, 테스트 유지

### ㅁ

**마이크로서비스 (Microservices)**
- **의미**: 큰 애플리케이션을 작은 서비스로 나누는 아키텍처
- **반대**: Monolith (모놀리스)
- **장점**: 독립적 배포, 확장성
- **단점**: 복잡도 증가

**메모리 누수 (Memory Leak)**
- **의미**: 더 이상 필요 없는 메모리를 해제하지 않아 쌓이는 현상
- **증상**: 시간 지날수록 느려짐, 결국 크래시
- **해결**: dispose() 호출, 이벤트 리스너 제거
- **연관**: [[#버그 3 - 메모리 누수]]

**메시 (Mesh)**
- **의미**: 3D 모델의 기본 단위
- **구성**: Geometry (형상) + Material (재질)
- **ThreeJS**: `new THREE.Mesh(geometry, material)`

**모놀리스 (Monolith)**
- **의미**: 모든 기능이 하나의 큰 파일/프로젝트에 있는 구조
- **문제**: 유지보수 어려움, 확장성 낮음
- **바이브 코딩**: 이것을 피하는 게 핵심!
- **연관**: [[#핵심 원칙 - AI에게 계획을 맡기지 마라!]]

**무한 루프 (Infinite Loop)**
- **의미**: 끝나지 않는 반복문
- **증상**: 브라우저 멈춤, 탭 크래시
- **예방**: 반복 조건 명확히, 최대 반복 횟수 설정

### ㅂ

**바이브 코딩 (Vibe Coding)**
- **의미**: AI에게 의도를 전달해서 코드를 생성하는 개발 방식
- **핵심**: 계획은 인간이, 구현은 AI가
- **도구**: Claude Code, Codex CLI, Cursor
- **연관**: [[#바이브 코딩이 뭐예요?]]

**번들 사이즈 (Bundle Size)**
- **의미**: 최종 배포되는 파일의 크기
- **중요성**: 작을수록 로딩 빠름
- **최적화**: Tree shaking, Code splitting, Minification

**보조익 (Ailerons)**
- **의미**: 날개 끝에 있는 조종 표면
- **역할**: 비행기의 롤(Roll) 제어
- **게임**: 디테일 표현용

**부스터 (Booster)**
- **의미**: 일시적으로 속도를 높이는 기능
- **게임에서**: 쿨다운, 에너지 소모 등 밸런스 필요

**불투명도 (Opacity)**
- **의미**: 물체의 투명한 정도 (0 = 완전 투명, 1 = 불투명)
- **사용**: 폭발 효과, 페이드 인/아웃
- **ThreeJS**: `material.opacity`, `material.transparent = true`

### ㅅ

**서버 권한 (Server Authority)**
- **의미**: 중요한 게임 판정은 서버에서 최종 결정
- **목적**: 치트 방지
- **예시**: 충돌 감지를 클라이언트에서 표시, 서버에서 검증

**소켓 (Socket)**
- **의미**: 네트워크 통신의 끝점
- **웹에서**: WebSocket - 실시간 양방향 통신
- **라이브러리**: Socket.io (추상화 + 기능 추가)

**스카이박스 (Skybox)**
- **의미**: 하늘을 표현하는 6면 큐브 텍스처
- **구현**: 거대한 박스 안에 카메라
- **효과**: 무한히 먼 배경

**스프라이트 (Sprite)**
- **의미**: 항상 카메라를 바라보는 2D 이미지
- **사용**: 구름, 파티클, UI
- **ThreeJS**: `THREE.Sprite`

**실시간 (Real-time)**
- **의미**: 즉각적인 반응 (보통 < 100ms)
- **게임**: 60fps = 16.67ms마다 화면 갱신
- **네트워킹**: 지연 최소화 필요

### ㅇ

**엔진 (Engine)**
- **의미**: 게임 또는 앱의 핵심 기능을 제공하는 라이브러리
- **종류**:
  - 렌더링: ThreeJS, Babylon.js
  - 물리: Cannon.js, Ammo.js
  - 게임: Unity, Unreal (바이브 코딩엔 안 씀)

**오브젝트 풀링 (Object Pooling)**
- **의미**: 오브젝트를 재사용해서 성능 향상
- **예시**: 미사일 100개를 만들지 말고, 10개를 만들어서 재사용
- **장점**: 메모리 할당/해제 오버헤드 감소

**웹소켓 (WebSocket)**
- **의미**: 웹에서 실시간 양방향 통신을 위한 프로토콜
- **기존 HTTP**: 요청 → 응답 (단방향)
- **WebSocket**: 양방향 지속 연결
- **사용**: 채팅, 멀티플레이 게임

**유한 상태 머신 (FSM - Finite State Machine)**
- **의미**: 상태와 전환 규칙으로 동작을 정의
- **예시**:
  ```
  IDLE → (스페이스바) → FLYING → (충돌) → EXPLODING → (3초) → RESPAWN
  ```

**이진 탐색 (Binary Search)**
- **의미**: 절반씩 나눠서 찾는 알고리즘
- **디버깅**: 코드 절반 주석 → 문제 위치 좁히기
- **연관**: [[#문제 위치 좁히기]]

**인덱스 (Index)**
- **의미**: 데이터의 위치를 가리키는 번호
- **배열**: 0부터 시작
- **데이터베이스**: 검색 속도 향상용 색인

### ㅈ

**좌표계 (Coordinate System)**
- **ThreeJS**:
  - X축: 좌우 (왼쪽이 -, 오른쪽이 +)
  - Y축: 상하 (아래가 -, 위가 +)
  - Z축: 앞뒤 (앞이 +, 뒤가 -)

**지연 (Latency)**
- **의미**: 데이터 전송의 지연 시간
- **멀티플레이**: 핑(Ping) 시간
- **허용**: < 100ms (쾌적), < 50ms (이상적)

**직렬화 (Serialization)**
- **의미**: 데이터를 전송 가능한 형태로 변환
- **예시**: JavaScript 객체 → JSON 문자열
- **반대**: Deserialization (역직렬화)

### ㅊ

**최적화 (Optimization)**
- **의미**: 성능을 개선하는 작업
- **원칙**: "측정 → 병목 찾기 → 개선 → 재측정"
- **주의**: 너무 이른 최적화는 악의 근원

**충돌 감지 (Collision Detection)**
- **의미**: 두 오브젝트가 겹치는지 확인
- **방법**:
  - AABB (Axis-Aligned Bounding Box) - 빠름
  - 구 충돌 (Sphere) - 중간
  - 메시 충돌 (Mesh) - 정확하지만 느림
- **라이브러리**: Cannon.js, Ammo.js

### ㅋ

**캔버스 (Canvas)**
- **의미**: HTML5에서 그래픽을 그리는 영역
- **2D**: `<canvas>` + 2D Context
- **3D**: `<canvas>` + WebGL (ThreeJS가 사용)

**커밋 (Commit)**
- **의미**: Git에서 변경사항을 저장하는 것
- **명령어**: `git commit -m "메시지"`
- **원칙**: 의미 있는 단위로, 자주
- **연관**: [[#Git 워크플로우]]

**컴포넌트 (Component)**
- **의미**: 재사용 가능한 UI 또는 기능 단위
- **React**: `function MyComponent() { ... }`
- **게임**: Player, Enemy, Weapon 등

**클라이언트 예측 (Client-side Prediction)**
- **의미**: 서버 응답 전에 클라이언트가 미리 결과 예측
- **목적**: 즉각적인 피드백, 부드러운 경험
- **주의**: 서버 결과와 다를 수 있음 → 보정 필요

### ㅌ

**태그 (Tag)**
- **Git**: 특정 커밋에 이름 붙이기 (v1.0, v2.0)
- **Obsidian**: 노트 분류용 레이블
- **HTML**: 마크업 요소 (`<div>`, `<p>` 등)

**테스팅 (Testing)**
- **종류**:
  - 단위 테스트 (Unit): 함수 단위
  - 통합 테스트 (Integration): 여러 모듈 조합
  - E2E 테스트: 전체 사용자 흐름
- **원칙**: 자동화, 반복 가능

**텍스처 (Texture)**
- **의미**: 3D 모델 표면에 입히는 이미지
- **종류**: Diffuse, Normal, Roughness, Metalness
- **포맷**: PNG, JPEG, WebP

**토큰 (Token)**
- **AI에서**: 텍스트의 작은 조각 단위
- **제한**: Claude/GPT는 대화당 토큰 제한 있음
- **절약**: /compact, 새 대화 시작

### ㅍ

**파티클 시스템 (Particle System)**
- **의미**: 많은 작은 입자로 효과 표현
- **예시**: 폭발, 연기, 불, 비
- **ThreeJS**: `THREE.Points` + `PointsMaterial`

**퍼포먼스 (Performance)**
- **측정**: FPS (초당 프레임 수)
- **목표**: 60fps (16.67ms/프레임)
- **도구**: Chrome DevTools Performance 탭

**폴리곤 (Polygon)**
- **의미**: 3D 모델을 구성하는 다각형 (보통 삼각형)
- **최적화**: 폴리곤 수 줄이기 (LOD)
- **권장**: 게임 모델 < 10,000 폴리곤

**프레임워크 (Framework)**
- **의미**: 앱 구조를 제공하는 도구
- **예시**: React, Vue, Angular
- **vs 라이브러리**: 프레임워크가 코드를 호출

**프롬프트 (Prompt)**
- **의미**: AI에게 주는 지시 또는 질문
- **좋은 프롬프트**: 명확, 구체적, 맥락 포함
- **연관**: [[#효율적인 프롬프트 작성법]]

**플레이어 (Player)**
- **게임**: 사용자가 조종하는 캐릭터/오브젝트
- **네트워킹**: 고유 ID, 위치, 상태를 가진 엔티티

### ㅎ

**하드포인트 (Hardpoint)**
- **의미**: 무기를 장착하는 위치
- **게임**: 날개 끝, 동체 아래 등
- **구현**: 빈 오브젝트 (Empty Object)로 위치 표시

**헤더 (Header)**
- **HTTP**: 요청/응답의 메타데이터
- **파일**: 파일 상단의 설명 또는 import 구문

**호스팅 (Hosting)**
- **의미**: 웹사이트/앱을 인터넷에 배포
- **무료**:
  - Vercel, Netlify (정적 사이트)
  - Railway, Render (서버 포함)

**훅 (Hook)**
- **React**: 함수 컴포넌트에서 상태 관리 (`useState`, `useEffect`)
- **Git**: 특정 이벤트 발생 시 실행되는 스크립트
- **Claude Code**: 도구 호출 시 실행되는 사용자 정의 스크립트

### 영문

**API (Application Programming Interface)**
- **의미**: 프로그램 간 통신 규약
- **REST API**: HTTP 기반 웹 API
- **예시**: `GET /api/players` → 플레이어 목록 반환

**CORS (Cross-Origin Resource Sharing)**
- **의미**: 다른 도메인 간 리소스 공유 정책
- **문제**: 브라우저 보안으로 차단됨
- **해결**: 서버에서 CORS 헤더 설정

**FPS (Frames Per Second)**
- **의미**: 초당 프레임 수 (화면 갱신 횟수)
- **목표**: 60fps (부드러움)
- **최소**: 30fps (플레이 가능)

**LOD (Level of Detail)**
- **의미**: 거리에 따라 모델 디테일 조절
- **예시**:
  - 가까이: 10,000 폴리곤
  - 중간: 2,000 폴리곤
  - 멀리: 500 폴리곤

**MVP (Minimum Viable Product)**
- **의미**: 최소 기능 제품
- **목적**: 빠르게 검증
- **바이브 코딩**: MVP 제작에 최적!

**NPM (Node Package Manager)**
- **의미**: JavaScript 패키지 관리자
- **명령어**:
  - `npm install` - 패키지 설치
  - `npm run dev` - 개발 서버 실행

**PRD (Product Requirements Document)**
- **의미**: 제품 요구사항 문서
- **앱**: GDD 대신 PRD 사용
- **포함**: 기능, 사용자 스토리, 제약사항

**Tech Stack**
- **의미**: 프로젝트에 사용하는 기술 모음
- **예시**:
  - Frontend: React + ThreeJS
  - Backend: Node.js + Express
  - DB: MongoDB
- **연관**: [[#2단계 - Tech Stack 선정하기]]

**ThreeJS**
- **의미**: 웹 3D 라이브러리
- **기능**: 3D 렌더링, 카메라, 조명, 재질
- **WebGL**: GPU 가속 그래픽 API 위에 구축

**UI/UX**
- **UI (User Interface)**: 사용자가 보는 화면
- **UX (User Experience)**: 사용자 경험 전체
- **목표**: 직관적, 효율적, 즐거움

**WebGL**
- **의미**: 브라우저에서 3D 그래픽을 렌더링하는 API
- **GPU 가속**: 그래픽 카드 사용
- **라이브러리**: ThreeJS, Babylon.js가 추상화

---

## 12. 마치며

### 🎉 축하합니다!

이 긴 가이드를 완독하셨다면, 여러분은 이제:

```
✅ 바이브 코딩의 핵심 원리 이해
✅ 게임/앱 개발의 전체 프로세스 파악
✅ AI 도구를 효과적으로 활용하는 방법 습득
✅ 버그 해결과 디버깅 전략 습득
✅ 실전 워크플로우 완벽 숙지
```

### 🚀 이제 무엇을 할까요?

**첫 번째 프로젝트 시작:**
```
1. 간단한 아이디어 선택
   - 예: 간단한 2D 게임
   - 예: To-do 앱
   - 예: 포트폴리오 웹사이트

2. 이 가이드 다시 읽으며 단계별 실행
   - GDD/PRD 작성
   - Tech Stack 선정
   - Implementation Plan 작성
   - Memory Bank 구성
   - 구현 시작!

3. 작은 성공 경험 쌓기
   - 완벽하지 않아도 OK
   - 학습이 목표
```

### 💪 계속 성장하기

**커뮤니티 참여:**
```
- Discord 서버 가입
- Reddit 커뮤니티 참여
- 트위터에서 #vibecoding 팔로우
- 자신의 프로젝트 공유
```

**학습 자료:**
```
- ThreeJS 공식 문서
- Socket.io 가이드
- Claude Code 문서
- 다른 개발자의 프로젝트 분석
```

**실력 향상:**
```
레벨 1: 간단한 프로젝트 완성
→ To-do 앱, 간단한 2D 게임

레벨 2: 복잡한 기능 추가
→ 멀티플레이, 결제 시스템

레벨 3: 상용화 준비
→ 보안, 최적화, 테스팅

레벨 4: 자신만의 방법론
→ 이 가이드를 넘어서기
```

### 🙏 감사의 말

이 가이드는 다음을 기반으로 작성되었습니다:
- **Nicolas Zullo**의 원본 "Ultimate Guide to Vibe Coding V1.2"
- 수많은 개발자들의 실전 경험
- AI 도구의 발전

### 📢 마지막 조언

```
완벽주의를 버리세요.
→ "동작하는" 것이 "완벽한" 것보다 낫습니다.

자주 커밋하세요.
→ 실수해도 되돌릴 수 있습니다.

AI를 두려워하지 마세요.
→ AI는 도구입니다. 당신이 주인입니다.

에러를 즐기세요.
→ 에러 = 배움의 기회

포기하지 마세요.
→ 모든 프로 개발자도 당신과 같은 길을 걸었습니다.
```

### 🌟 당신의 여정은 이제 시작입니다!

**지훈이는 어떻게 되었을까요?**

8주 후, 지훈이는 첫 번째 프로토타입을 완성했습니다.
완벽하진 않았지만, **날아다니는 비행기, 미사일 발사, 멀티플레이**가 모두 작동했습니다.

친구들에게 보여줬을 때의 반응:
> "야, 진짜 네가 만든 거야?!"

그 순간, 지훈이는 깨달았습니다.
프로그래밍 천재가 아니어도,
AI와 함께라면 **누구나 만들고 싶은 걸 만들 수 있다는 것을.**

**이제 당신의 차례입니다. 🚀**

---

## 연결된 노트

- [[Claude Code 시작 가이드]] - Claude Code 초기 설정
- [[Git 기초 사용법]] - Git 명령어 완벽 정리
- [[ThreeJS 입문 가이드]] - 3D 그래픽 기초
- [[Socket.io 멀티플레이 구현]] - 실시간 멀티플레이
- [[프롬프트 엔지니어링 기법]] - AI에게 효과적으로 질문하기
- [[게임 디자인 문서 작성법]] - GDD 템플릿과 예시
- [[웹 게임 배포 가이드]] - Vercel, Netlify 배포

---

## 변경 이력

- **2025-10-12**: Part 2 완성 (섹션 6-12)
  - 세부 기능 추가하기
  - 버그 해결과 막힘 돌파하기
  - 프로 팁과 도구 활용
  - 실전 워크플로우 완벽 정리
  - FAQ (자주 묻는 질문)
  - 용어 설명 (가나다순)
  - 마치며

- **2025-10-12**: 초안 작성 완료 (섹션 1-5)
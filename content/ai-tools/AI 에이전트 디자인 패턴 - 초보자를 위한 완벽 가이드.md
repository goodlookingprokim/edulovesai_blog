---
title: "AI ì—ì´ì „íŠ¸ ë””ìì¸ íŒ¨í„´ - ì´ˆë³´ìë¥¼ ìœ„í•œ ì™„ë²½ ê°€ì´ë“œ"
created: '2025-10-11'
last_modified: '2025-10-11'
tags:
  - AI/ì—ì´ì „íŠ¸
  - AI/ë””ìì¸íŒ¨í„´
  - í”„ë¡œê·¸ë˜ë°/ì´ˆë³´ì
  - êµìœ¡/íŠœí† ë¦¬ì–¼
  - ê°œë°œ/AI
  - íŒŒì¸ë§Œê¸°ë²•
  - ìŠ¤í† ë¦¬í…”ë§
status: "ì™„ë£Œ"
type: "êµìœ¡ìë£Œ"
priority: "high"
share_link: ""
---

# ğŸ¤– AI ì—ì´ì „íŠ¸ ë””ìì¸ íŒ¨í„´: ì´ˆë³´ ê°œë°œìë¥¼ ìœ„í•œ ì™„ë²½ ê°€ì´ë“œ

> ğŸ’¡ **ì´ ë…¸íŠ¸ì˜ ëª©ì **: ë³µì¡í•œ AI ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œì„ **5ì‚´ ì•„ì´ë„ ì´í•´í•  ìˆ˜ ìˆê²Œ** ì„¤ëª…í•˜ê³ , ì‹¤ì œë¡œ **ë‹¹ì‹ ì´ ì§ì ‘ ë§Œë“¤ ìˆ˜ ìˆë„ë¡** ë•ëŠ” ê²ƒì…ë‹ˆë‹¤.

## ğŸ“‹ ëª©ì°¨
1. [[#í”„ë¡¤ë¡œê·¸ - AI ì—ì´ì „íŠ¸ì™€ì˜ ì²« ë§Œë‚¨]]
2. [[#AI ì—ì´ì „íŠ¸ë€ ë¬´ì—‡ì¸ê°€ - ë¡œë´‡ ë¹„ì„œ ì´ì•¼ê¸°]]
3. [[#7ê°€ì§€ í•µì‹¬ ë””ìì¸ íŒ¨í„´ - ë ˆê³  ë¸”ë¡ì²˜ëŸ¼ ì¡°ë¦½í•˜ê¸°]]
4. [[#ì´ˆë³´ìë¥¼ ìœ„í•œ ë‹¨ê³„ë³„ ì‹¤ìŠµ]]
5. [[#ì‹¤ì „ í”„ë¡œì íŠ¸ - ë‚˜ë§Œì˜ AI ë¹„ì„œ ë§Œë“¤ê¸°]]
6. [[#ìš©ì–´ ì‚¬ì „ - ì–´ë ¤ìš´ ë§ ì‰½ê²Œ ì´í•´í•˜ê¸°]]
7. [[#ë” ë‚˜ì•„ê°€ê¸° - ì„±ì¥ ë¡œë“œë§µ]]

---

## í”„ë¡¤ë¡œê·¸ - AI ì—ì´ì „íŠ¸ì™€ì˜ ì²« ë§Œë‚¨

### ğŸ­ ì´ì•¼ê¸°ë¡œ ì‹œì‘í•˜ëŠ” AI ì—ì´ì „íŠ¸

ìƒìƒí•´ë³´ì„¸ìš”. ë‹¹ì‹ ì€ ì‘ì€ ì¹´í˜ë¥¼ ìš´ì˜í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë§¤ì¼ ì•„ì¹¨:
- â˜• ì»¤í”¼ ì›ë‘ ì¬ê³ ë¥¼ í™•ì¸í•´ì•¼ í•˜ê³ 
- ğŸ“¦ í•„ìš”í•˜ë©´ ìë™ìœ¼ë¡œ ì£¼ë¬¸í•´ì•¼ í•˜ê³ 
- ğŸ’¬ ê³ ê°ì˜ ë¬¸ì˜ì— ë‹µë³€í•´ì•¼ í•˜ê³ 
- ğŸ“Š ë§¤ì¶œì„ ì •ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤

**"ì´ ëª¨ë“  ê±¸ ì•Œì•„ì„œ í•´ì£¼ëŠ” ì§ì›ì´ ìˆë‹¤ë©´ ì–¼ë§ˆë‚˜ ì¢‹ì„ê¹Œ?"**

ë°”ë¡œ ì´ê²ƒì´ **AI ì—ì´ì „íŠ¸**ì…ë‹ˆë‹¤!

### ğŸ¯ íŒŒì¸ë§Œ ê¸°ë²•ìœ¼ë¡œ ì´í•´í•˜ê¸°

> "ë³µì¡í•œ ê²ƒì„ ë‹¨ìˆœí•˜ê²Œ ì„¤ëª…í•  ìˆ˜ ì—†ë‹¤ë©´, ê·¸ê²ƒì„ ì œëŒ€ë¡œ ì´í•´í•œ ê²ƒì´ ì•„ë‹ˆë‹¤" - ë¦¬ì²˜ë“œ íŒŒì¸ë§Œ

**AI ì—ì´ì „íŠ¸ë¥¼ 5ì‚´ ì•„ì´ì—ê²Œ ì„¤ëª…í•œë‹¤ë©´?**
```
AI ì—ì´ì „íŠ¸ = ë˜‘ë˜‘í•œ ë¡œë´‡ ì¹œêµ¬
- í˜¼ìì„œ ì¼ì„ í•  ìˆ˜ ìˆì–´ìš”
- í•„ìš”í•œ ë„êµ¬ë¥¼ ì°¾ì•„ ì“¸ ìˆ˜ ìˆì–´ìš”
- ì‹¤ìˆ˜í•˜ë©´ ë‹¤ì‹œ ê³ ì¹  ìˆ˜ ìˆì–´ìš”
- ì¹œêµ¬ë“¤ê³¼ í˜‘ë ¥í•  ìˆ˜ ìˆì–´ìš”
```

---

## AI ì—ì´ì „íŠ¸ë€ ë¬´ì—‡ì¸ê°€ - ë¡œë´‡ ë¹„ì„œ ì´ì•¼ê¸°

### ğŸ¤” ì¼ë°˜ í”„ë¡œê·¸ë¨ vs AI ì—ì´ì „íŠ¸

#### ğŸ“± ì¼ë°˜ í”„ë¡œê·¸ë¨ (ì „í†µì ì¸ ì•±)
```python
# ì „í†µì ì¸ í”„ë¡œê·¸ë¨: ì •í•´ì§„ ëŒ€ë¡œë§Œ ë™ì‘
def traditional_coffee_order():
    if inventory < 10:
        order_coffee()  # ë¬´ì¡°ê±´ 10ê°œ ì´í•˜ë©´ ì£¼ë¬¸
    else:
        pass  # ì•„ë‹ˆë©´ ì•„ë¬´ê²ƒë„ ì•ˆ í•¨
```

**íŠ¹ì§•**:
- ğŸ”´ ì •í•´ì§„ ê·œì¹™ëŒ€ë¡œë§Œ ë™ì‘
- ğŸ”´ ì˜ˆì™¸ ìƒí™©ì— ëŒ€ì²˜ ëª» í•¨
- ğŸ”´ í•™ìŠµí•˜ì§€ ì•ŠìŒ

#### ğŸ§  AI ì—ì´ì „íŠ¸
```python
# AI ì—ì´ì „íŠ¸: ìƒí™©ì„ íŒë‹¨í•˜ê³  ê²°ì •
class CoffeeAgent:
    def think_and_act(self):
        # 1. ìƒí™© íŒŒì•…
        context = analyze_situation()  # "ìš”ì¦˜ íŒë§¤ ì¶”ì„¸ëŠ”? ë‚ ì”¨ëŠ”?"

        # 2. ê³„íš ìˆ˜ë¦½
        plan = create_plan(context)  # "ë¹„ ì˜¤ëŠ” ë‚ ì´ë‹ˆ ë”°ëœ»í•œ ì»¤í”¼ ë” ì¤€ë¹„"

        # 3. ì‹¤í–‰ê³¼ í•™ìŠµ
        result = execute(plan)
        learn_from_result(result)  # "ì˜¤ëŠ˜ ì „ëµì´ íš¨ê³¼ì ì´ì—ˆë‚˜?"
```

**íŠ¹ì§•**:
- âœ… ìŠ¤ìŠ¤ë¡œ íŒë‹¨í•˜ê³  ê²°ì •
- âœ… ì‹¤ìˆ˜ì—ì„œ ë°°ì›€
- âœ… ìƒí™©ì— ë§ê²Œ ì ì‘

### ğŸ¨ ì‹¤ìƒí™œ ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°

| êµ¬ë¶„ | ì¼ë°˜ í”„ë¡œê·¸ë¨ | AI ì—ì´ì „íŠ¸ |
|------|--------------|-------------|
| ë¹„ìœ  | ğŸ“– **ìš”ë¦¬ì±… ë ˆì‹œí”¼** | ğŸ‘¨â€ğŸ³ **ì „ë¬¸ ìš”ë¦¬ì‚¬** |
| ì„¤ëª… | ì •í™•í•œ ìˆœì„œëŒ€ë¡œë§Œ ë”°ë¼í•¨ | ì¬ë£Œì™€ ìƒí™© ë³´ê³  ì¡°ì ˆ |
| ì˜ˆì‹œ | "ì†Œê¸ˆ 1ìŠ¤í‘¼ ë„£ê¸°" | "ë§› ë³´ê³  ê°„ ì¡°ì ˆí•˜ê¸°" |
| ìœ ì—°ì„± | ì¬ë£Œ ì—†ìœ¼ë©´ ë©ˆì¶¤ | ëŒ€ì²´ ì¬ë£Œ ì°¾ì•„ ì‚¬ìš© |

---

## 7ê°€ì§€ í•µì‹¬ ë””ìì¸ íŒ¨í„´ - ë ˆê³  ë¸”ë¡ì²˜ëŸ¼ ì¡°ë¦½í•˜ê¸°

### ğŸ§© íŒ¨í„´ 1: Prompt Chaining (í”„ë¡¬í”„íŠ¸ ì²´ì´ë‹)
**"ë¦´ë ˆì´ ê²½ì£¼ì²˜ëŸ¼ ì‘ì—… ì´ì–´ê°€ê¸°"**

#### ğŸ“š ì´ˆë³´ì ì„¤ëª…
í† ìŠ¤íŠ¸ë¥¼ ë§Œë“œëŠ” ê³¼ì •ì„ ìƒìƒí•´ë³´ì„¸ìš”:
1. ğŸ ë¹µ êº¼ë‚´ê¸° â†’
2. ğŸ”¥ í† ìŠ¤í„°ì— ë„£ê¸° â†’
3. â° ê¸°ë‹¤ë¦¬ê¸° â†’
4. ğŸ§ˆ ë²„í„° ë°”ë¥´ê¸°

ê° ë‹¨ê³„ì˜ **ê²°ê³¼**ê°€ ë‹¤ìŒ ë‹¨ê³„ì˜ **ì‹œì‘**ì´ ë©ë‹ˆë‹¤!

#### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (ìˆ˜ì¤€ë³„)

**ğŸŒ± ì…ë¬¸ììš© - ê°„ë‹¨í•œ ì²´ì¸**
```python
# ë ˆë²¨ 1: ì•„ì£¼ ê°„ë‹¨í•œ ì²´ì¸
def make_story():
    # ë‹¨ê³„ 1: ì£¼ì¸ê³µ ë§Œë“¤ê¸°
    character = create_character("ìš©ê°í•œ ê°œë°œì")

    # ë‹¨ê³„ 2: ë°°ê²½ ë§Œë“¤ê¸° (ì£¼ì¸ê³µ ì •ë³´ í™œìš©)
    setting = create_setting(character)

    # ë‹¨ê³„ 3: ì´ì•¼ê¸° ì™„ì„± (ì´ì „ ì •ë³´ë“¤ ëª¨ë‘ í™œìš©)
    story = write_story(character, setting)

    return story

# ì‹¤í–‰ ì˜ˆì‹œ
print(make_story())
# ì¶œë ¥: "ìš©ê°í•œ ê°œë°œìê°€ ì‹¤ë¦¬ì½˜ë°¸ë¦¬ì—ì„œ AI ì—ì´ì „íŠ¸ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤..."
```

**ğŸŒ¿ ì´ˆê¸‰ììš© - ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€**
```python
# ë ˆë²¨ 2: ì—ëŸ¬ ì²˜ë¦¬ê°€ ìˆëŠ” ì²´ì¸
class StoryChain:
    def __init__(self):
        self.steps = []

    def add_step(self, step_name, function):
        """ì²´ì¸ì— ë‹¨ê³„ ì¶”ê°€"""
        self.steps.append((step_name, function))

    def run(self, initial_input):
        """ì²´ì¸ ì‹¤í–‰ - ì—ëŸ¬ ë°œìƒì‹œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬"""
        result = initial_input

        for step_name, function in self.steps:
            try:
                print(f"ğŸ”„ {step_name} ì‹¤í–‰ ì¤‘...")
                result = function(result)
            except Exception as e:
                print(f"âŒ {step_name} ì‹¤íŒ¨: {e}")
                return None

        return result

# ì‚¬ìš© ì˜ˆì‹œ
chain = StoryChain()
chain.add_step("ìºë¦­í„° ìƒì„±", create_character)
chain.add_step("ë°°ê²½ ì„¤ì •", create_setting)
chain.add_step("í”Œë¡¯ êµ¬ì„±", create_plot)
story = chain.run("ëª¨í—˜ ì´ì•¼ê¸°")
```

**ğŸŒ³ ì¤‘ê¸‰ììš© - ë¹„ë™ê¸° ì²˜ë¦¬ì™€ ë¡œê¹…**
```python
# ë ˆë²¨ 3: ì‹¤ë¬´ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì²´ì¸
import asyncio
import logging
from typing import Any, Callable, List

class AdvancedChain:
    def __init__(self, name: str):
        self.name = name
        self.steps: List[Callable] = []
        self.logger = logging.getLogger(name)

    async def add_step(self, step_func: Callable,
                       timeout: int = 30):
        """ë¹„ë™ê¸° ë‹¨ê³„ ì¶”ê°€"""
        self.steps.append({
            'func': step_func,
            'timeout': timeout
        })

    async def execute(self, initial_data: Any) -> Any:
        """ì²´ì¸ ì‹¤í–‰ - íƒ€ì„ì•„ì›ƒê³¼ ì¬ì‹œë„ í¬í•¨"""
        current_data = initial_data

        for i, step in enumerate(self.steps):
            self.logger.info(f"Step {i+1}/{len(self.steps)} ì‹œì‘")

            try:
                # íƒ€ì„ì•„ì›ƒ ì„¤ì •
                current_data = await asyncio.wait_for(
                    step['func'](current_data),
                    timeout=step['timeout']
                )
            except asyncio.TimeoutError:
                self.logger.error(f"Step {i+1} íƒ€ì„ì•„ì›ƒ")
                # ì¬ì‹œë„ ë¡œì§ ë˜ëŠ” ëŒ€ì²´ ì²˜ë¦¬
                current_data = await self.fallback_handler(current_data)

        return current_data

# ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ
async def main():
    chain = AdvancedChain("customer_service")

    # ê³ ê° ì„œë¹„ìŠ¤ ì²´ì¸ êµ¬ì„±
    chain.add_step(analyze_customer_query, timeout=10)
    chain.add_step(search_knowledge_base, timeout=20)
    chain.add_step(generate_response, timeout=15)
    chain.add_step(personalize_tone, timeout=5)

    response = await chain.execute("ì œí’ˆ í™˜ë¶ˆ ë¬¸ì˜")
    print(response)
```

### ğŸ§© íŒ¨í„´ 2: Routing (ë¼ìš°íŒ…)
**"êµí†µ ì‹ í˜¸ë“±ì²˜ëŸ¼ ê¸¸ ì•ˆë‚´í•˜ê¸°"**

#### ğŸ“š ì´ˆë³´ì ì„¤ëª…
ê³ ê° ì„¼í„°ì— ì „í™”í–ˆì„ ë•Œë¥¼ ìƒê°í•´ë³´ì„¸ìš”:
- "ì£¼ë¬¸ ë¬¸ì˜ëŠ” 1ë²ˆ" â†’ ì£¼ë¬¸íŒ€
- "ë°°ì†¡ ë¬¸ì˜ëŠ” 2ë²ˆ" â†’ ë°°ì†¡íŒ€
- "í™˜ë¶ˆ ë¬¸ì˜ëŠ” 3ë²ˆ" â†’ í™˜ë¶ˆíŒ€

AIë„ ì´ë ‡ê²Œ **ì§ˆë¬¸ ìœ í˜•ì— ë”°ë¼** ë‹¤ë¥¸ ì²˜ë¦¬ë¥¼ í•©ë‹ˆë‹¤!

#### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (ìˆ˜ì¤€ë³„)

**ğŸŒ± ì…ë¬¸ììš© - ë‹¨ìˆœ ë¶„ê¸°**
```python
# ë ˆë²¨ 1: if-elseë¡œ ê°„ë‹¨í•œ ë¼ìš°íŒ…
def customer_service_bot(message):
    # ë©”ì‹œì§€ ë‚´ìš©ìœ¼ë¡œ ì–´ë””ë¡œ ë³´ë‚¼ì§€ ê²°ì •
    if "ì£¼ë¬¸" in message:
        return handle_order(message)
    elif "ë°°ì†¡" in message:
        return handle_shipping(message)
    elif "í™˜ë¶ˆ" in message:
        return handle_refund(message)
    else:
        return "ì£„ì†¡í•©ë‹ˆë‹¤. ì´í•´í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."

# í…ŒìŠ¤íŠ¸
print(customer_service_bot("ì£¼ë¬¸í•œ ì œí’ˆì´ ì–¸ì œ ì˜¤ë‚˜ìš”?"))
# ì¶œë ¥: "ì£¼ë¬¸ ë²ˆí˜¸ë¥¼ ì•Œë ¤ì£¼ì‹œë©´ ë°°ì†¡ ìƒíƒœë¥¼ í™•ì¸í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤."
```

**ğŸŒ¿ ì´ˆê¸‰ììš© - ë”•ì…”ë„ˆë¦¬ í™œìš©**
```python
# ë ˆë²¨ 2: ë” ê¹”ë”í•œ ë¼ìš°í„°
class SmartRouter:
    def __init__(self):
        # í‚¤ì›Œë“œì™€ ì²˜ë¦¬ í•¨ìˆ˜ ë§¤í•‘
        self.routes = {
            "ì£¼ë¬¸": self.handle_order,
            "ë°°ì†¡": self.handle_shipping,
            "í™˜ë¶ˆ": self.handle_refund,
            "êµí™˜": self.handle_exchange
        }

    def route(self, message):
        """ë©”ì‹œì§€ ë¶„ì„ í›„ ì ì ˆí•œ í•¸ë“¤ëŸ¬ë¡œ ë¼ìš°íŒ…"""
        # í‚¤ì›Œë“œ ì°¾ê¸°
        for keyword, handler in self.routes.items():
            if keyword in message:
                return handler(message)

        # ê¸°ë³¸ ì²˜ë¦¬
        return self.handle_default(message)

    def handle_order(self, msg):
        return f"ğŸ“¦ ì£¼ë¬¸ ê´€ë ¨: {msg}"

    def handle_shipping(self, msg):
        return f"ğŸšš ë°°ì†¡ ê´€ë ¨: {msg}"

    # ... ë‹¤ë¥¸ í•¸ë“¤ëŸ¬ë“¤

router = SmartRouter()
print(router.route("ë°°ì†¡ì´ ë„ˆë¬´ ëŠ¦ì–´ìš”"))
```

**ğŸŒ³ ì¤‘ê¸‰ììš© - AI ê¸°ë°˜ ë¼ìš°íŒ…**
```python
# ë ˆë²¨ 3: AIë¡œ ì˜ë„ íŒŒì•…í•˜ì—¬ ë¼ìš°íŒ…
import openai
from enum import Enum
from typing import Dict, Optional

class Intent(Enum):
    ORDER = "order"
    SHIPPING = "shipping"
    REFUND = "refund"
    TECHNICAL = "technical"
    GENERAL = "general"

class AIRouter:
    def __init__(self, api_key: str):
        self.client = openai.Client(api_key=api_key)
        self.handlers = {
            Intent.ORDER: OrderHandler(),
            Intent.SHIPPING: ShippingHandler(),
            Intent.REFUND: RefundHandler(),
            Intent.TECHNICAL: TechSupportHandler(),
            Intent.GENERAL: GeneralHandler()
        }

    async def classify_intent(self, message: str) -> Intent:
        """AIë¡œ ì‚¬ìš©ì ì˜ë„ ë¶„ë¥˜"""
        prompt = f"""
        ì‚¬ìš©ì ë©”ì‹œì§€: {message}

        ìœ„ ë©”ì‹œì§€ì˜ ì˜ë„ë¥¼ ë¶„ë¥˜í•˜ì„¸ìš”:
        - order: ì£¼ë¬¸ ê´€ë ¨
        - shipping: ë°°ì†¡ ê´€ë ¨
        - refund: í™˜ë¶ˆ/êµí™˜ ê´€ë ¨
        - technical: ê¸°ìˆ  ì§€ì›
        - general: ì¼ë°˜ ë¬¸ì˜

        ì˜ë„:
        """

        response = await self.client.completions.create(
            model="gpt-4",
            prompt=prompt,
            max_tokens=10
        )

        intent_str = response.choices[0].text.strip()
        return Intent[intent_str.upper()]

    async def process(self, message: str) -> str:
        """ë©”ì‹œì§€ ì²˜ë¦¬ - ì˜ë„ íŒŒì•… í›„ ì ì ˆí•œ í•¸ë“¤ëŸ¬ ì‹¤í–‰"""
        # 1. AIë¡œ ì˜ë„ íŒŒì•…
        intent = await self.classify_intent(message)

        # 2. ì‹ ë¢°ë„ ì²´í¬ (ì„ íƒì )
        confidence = await self.get_confidence(message, intent)

        if confidence < 0.7:
            # ì‹ ë¢°ë„ ë‚®ìœ¼ë©´ ì‚¬ëŒì—ê²Œ ì „ë‹¬
            return await self.escalate_to_human(message)

        # 3. ì ì ˆí•œ í•¸ë“¤ëŸ¬ë¡œ ì²˜ë¦¬
        handler = self.handlers[intent]
        return await handler.process(message)

# ì‹¤ì œ ì‚¬ìš©
router = AIRouter(api_key="your-key")
response = await router.process("ì œí’ˆì´ ê³ ì¥ë‚¬ëŠ”ë° AS ë°›ê³  ì‹¶ì–´ìš”")
# AIê°€ 'technical'ë¡œ ë¶„ë¥˜ â†’ TechSupportHandlerê°€ ì²˜ë¦¬
```

### ğŸ§© íŒ¨í„´ 3: Parallelization (ë³‘ë ¬ ì²˜ë¦¬)
**"ì—¬ëŸ¬ ì¼ì„ ë™ì‹œì— ì²˜ë¦¬í•˜ê¸°"**

#### ğŸ“š ì´ˆë³´ì ì„¤ëª…
ìš”ë¦¬í•  ë•Œë¥¼ ìƒê°í•´ë³´ì„¸ìš”:
- ğŸš ë°¥ì†¥ì— ë°¥ í•˜ë©´ì„œ
- ğŸ¥˜ ì°Œê°œë„ ë“ì´ê³ 
- ğŸ¥— ìƒëŸ¬ë“œë„ ë§Œë“¤ê¸°

í•˜ë‚˜ì”© í•˜ë©´ 3ì‹œê°„, **ë™ì‹œì— í•˜ë©´ 1ì‹œê°„**!

#### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (ìˆ˜ì¤€ë³„)

**ğŸŒ± ì…ë¬¸ììš© - ë™ì‹œ ì‹¤í–‰ ì²´í—˜**
```python
# ë ˆë²¨ 1: ìˆœì°¨ ì²˜ë¦¬ vs ë³‘ë ¬ ì²˜ë¦¬ ë¹„êµ
import time
import concurrent.futures

# ëŠë¦° ë°©ë²•: í•˜ë‚˜ì”© ì²˜ë¦¬
def sequential_processing():
    start = time.time()

    weather = get_weather()      # 2ì´ˆ
    news = get_news()            # 2ì´ˆ
    stock = get_stock_price()    # 2ì´ˆ

    print(f"ìˆœì°¨ ì²˜ë¦¬ ì‹œê°„: {time.time() - start}ì´ˆ")  # ì•½ 6ì´ˆ
    return weather, news, stock

# ë¹ ë¥¸ ë°©ë²•: ë™ì‹œì— ì²˜ë¦¬
def parallel_processing():
    start = time.time()

    with concurrent.futures.ThreadPoolExecutor() as executor:
        # ëª¨ë“  ì‘ì—…ì„ ë™ì‹œì— ì‹œì‘
        future_weather = executor.submit(get_weather)
        future_news = executor.submit(get_news)
        future_stock = executor.submit(get_stock_price)

        # ê²°ê³¼ ìˆ˜ì§‘
        weather = future_weather.result()
        news = future_news.result()
        stock = future_stock.result()

    print(f"ë³‘ë ¬ ì²˜ë¦¬ ì‹œê°„: {time.time() - start}ì´ˆ")  # ì•½ 2ì´ˆ
    return weather, news, stock
```

**ğŸŒ¿ ì´ˆê¸‰ììš© - ì‹¤ìš©ì ì¸ ë³‘ë ¬ ì²˜ë¦¬**
```python
# ë ˆë²¨ 2: ì—¬ëŸ¬ API ë™ì‹œ í˜¸ì¶œ
import asyncio
import aiohttp

class ParallelDataFetcher:
    def __init__(self):
        self.apis = {
            "weather": "https://api.weather.com/data",
            "news": "https://api.news.com/latest",
            "traffic": "https://api.traffic.com/current"
        }

    async def fetch_one(self, session, name, url):
        """í•˜ë‚˜ì˜ API í˜¸ì¶œ"""
        try:
            async with session.get(url) as response:
                data = await response.json()
                return {name: data}
        except Exception as e:
            return {name: f"Error: {e}"}

    async def fetch_all(self):
        """ëª¨ë“  API ë™ì‹œ í˜¸ì¶œ"""
        async with aiohttp.ClientSession() as session:
            # ëª¨ë“  ì‘ì—…ì„ ë™ì‹œì— ì‹¤í–‰
            tasks = [
                self.fetch_one(session, name, url)
                for name, url in self.apis.items()
            ]

            # ëª¨ë“  ê²°ê³¼ ëŒ€ê¸°
            results = await asyncio.gather(*tasks)

            # ê²°ê³¼ í•©ì¹˜ê¸°
            combined = {}
            for result in results:
                combined.update(result)

            return combined

# ì‚¬ìš© ì˜ˆì‹œ
fetcher = ParallelDataFetcher()
data = asyncio.run(fetcher.fetch_all())
print(f"ë°›ì€ ë°ì´í„°: {data}")
```

**ğŸŒ³ ì¤‘ê¸‰ììš© - ì§€ëŠ¥ì ì¸ ë³‘ë ¬ ì²˜ë¦¬**
```python
# ë ˆë²¨ 3: ì‘ì—… ì˜ì¡´ì„± ê´€ë¦¬ì™€ ë™ì  ë³‘ë ¬í™”
from dataclasses import dataclass
from typing import List, Set, Dict, Any
import asyncio

@dataclass
class Task:
    id: str
    func: callable
    dependencies: Set[str] = None

    def __post_init__(self):
        if self.dependencies is None:
            self.dependencies = set()

class SmartParallelExecutor:
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
        self.results: Dict[str, Any] = {}

    def add_task(self, task: Task):
        """ì‘ì—… ì¶”ê°€"""
        self.tasks[task.id] = task

    async def execute_task(self, task_id: str):
        """ë‹¨ì¼ ì‘ì—… ì‹¤í–‰"""
        task = self.tasks[task_id]

        # ì˜ì¡´ì„± ìˆëŠ” ì‘ì—…ë“¤ì˜ ê²°ê³¼ ìˆ˜ì§‘
        deps_results = {
            dep_id: self.results[dep_id]
            for dep_id in task.dependencies
        }

        # ì‘ì—… ì‹¤í–‰
        result = await task.func(deps_results)
        self.results[task_id] = result
        return result

    async def execute_all(self):
        """ëª¨ë“  ì‘ì—…ì„ ì˜ì¡´ì„± ê³ ë ¤í•˜ì—¬ ì‹¤í–‰"""
        # ì‘ì—…ì„ ë ˆë²¨ë³„ë¡œ ê·¸ë£¹í™”
        levels = self.topological_sort()

        for level in levels:
            # ê°™ì€ ë ˆë²¨ì˜ ì‘ì—…ë“¤ì€ ë³‘ë ¬ ì‹¤í–‰
            tasks = [
                self.execute_task(task_id)
                for task_id in level
            ]
            await asyncio.gather(*tasks)

            print(f"ë ˆë²¨ {levels.index(level)} ì™„ë£Œ: {level}")

        return self.results

    def topological_sort(self) -> List[List[str]]:
        """ì˜ì¡´ì„± ê¸°ë°˜ ì‘ì—… ë ˆë²¨ ë¶„ë¥˜"""
        levels = []
        processed = set()

        while len(processed) < len(self.tasks):
            current_level = []

            for task_id, task in self.tasks.items():
                if task_id not in processed:
                    # ì˜ì¡´ì„±ì´ ëª¨ë‘ ì²˜ë¦¬ë˜ì—ˆëŠ”ì§€ í™•ì¸
                    if task.dependencies.issubset(processed):
                        current_level.append(task_id)

            levels.append(current_level)
            processed.update(current_level)

        return levels

# ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ
executor = SmartParallelExecutor()

# ì‘ì—… ì •ì˜ (ì¼ë¶€ëŠ” ì„œë¡œ ì˜ì¡´)
executor.add_task(Task("user_data", fetch_user_data))
executor.add_task(Task("preferences", fetch_preferences, {"user_data"}))
executor.add_task(Task("history", fetch_history, {"user_data"}))
executor.add_task(Task("recommendations", generate_recommendations,
                      {"preferences", "history"}))

# ì‹¤í–‰ - ìë™ìœ¼ë¡œ ìµœì  ë³‘ë ¬í™”
results = await executor.execute_all()
# user_data ë¨¼ì € â†’ preferencesì™€ history ë™ì‹œ â†’ recommendations
```

### ğŸ§© íŒ¨í„´ 4: Reflection (ë°˜ì„±/ê°œì„ )
**"ì‹¤ìˆ˜ì—ì„œ ë°°ìš°ëŠ” AI"**

#### ğŸ“š ì´ˆë³´ì ì„¤ëª…
ìˆ˜í•™ ë¬¸ì œë¥¼ í’€ ë•Œ:
1. ğŸ“ ë¬¸ì œ í’€ê¸°
2. ğŸ” ë‹µ í™•ì¸í•˜ê¸°
3. âŒ í‹€ë ¸ë‹¤ë©´ ì™œ í‹€ë ¸ëŠ”ì§€ ë¶„ì„
4. âœï¸ ë‹¤ì‹œ í’€ê¸°

AIë„ ì´ë ‡ê²Œ **ìê¸° ë‹µì„ ê²€í† í•˜ê³  ê°œì„ **í•©ë‹ˆë‹¤!

#### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (ìˆ˜ì¤€ë³„)

**ğŸŒ± ì…ë¬¸ììš© - ê°„ë‹¨í•œ ìê¸° ê²€ì¦**
```python
# ë ˆë²¨ 1: ê¸°ë³¸ì ì¸ ë°˜ì„± íŒ¨í„´
class SimpleReflectiveBot:
    def answer_with_reflection(self, question):
        # 1ë‹¨ê³„: ì²« ë²ˆì§¸ ë‹µë³€ ìƒì„±
        first_answer = self.generate_answer(question)
        print(f"ì´ˆì•ˆ: {first_answer}")

        # 2ë‹¨ê³„: ë‹µë³€ ê²€í† 
        issues = self.find_issues(first_answer)

        if issues:
            print(f"ë°œê²¬ëœ ë¬¸ì œ: {issues}")
            # 3ë‹¨ê³„: ê°œì„ ëœ ë‹µë³€ ìƒì„±
            final_answer = self.improve_answer(first_answer, issues)
            print(f"ìµœì¢…: {final_answer}")
            return final_answer

        return first_answer

    def find_issues(self, answer):
        issues = []
        if len(answer) < 10:
            issues.append("ë„ˆë¬´ ì§§ìŒ")
        if "ì£„ì†¡" in answer:
            issues.append("ë„ˆë¬´ ì†Œê·¹ì ")
        return issues

# ì‚¬ìš© ì˜ˆì‹œ
bot = SimpleReflectiveBot()
bot.answer_with_reflection("Pythonì´ ë­”ê°€ìš”?")
# ì´ˆì•ˆ: "í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì…ë‹ˆë‹¤"
# ë°œê²¬ëœ ë¬¸ì œ: ['ë„ˆë¬´ ì§§ìŒ']
# ìµœì¢…: "Pythonì€ ë°°ìš°ê¸° ì‰½ê³  ê°•ë ¥í•œ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¡œ..."
```

**ğŸŒ¿ ì´ˆê¸‰ììš© - ì²´ê³„ì ì¸ ê²€ì¦**
```python
# ë ˆë²¨ 2: ì—¬ëŸ¬ ê´€ì ì—ì„œ ê²€ì¦
class ReflectiveWriter:
    def __init__(self):
        self.validators = [
            self.check_accuracy,
            self.check_completeness,
            self.check_clarity,
            self.check_tone
        ]

    def write_with_reflection(self, topic, max_iterations=3):
        """ë°˜ë³µì ìœ¼ë¡œ ê°œì„ í•˜ë©° ê¸€ì“°ê¸°"""
        content = self.initial_draft(topic)

        for i in range(max_iterations):
            print(f"\n=== ë°˜ë³µ {i+1} ===")

            # ëª¨ë“  ê²€ì¦ê¸°ë¡œ ê²€í† 
            all_feedback = []
            for validator in self.validators:
                feedback = validator(content)
                if feedback:
                    all_feedback.append(feedback)

            # í”¼ë“œë°±ì´ ì—†ìœ¼ë©´ ì™„ë£Œ
            if not all_feedback:
                print("âœ… ëª¨ë“  ê²€ì¦ í†µê³¼!")
                break

            # í”¼ë“œë°± ê¸°ë°˜ ê°œì„ 
            print(f"í”¼ë“œë°±: {all_feedback}")
            content = self.revise(content, all_feedback)

        return content

    def check_accuracy(self, content):
        """ì •í™•ì„± ê²€ì¦"""
        # ì‹¤ì œë¡œëŠ” íŒ©íŠ¸ ì²´í¬ API í˜¸ì¶œ
        if "ì˜ëª»ëœ ì •ë³´" in content:
            return "ì‚¬ì‹¤ í™•ì¸ í•„ìš”"
        return None

    def check_completeness(self, content):
        """ì™„ì„±ë„ ê²€ì¦"""
        if len(content.split()) < 50:
            return "ë‚´ìš© ë³´ì¶© í•„ìš”"
        return None

    def revise(self, content, feedback_list):
        """í”¼ë“œë°± ë°˜ì˜í•˜ì—¬ ìˆ˜ì •"""
        revised = content
        for feedback in feedback_list:
            if "ë³´ì¶©" in feedback:
                revised += "\nì¶”ê°€ ì„¤ëª…..."
            # ... ë‹¤ë¥¸ ìˆ˜ì • ë¡œì§
        return revised
```

**ğŸŒ³ ì¤‘ê¸‰ììš© - AI ê¸°ë°˜ ìê¸° ê°œì„ **
```python
# ë ˆë²¨ 3: LLMì„ í™œìš©í•œ ê³ ê¸‰ ë°˜ì„±
import json
from typing import Dict, List, Optional

class AdvancedReflectiveAgent:
    def __init__(self, llm_client):
        self.llm = llm_client
        self.reflection_history = []

    async def solve_with_reflection(
        self,
        problem: str,
        max_attempts: int = 3
    ) -> Dict:
        """ë¬¸ì œ í•´ê²° with ìê¸° ë°˜ì„±"""

        attempt = 0
        best_solution = None
        best_score = 0

        while attempt < max_attempts:
            attempt += 1

            # 1. í•´ê²°ì±… ìƒì„±
            solution = await self.generate_solution(
                problem,
                self.reflection_history
            )

            # 2. ìê¸° í‰ê°€
            evaluation = await self.self_evaluate(
                problem,
                solution
            )

            # 3. ë°˜ì„± ë° í•™ìŠµ
            reflection = await self.reflect(
                problem,
                solution,
                evaluation
            )

            self.reflection_history.append({
                'attempt': attempt,
                'solution': solution,
                'evaluation': evaluation,
                'reflection': reflection
            })

            # 4. ê°œì„  ì—¬ë¶€ íŒë‹¨
            if evaluation['score'] > best_score:
                best_score = evaluation['score']
                best_solution = solution

            if evaluation['score'] >= 0.9:  # ì¶©ë¶„íˆ ì¢‹ìŒ
                break

            print(f"ì‹œë„ {attempt}: ì ìˆ˜ {evaluation['score']}")
            print(f"ë°˜ì„±: {reflection['key_insights']}")

        return {
            'solution': best_solution,
            'score': best_score,
            'attempts': attempt,
            'learning': self.extract_learnings()
        }

    async def self_evaluate(self, problem: str, solution: str) -> Dict:
        """í•´ê²°ì±… ìê¸° í‰ê°€"""
        prompt = f"""
        ë¬¸ì œ: {problem}
        ì œì•ˆëœ í•´ê²°ì±…: {solution}

        ì´ í•´ê²°ì±…ì„ ë‹¤ìŒ ê¸°ì¤€ìœ¼ë¡œ í‰ê°€í•˜ì„¸ìš”:
        1. ì •í™•ì„± (0-1)
        2. ì™„ì„±ë„ (0-1)
        3. íš¨ìœ¨ì„± (0-1)
        4. ì°½ì˜ì„± (0-1)

        JSON í˜•ì‹ìœ¼ë¡œ ë‹µí•˜ì„¸ìš”.
        """

        response = await self.llm.generate(prompt)
        return json.loads(response)

    async def reflect(
        self,
        problem: str,
        solution: str,
        evaluation: Dict
    ) -> Dict:
        """í•´ê²° ê³¼ì • ë°˜ì„±"""
        prompt = f"""
        ë¬¸ì œ: {problem}
        ì‹œë„í•œ í•´ê²°ì±…: {solution}
        í‰ê°€ ê²°ê³¼: {json.dumps(evaluation)}

        ë‹¤ìŒì„ ë¶„ì„í•˜ì„¸ìš”:
        1. ë¬´ì—‡ì´ ì˜ ë˜ì—ˆëŠ”ê°€?
        2. ë¬´ì—‡ì´ ë¶€ì¡±í–ˆëŠ”ê°€?
        3. ì–´ë–»ê²Œ ê°œì„ í•  ìˆ˜ ìˆëŠ”ê°€?
        4. ë‹¤ìŒ ì‹œë„ì—ì„œ ì£¼ì˜í•  ì ì€?
        """

        reflection = await self.llm.generate(prompt)
        return {
            'key_insights': self.extract_insights(reflection),
            'improvement_areas': self.identify_improvements(reflection),
            'next_approach': self.suggest_approach(reflection)
        }

# ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ
agent = AdvancedReflectiveAgent(llm_client)
result = await agent.solve_with_reflection(
    "ì‚¬ìš©ì ì´íƒˆë¥ ì„ ì¤„ì´ëŠ” ë°©ë²•ì„ ì œì•ˆí•˜ì„¸ìš”"
)

print(f"ìµœì¢… í•´ê²°ì±…: {result['solution']}")
print(f"í•™ìŠµëœ ë‚´ìš©: {result['learning']}")
```

### ğŸ§© íŒ¨í„´ 5: Tool Use (ë„êµ¬ ì‚¬ìš©)
**"ì ì ˆí•œ ë„êµ¬ ì°¾ì•„ ì“°ê¸°"**

#### ğŸ“š ì´ˆë³´ì ì„¤ëª…
ëª©ìˆ˜ê°€ ì¼í•  ë•Œ:
- ğŸ”¨ ëª» ë°•ì„ ë•ŒëŠ” ë§ì¹˜
- ğŸªš ìë¥¼ ë•ŒëŠ” í†±
- ğŸ“ ì¸¡ì •í•  ë•ŒëŠ” ì

AIë„ **í•„ìš”ì— ë”°ë¼ ë‹¤ì–‘í•œ ë„êµ¬**ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤!

#### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (ìˆ˜ì¤€ë³„)

**ğŸŒ± ì…ë¬¸ììš© - ê°„ë‹¨í•œ ë„êµ¬ ì‚¬ìš©**
```python
# ë ˆë²¨ 1: ê¸°ë³¸ ë„êµ¬ ì‚¬ìš©
class SimpleToolBot:
    def __init__(self):
        # ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬ë“¤
        self.tools = {
            "calculator": self.calculate,
            "translator": self.translate,
            "weather": self.get_weather
        }

    def process_request(self, request):
        """ìš”ì²­ ì²˜ë¦¬ - ì ì ˆí•œ ë„êµ¬ ì„ íƒ"""
        if "ê³„ì‚°" in request or "+" in request:
            return self.tools["calculator"](request)
        elif "ë²ˆì—­" in request:
            return self.tools["translator"](request)
        elif "ë‚ ì”¨" in request:
            return self.tools["weather"](request)
        else:
            return "ë„êµ¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

    def calculate(self, expr):
        # ì‹¤ì œë¡œëŠ” eval ëŒ€ì‹  ì•ˆì „í•œ íŒŒì„œ ì‚¬ìš©
        return f"ë‹µ: {eval(expr.replace('ê³„ì‚°', ''))}"

    def translate(self, text):
        # ì‹¤ì œë¡œëŠ” ë²ˆì—­ API í˜¸ì¶œ
        return f"ë²ˆì—­ ê²°ê³¼: [translated text]"

    def get_weather(self, location):
        # ì‹¤ì œë¡œëŠ” ë‚ ì”¨ API í˜¸ì¶œ
        return f"ì˜¤ëŠ˜ ë‚ ì”¨: ë§‘ìŒ, 20ë„"

# ì‚¬ìš©
bot = SimpleToolBot()
print(bot.process_request("3 + 5 ê³„ì‚°í•´ì¤˜"))
# ì¶œë ¥: "ë‹µ: 8"
```

**ğŸŒ¿ ì´ˆê¸‰ììš© - ë„êµ¬ ì²´ì¸**
```python
# ë ˆë²¨ 2: ì—¬ëŸ¬ ë„êµ¬ë¥¼ ì—°ê²°í•˜ì—¬ ì‚¬ìš©
class ToolChainBot:
    def __init__(self):
        self.tools = {
            "search": GoogleSearchTool(),
            "summarize": SummarizerTool(),
            "translate": TranslatorTool(),
            "save": FileSaverTool()
        }

    async def research_and_report(self, topic, language="ko"):
        """ì—°êµ¬ í›„ ë³´ê³ ì„œ ì‘ì„± - ì—¬ëŸ¬ ë„êµ¬ í™œìš©"""

        # 1. ê²€ìƒ‰ ë„êµ¬ë¡œ ì •ë³´ ìˆ˜ì§‘
        print(f"ğŸ” '{topic}' ê²€ìƒ‰ ì¤‘...")
        search_results = await self.tools["search"].search(topic)

        # 2. ìš”ì•½ ë„êµ¬ë¡œ í•µì‹¬ ì •ë¦¬
        print("ğŸ“ ë‚´ìš© ìš”ì•½ ì¤‘...")
        summary = await self.tools["summarize"].summarize(
            search_results,
            max_length=500
        )

        # 3. ë²ˆì—­ ë„êµ¬ë¡œ ì–¸ì–´ ë³€í™˜
        if language != "en":
            print(f"ğŸŒ {language}ë¡œ ë²ˆì—­ ì¤‘...")
            summary = await self.tools["translate"].translate(
                summary,
                target_lang=language
            )

        # 4. ì €ì¥ ë„êµ¬ë¡œ íŒŒì¼ ì €ì¥
        print("ğŸ’¾ ê²°ê³¼ ì €ì¥ ì¤‘...")
        file_path = await self.tools["save"].save(
            content=summary,
            filename=f"{topic}_report.txt"
        )

        return {
            "topic": topic,
            "summary": summary,
            "saved_to": file_path
        }

# ì‚¬ìš© ì˜ˆì‹œ
bot = ToolChainBot()
report = await bot.research_and_report(
    "ì¸ê³µì§€ëŠ¥ ìµœì‹  ë™í–¥",
    language="ko"
)
```

**ğŸŒ³ ì¤‘ê¸‰ììš© - ë™ì  ë„êµ¬ ì„ íƒ**
```python
# ë ˆë²¨ 3: AIê°€ ìŠ¤ìŠ¤ë¡œ ë„êµ¬ ì„ íƒ
from typing import List, Dict, Any
import inspect

class Tool:
    """ë„êµ¬ ë² ì´ìŠ¤ í´ë˜ìŠ¤"""
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description

    def get_schema(self) -> Dict:
        """ë„êµ¬ ì‚¬ìš©ë²• ìŠ¤í‚¤ë§ˆ ë°˜í™˜"""
        return {
            "name": self.name,
            "description": self.description,
            "parameters": self._extract_parameters()
        }

    def _extract_parameters(self):
        """í•¨ìˆ˜ íŒŒë¼ë¯¸í„° ìë™ ì¶”ì¶œ"""
        sig = inspect.signature(self.execute)
        params = {}
        for name, param in sig.parameters.items():
            if name != 'self':
                params[name] = {
                    "type": param.annotation.__name__
                    if param.annotation != inspect.Parameter.empty
                    else "string",
                    "required": param.default == inspect.Parameter.empty
                }
        return params

class SmartToolAgent:
    def __init__(self, llm_client):
        self.llm = llm_client
        self.tools: Dict[str, Tool] = {}

    def register_tool(self, tool: Tool):
        """ë„êµ¬ ë“±ë¡"""
        self.tools[tool.name] = tool

    async def process(self, user_query: str) -> Any:
        """ì‚¬ìš©ì ì¿¼ë¦¬ ì²˜ë¦¬ - AIê°€ ë„êµ¬ ì„ íƒ"""

        # 1. ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬ ëª©ë¡ ìƒì„±
        tools_desc = self._format_tools_description()

        # 2. AIì—ê²Œ ë„êµ¬ ì„ íƒ ìš”ì²­
        tool_selection = await self._select_tools(
            user_query,
            tools_desc
        )

        # 3. ì„ íƒëœ ë„êµ¬ë“¤ ì‹¤í–‰
        results = []
        for tool_call in tool_selection:
            tool_name = tool_call['tool']
            params = tool_call['parameters']

            if tool_name in self.tools:
                tool = self.tools[tool_name]
                result = await tool.execute(**params)
                results.append({
                    'tool': tool_name,
                    'result': result
                })

        # 4. ê²°ê³¼ ì¢…í•©
        final_response = await self._synthesize_results(
            user_query,
            results
        )

        return final_response

    async def _select_tools(
        self,
        query: str,
        tools_desc: str
    ) -> List[Dict]:
        """AIê°€ í•„ìš”í•œ ë„êµ¬ ì„ íƒ"""
        prompt = f"""
        ì‚¬ìš©ì ìš”ì²­: {query}

        ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬:
        {tools_desc}

        ì´ ìš”ì²­ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ í•„ìš”í•œ ë„êµ¬ì™€ íŒŒë¼ë¯¸í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.
        ì—¬ëŸ¬ ë„êµ¬ë¥¼ ìˆœì„œëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

        JSON ë°°ì—´ í˜•ì‹ìœ¼ë¡œ ë‹µí•˜ì„¸ìš”:
        [
            {{
                "tool": "ë„êµ¬ì´ë¦„",
                "parameters": {{...}},
                "reason": "ì„ íƒ ì´ìœ "
            }}
        ]
        """

        response = await self.llm.generate(prompt)
        return json.loads(response)

# ì‹¤ì œ ë„êµ¬ êµ¬í˜„ ì˜ˆì‹œ
class WebSearchTool(Tool):
    def __init__(self):
        super().__init__(
            name="web_search",
            description="ì›¹ì—ì„œ ì •ë³´ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤"
        )

    async def execute(self, query: str, max_results: int = 5) -> List:
        # ì‹¤ì œ ê²€ìƒ‰ API í˜¸ì¶œ
        results = await search_api.search(query, max_results)
        return results

class DatabaseTool(Tool):
    def __init__(self, connection_string):
        super().__init__(
            name="database",
            description="ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤"
        )
        self.db = Database(connection_string)

    async def execute(self, sql: str) -> List[Dict]:
        return await self.db.query(sql)

# ì‚¬ìš© ì˜ˆì‹œ
agent = SmartToolAgent(llm_client)
agent.register_tool(WebSearchTool())
agent.register_tool(DatabaseTool("postgresql://..."))
agent.register_tool(EmailTool())

response = await agent.process(
    "ìµœê·¼ íŒë§¤ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ê³  ë³´ê³ ì„œë¥¼ ì´ë©”ì¼ë¡œ ë³´ë‚´ì¤˜"
)
# AIê°€ ìë™ìœ¼ë¡œ:
# 1. DatabaseToolë¡œ ë°ì´í„° ì¡°íšŒ
# 2. ë‚´ì¥ ë¶„ì„ ê¸°ëŠ¥ìœ¼ë¡œ ì²˜ë¦¬
# 3. EmailToolë¡œ ì „ì†¡
```

### ğŸ§© íŒ¨í„´ 6: Planning (ê³„íš ìˆ˜ë¦½)
**"ëª©í‘œ ë‹¬ì„±ì„ ìœ„í•œ ë¡œë“œë§µ ë§Œë“¤ê¸°"**

#### ğŸ“š ì´ˆë³´ì ì„¤ëª…
ì—¬í–‰ ê³„íšì²˜ëŸ¼:
1. ğŸ¯ ëª©ì ì§€ ì •í•˜ê¸° (ëª©í‘œ)
2. ğŸ—ºï¸ ê²½ë¡œ ê³„íš (ë‹¨ê³„)
3. ğŸ’ ì¤€ë¹„ë¬¼ ì±™ê¸°ê¸° (ìì›)
4. ğŸš— ì¶œë°œ! (ì‹¤í–‰)

#### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (ìˆ˜ì¤€ë³„)

**ğŸŒ± ì…ë¬¸ììš© - ë‹¨ìˆœ ê³„íš**
```python
# ë ˆë²¨ 1: ê°„ë‹¨í•œ ë‹¨ê³„ë³„ ê³„íš
class SimplePlanner:
    def make_plan(self, goal):
        """ëª©í‘œì— ë”°ë¥¸ ê³„íš ìƒì„±"""
        if goal == "ì›¹ì‚¬ì´íŠ¸ ë§Œë“¤ê¸°":
            return [
                "1. ìš”êµ¬ì‚¬í•­ ë¶„ì„",
                "2. ë””ìì¸ ìŠ¤ì¼€ì¹˜",
                "3. HTML/CSS ì½”ë”©",
                "4. JavaScript ì¶”ê°€",
                "5. í…ŒìŠ¤íŠ¸",
                "6. ë°°í¬"
            ]
        elif goal == "ì•± ê°œë°œ":
            return [
                "1. ì•„ì´ë””ì–´ êµ¬ì²´í™”",
                "2. í™”ë©´ ì„¤ê³„",
                "3. ë°±ì—”ë“œ êµ¬ì¶•",
                "4. í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ",
                "5. í†µí•© í…ŒìŠ¤íŠ¸",
                "6. ì¶œì‹œ"
            ]

    def execute_plan(self, plan):
        """ê³„íš ì‹¤í–‰"""
        for step in plan:
            print(f"ì‹¤í–‰ ì¤‘: {step}")
            # ì‹¤ì œ ì‘ì—… ìˆ˜í–‰
            self.do_work(step)
            print(f"âœ… ì™„ë£Œ: {step}")

planner = SimplePlanner()
plan = planner.make_plan("ì›¹ì‚¬ì´íŠ¸ ë§Œë“¤ê¸°")
planner.execute_plan(plan)
```

**ğŸŒ¿ ì´ˆê¸‰ììš© - ë™ì  ê³„íš**
```python
# ë ˆë²¨ 2: ìƒí™©ì— ë§ëŠ” ê³„íš ìƒì„±
class DynamicPlanner:
    def __init__(self):
        self.task_templates = {
            "research": ["ì¡°ì‚¬", "ë¶„ì„", "ì •ë¦¬", "ë³´ê³ "],
            "development": ["ì„¤ê³„", "êµ¬í˜„", "í…ŒìŠ¤íŠ¸", "ë°°í¬"],
            "learning": ["ê°œë… ì´í•´", "ì‹¤ìŠµ", "í”„ë¡œì íŠ¸", "ë³µìŠµ"]
        }

    def create_plan(self, goal, context):
        """ëª©í‘œì™€ ë§¥ë½ ê¸°ë°˜ ê³„íš ìƒì„±"""
        plan = Plan(goal)

        # ëª©í‘œ ë¶„ì„
        task_type = self.analyze_goal(goal)
        template = self.task_templates.get(task_type, [])

        # ë§¥ë½ ë°˜ì˜
        for step_template in template:
            step = self.customize_step(step_template, context)
            plan.add_step(step)

        # ì‹œê°„ ë° ë¦¬ì†ŒìŠ¤ í• ë‹¹
        plan.allocate_resources(context.get("resources", {}))
        plan.estimate_time()

        return plan

    def analyze_goal(self, goal):
        """ëª©í‘œ ìœ í˜• ë¶„ì„"""
        if "ì¡°ì‚¬" in goal or "ë¶„ì„" in goal:
            return "research"
        elif "ê°œë°œ" in goal or "êµ¬ì¶•" in goal:
            return "development"
        elif "ë°°ìš°" in goal or "í•™ìŠµ" in goal:
            return "learning"
        return "general"

    def customize_step(self, template, context):
        """ë‹¨ê³„ë¥¼ ë§¥ë½ì— ë§ê²Œ ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ"""
        step = Step(template)

        if context.get("deadline"):
            step.set_deadline(context["deadline"])

        if context.get("team_size"):
            step.assign_resources(context["team_size"])

        return step

class Plan:
    def __init__(self, goal):
        self.goal = goal
        self.steps = []
        self.total_time = 0

    def add_step(self, step):
        self.steps.append(step)

    def allocate_resources(self, resources):
        """ë¦¬ì†ŒìŠ¤ í• ë‹¹"""
        for step in self.steps:
            step.resources = resources.get(step.name, {})

    def estimate_time(self):
        """ì‹œê°„ ì¶”ì •"""
        self.total_time = sum(step.estimated_time for step in self.steps)

# ì‚¬ìš© ì˜ˆì‹œ
planner = DynamicPlanner()
context = {
    "deadline": "2024-12-31",
    "team_size": 3,
    "resources": {"budget": 10000}
}
plan = planner.create_plan("AI ì±—ë´‡ ê°œë°œ", context)
```

**ğŸŒ³ ì¤‘ê¸‰ììš© - AI ê¸°ë°˜ ê³„íš**
```python
# ë ˆë²¨ 3: AIê°€ ìŠ¤ìŠ¤ë¡œ ê³„íš ìˆ˜ë¦½ ë° ì¡°ì •
class AIPlanner:
    def __init__(self, llm_client):
        self.llm = llm_client
        self.execution_history = []

    async def plan_and_execute(self, goal: str, constraints: Dict):
        """ëª©í‘œ ë‹¬ì„±ì„ ìœ„í•œ ê³„íš ìˆ˜ë¦½ ë° ì‹¤í–‰"""

        # 1. ì´ˆê¸° ê³„íš ìƒì„±
        initial_plan = await self.generate_plan(goal, constraints)

        # 2. ê³„íš ê²€ì¦
        validation = await self.validate_plan(initial_plan)

        if not validation['is_valid']:
            # 3. ë¬¸ì œì  ê¸°ë°˜ ì¬ê³„íš
            initial_plan = await self.revise_plan(
                initial_plan,
                validation['issues']
            )

        # 4. ì ì‘í˜• ì‹¤í–‰
        results = await self.adaptive_execution(initial_plan)

        return {
            'goal': goal,
            'plan': initial_plan,
            'execution_results': results,
            'success': self.evaluate_success(results, goal)
        }

    async def generate_plan(self, goal: str, constraints: Dict) -> Dict:
        """AIë¡œ ê³„íš ìƒì„±"""
        prompt = f"""
        ëª©í‘œ: {goal}
        ì œì•½ì‚¬í•­: {json.dumps(constraints, ensure_ascii=False)}

        ì´ ëª©í‘œë¥¼ ë‹¬ì„±í•˜ê¸° ìœ„í•œ ìƒì„¸í•œ ê³„íšì„ ìˆ˜ë¦½í•˜ì„¸ìš”.

        ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ë‹µí•˜ì„¸ìš”:
        {{
            "steps": [
                {{
                    "id": "step_1",
                    "action": "êµ¬ì²´ì ì¸ í–‰ë™",
                    "dependencies": [],
                    "estimated_time": "1h",
                    "required_resources": [],
                    "success_criteria": "ì™„ë£Œ ê¸°ì¤€"
                }}
            ],
            "total_estimated_time": "ì´ ì‹œê°„",
            "critical_path": ["ì¤‘ìš” ê²½ë¡œì˜ step_idë“¤"],
            "risk_factors": ["ì ì¬ì  ìœ„í—˜"],
            "fallback_strategies": {{}}
        }}
        """

        response = await self.llm.generate(prompt)
        return json.loads(response)

    async def adaptive_execution(self, plan: Dict) -> List[Dict]:
        """ì ì‘í˜• ê³„íš ì‹¤í–‰"""
        results = []
        executed_steps = set()

        while len(executed_steps) < len(plan['steps']):
            # ì‹¤í–‰ ê°€ëŠ¥í•œ ë‹¨ê³„ ì°¾ê¸°
            ready_steps = self.find_ready_steps(
                plan['steps'],
                executed_steps
            )

            if not ready_steps:
                # êµì°© ìƒíƒœ í•´ê²°
                await self.resolve_deadlock(plan, executed_steps)
                continue

            # ë³‘ë ¬ ì‹¤í–‰ ê°€ëŠ¥í•œ ë‹¨ê³„ë“¤ ë™ì‹œ ì‹¤í–‰
            step_results = await asyncio.gather(*[
                self.execute_step(step)
                for step in ready_steps
            ])

            # ê²°ê³¼ ì²˜ë¦¬ ë° ê³„íš ì¡°ì •
            for step, result in zip(ready_steps, step_results):
                results.append(result)
                executed_steps.add(step['id'])

                if not result['success']:
                    # ì‹¤íŒ¨ ì‹œ ì¬ê³„íš
                    plan = await self.replan_on_failure(
                        plan,
                        step,
                        result['error']
                    )

        return results

    def find_ready_steps(self, steps, executed):
        """ì‹¤í–‰ ê°€ëŠ¥í•œ ë‹¨ê³„ ì°¾ê¸°"""
        ready = []
        for step in steps:
            if step['id'] not in executed:
                deps = set(step.get('dependencies', []))
                if deps.issubset(executed):
                    ready.append(step)
        return ready

    async def replan_on_failure(self, plan, failed_step, error):
        """ì‹¤íŒ¨ ì‹œ ì¬ê³„íš"""
        prompt = f"""
        ì‹¤í–‰ ì¤‘ ì‹¤íŒ¨ ë°œìƒ:
        ì‹¤íŒ¨í•œ ë‹¨ê³„: {json.dumps(failed_step)}
        ì—ëŸ¬: {error}
        í˜„ì¬ ê³„íš: {json.dumps(plan)}

        ëŒ€ì²´ ê³„íšì„ ì œì‹œí•˜ì„¸ìš”.
        """

        new_plan = await self.llm.generate(prompt)
        return json.loads(new_plan)

# ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ
planner = AIPlanner(llm_client)
result = await planner.plan_and_execute(
    goal="ê³ ê° ì„œë¹„ìŠ¤ ì±—ë´‡ êµ¬ì¶•",
    constraints={
        "budget": 50000,
        "deadline": "2024-06-01",
        "team_size": 2,
        "tech_stack": ["Python", "FastAPI", "PostgreSQL"]
    }
)

print(f"ê³„íš: {result['plan']}")
print(f"ì‹¤í–‰ ê²°ê³¼: {result['execution_results']}")
print(f"ì„±ê³µ ì—¬ë¶€: {result['success']}")
```

### ğŸ§© íŒ¨í„´ 7: Multi-Agent (ë‹¤ì¤‘ ì—ì´ì „íŠ¸)
**"íŒ€ì›Œí¬ë¡œ ë¬¸ì œ í•´ê²°í•˜ê¸°"**

#### ğŸ“š ì´ˆë³´ì ì„¤ëª…
íšŒì‚¬ì²˜ëŸ¼:
- ğŸ‘” CEO: ì „ì²´ ë°©í–¥ ê²°ì •
- ğŸ’¼ ê´€ë¦¬ì: ì‘ì—… ë¶„ë°°
- ğŸ‘· ì§ì›ë“¤: ì‹¤ì œ ì‘ì—…
- ğŸ“Š ë¶„ì„ê°€: ê²°ê³¼ ê²€í† 

ì—¬ëŸ¬ AIê°€ **ê°ìì˜ ì—­í• **ì„ ë§¡ì•„ í˜‘ì—…!

#### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (ìˆ˜ì¤€ë³„)

**ğŸŒ± ì…ë¬¸ììš© - ê°„ë‹¨í•œ í˜‘ì—…**
```python
# ë ˆë²¨ 1: ê¸°ë³¸ ë©€í‹° ì—ì´ì „íŠ¸
class SimpleMultiAgent:
    def __init__(self):
        # ê° ì—ì´ì „íŠ¸ ì •ì˜
        self.researcher = ResearchAgent()
        self.writer = WriterAgent()
        self.editor = EditorAgent()

    def create_article(self, topic):
        """ê¸°ì‚¬ ì‘ì„± - 3ê°œ ì—ì´ì „íŠ¸ í˜‘ì—…"""

        # 1. ì—°êµ¬ì›ì´ ìë£Œ ìˆ˜ì§‘
        print("ğŸ” ì—°êµ¬ì›: ìë£Œ ìˆ˜ì§‘ ì¤‘...")
        research_data = self.researcher.gather_info(topic)

        # 2. ì‘ê°€ê°€ ì´ˆì•ˆ ì‘ì„±
        print("âœï¸ ì‘ê°€: ê¸€ ì‘ì„± ì¤‘...")
        draft = self.writer.write_draft(research_data)

        # 3. í¸ì§‘ìê°€ ê²€í†  ë° ìˆ˜ì •
        print("ğŸ“ í¸ì§‘ì: ê²€í†  ë° ìˆ˜ì • ì¤‘...")
        final_article = self.editor.edit(draft)

        return final_article

class ResearchAgent:
    def gather_info(self, topic):
        # ì‹¤ì œë¡œëŠ” ì›¹ ê²€ìƒ‰, DB ì¡°íšŒ ë“±
        return f"{topic}ì— ëŒ€í•œ ì—°êµ¬ ìë£Œ..."

class WriterAgent:
    def write_draft(self, research):
        return f"ì œëª©: ...\n\në³¸ë¬¸: {research}ë¥¼ ë°”íƒ•ìœ¼ë¡œ..."

class EditorAgent:
    def edit(self, draft):
        return draft.replace("...", "[ìˆ˜ì •ë¨]")

# ì‚¬ìš©
team = SimpleMultiAgent()
article = team.create_article("AIì˜ ë¯¸ë˜")
```

**ğŸŒ¿ ì´ˆê¸‰ììš© - ë©”ì‹œì§€ ê¸°ë°˜ í˜‘ì—…**
```python
# ë ˆë²¨ 2: ë©”ì‹œì§€ ì „ë‹¬ ì‹œìŠ¤í…œ
from queue import Queue
from threading import Thread

class Agent:
    def __init__(self, name, role):
        self.name = name
        self.role = role
        self.inbox = Queue()
        self.running = True

    def send_message(self, recipient, message):
        """ë‹¤ë¥¸ ì—ì´ì „íŠ¸ì—ê²Œ ë©”ì‹œì§€ ì „ì†¡"""
        recipient.inbox.put({
            'from': self.name,
            'content': message
        })

    def process_messages(self):
        """ë°›ì€ ë©”ì‹œì§€ ì²˜ë¦¬"""
        while self.running:
            if not self.inbox.empty():
                message = self.inbox.get()
                self.handle_message(message)

    def handle_message(self, message):
        """ë©”ì‹œì§€ ì²˜ë¦¬ (í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„)"""
        pass

class ProjectManager(Agent):
    def __init__(self):
        super().__init__("PM", "í”„ë¡œì íŠ¸ ê´€ë¦¬")
        self.team = {}

    def add_team_member(self, agent):
        self.team[agent.name] = agent

    def assign_task(self, task):
        """ì‘ì—… ë¶„ë°°"""
        if "ê°œë°œ" in task:
            self.send_message(self.team["Developer"], task)
        elif "ë””ìì¸" in task:
            self.send_message(self.team["Designer"], task)
        elif "í…ŒìŠ¤íŠ¸" in task:
            self.send_message(self.team["Tester"], task)

    def handle_message(self, message):
        if "ì™„ë£Œ" in message['content']:
            print(f"âœ… {message['from']}ê°€ ì‘ì—… ì™„ë£Œ!")
            # ë‹¤ìŒ ì‘ì—… í• ë‹¹
            self.assign_next_task()

class Developer(Agent):
    def __init__(self):
        super().__init__("Developer", "ê°œë°œ")

    def handle_message(self, message):
        print(f"ğŸ’» ê°œë°œì: {message['content']} ì‘ì—… ì¤‘...")
        # ì‘ì—… ìˆ˜í–‰
        result = self.do_development(message['content'])
        # ì™„ë£Œ ë³´ê³ 
        self.send_message(message['from'], f"ê°œë°œ ì™„ë£Œ: {result}")

# íŒ€ êµ¬ì„± ë° ì‹¤í–‰
pm = ProjectManager()
dev = Developer()
designer = Designer()
tester = Tester()

pm.add_team_member(dev)
pm.add_team_member(designer)
pm.add_team_member(tester)

# í”„ë¡œì íŠ¸ ì‹œì‘
pm.assign_task("ë¡œê·¸ì¸ ê¸°ëŠ¥ ê°œë°œ")
```

**ğŸŒ³ ì¤‘ê¸‰ììš© - ììœ¨ í˜‘ì—… ì‹œìŠ¤í…œ**
```python
# ë ˆë²¨ 3: ê³ ê¸‰ ë©€í‹° ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

class AgentRole(Enum):
    COORDINATOR = "coordinator"
    SPECIALIST = "specialist"
    REVIEWER = "reviewer"
    EXECUTOR = "executor"

@dataclass
class Task:
    id: str
    description: str
    required_skills: List[str]
    priority: int
    dependencies: List[str]
    status: str = "pending"
    assigned_to: Optional[str] = None
    result: Optional[Any] = None

class AutonomousAgent:
    def __init__(self, agent_id: str, role: AgentRole, skills: List[str]):
        self.id = agent_id
        self.role = role
        self.skills = skills
        self.task_queue = asyncio.Queue()
        self.knowledge_base = {}
        self.llm_client = None  # LLM ì—°ê²°

    async def think(self, context: Dict) -> Dict:
        """ìƒí™© ë¶„ì„ ë° ì˜ì‚¬ê²°ì •"""
        prompt = f"""
        ì—ì´ì „íŠ¸ ì—­í• : {self.role.value}
        ì „ë¬¸ ë¶„ì•¼: {self.skills}
        í˜„ì¬ ìƒí™©: {context}

        ë‹¤ìŒ í–‰ë™ì„ ê²°ì •í•˜ì„¸ìš”.
        """

        decision = await self.llm_client.generate(prompt)
        return json.loads(decision)

    async def collaborate(self, other_agents: List['AutonomousAgent'], task: Task):
        """ë‹¤ë¥¸ ì—ì´ì „íŠ¸ì™€ í˜‘ì—…"""
        # í•„ìš”í•œ ì „ë¬¸ê°€ ì°¾ê¸°
        experts = self.find_experts(other_agents, task.required_skills)

        if not experts:
            return await self.handle_solo(task)

        # í˜‘ì—… ì „ëµ ìˆ˜ë¦½
        strategy = await self.plan_collaboration(task, experts)

        # ì‘ì—… ë¶„ë°°
        subtasks = await self.decompose_task(task, strategy)

        # ë¹„ë™ê¸° í˜‘ì—… ì‹¤í–‰
        results = await asyncio.gather(*[
            expert.execute_subtask(subtask)
            for expert, subtask in zip(experts, subtasks)
        ])

        # ê²°ê³¼ í†µí•©
        return await self.integrate_results(results)

    def find_experts(self, agents: List['AutonomousAgent'], skills: List[str]):
        """í•„ìš”í•œ ê¸°ìˆ ì„ ê°€ì§„ ì „ë¬¸ê°€ ì°¾ê¸°"""
        experts = []
        for skill in skills:
            for agent in agents:
                if skill in agent.skills and agent not in experts:
                    experts.append(agent)
                    break
        return experts

class MultiAgentSystem:
    def __init__(self):
        self.agents: Dict[str, AutonomousAgent] = {}
        self.task_pool: List[Task] = []
        self.communication_bus = asyncio.Queue()

    def add_agent(self, agent: AutonomousAgent):
        """ì—ì´ì „íŠ¸ ì¶”ê°€"""
        self.agents[agent.id] = agent

    async def solve_problem(self, problem: str) -> Dict:
        """ë¬¸ì œ í•´ê²° - ì „ì²´ ì‹œìŠ¤í…œ ì¡°ìœ¨"""

        # 1. ë¬¸ì œ ë¶„ì„ ë° ì‘ì—… ë¶„í•´
        tasks = await self.decompose_problem(problem)

        # 2. ì¡°ìœ¨ì ì„ ì¶œ
        coordinator = self.elect_coordinator()

        # 3. ì‘ì—… í• ë‹¹ ì „ëµ ìˆ˜ë¦½
        allocation = await coordinator.plan_allocation(tasks, self.agents)

        # 4. ë³‘ë ¬ ì‘ì—… ì‹¤í–‰
        results = []
        for task in tasks:
            assigned_agents = allocation[task.id]

            if len(assigned_agents) > 1:
                # í˜‘ì—… í•„ìš”
                result = await self.collaborative_execution(
                    task,
                    assigned_agents
                )
            else:
                # ë‹¨ë… ì‹¤í–‰
                result = await assigned_agents[0].execute(task)

            results.append(result)

            # ì¤‘ê°„ ê²°ê³¼ ê³µìœ 
            await self.broadcast_progress(task, result)

        # 5. ìµœì¢… ê²°ê³¼ í†µí•©
        final_result = await self.synthesize_results(results)

        return {
            'problem': problem,
            'solution': final_result,
            'agents_involved': [a.id for a in self.agents.values()],
            'tasks_completed': len(tasks)
        }

    async def collaborative_execution(
        self,
        task: Task,
        agents: List[AutonomousAgent]
    ):
        """í˜‘ì—… ì‹¤í–‰ ê´€ë¦¬"""

        # ë¦¬ë” ì„ ì¶œ
        leader = self.select_leader(agents, task)

        # ë¦¬ë”ê°€ ì‘ì—… ì¡°ìœ¨
        subtasks = await leader.decompose_for_team(task, agents)

        # ë™ì‹œ ì‹¤í–‰
        async def execute_with_communication(agent, subtask):
            result = await agent.execute(subtask)

            # ì§„í–‰ ìƒí™© ê³µìœ 
            await self.communication_bus.put({
                'agent': agent.id,
                'subtask': subtask.id,
                'status': 'completed',
                'result': result
            })

            return result

        results = await asyncio.gather(*[
            execute_with_communication(agent, subtask)
            for agent, subtask in zip(agents, subtasks)
        ])

        # ë¦¬ë”ê°€ ê²°ê³¼ ê²€ì¦ ë° í†µí•©
        return await leader.validate_and_integrate(results)

    async def broadcast_progress(self, task: Task, result: Any):
        """ì§„í–‰ ìƒí™© ì „íŒŒ"""
        message = {
            'type': 'progress',
            'task': task.id,
            'status': task.status,
            'result': result
        }

        # ëª¨ë“  ì—ì´ì „íŠ¸ì—ê²Œ ì „ë‹¬
        for agent in self.agents.values():
            await agent.receive_update(message)

# ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ
async def main():
    # ë©€í‹° ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ êµ¬ì„±
    system = MultiAgentSystem()

    # ë‹¤ì–‘í•œ ì „ë¬¸ê°€ ì—ì´ì „íŠ¸ ì¶”ê°€
    system.add_agent(AutonomousAgent(
        "architect",
        AgentRole.SPECIALIST,
        ["system_design", "architecture"]
    ))
    system.add_agent(AutonomousAgent(
        "backend_dev",
        AgentRole.EXECUTOR,
        ["python", "database", "api"]
    ))
    system.add_agent(AutonomousAgent(
        "frontend_dev",
        AgentRole.EXECUTOR,
        ["javascript", "react", "ui"]
    ))
    system.add_agent(AutonomousAgent(
        "qa_engineer",
        AgentRole.REVIEWER,
        ["testing", "quality_assurance"]
    ))

    # ë³µì¡í•œ ë¬¸ì œ í•´ê²°
    result = await system.solve_problem(
        "ì „ììƒê±°ë˜ í”Œë«í¼ êµ¬ì¶•"
    )

    print(f"í•´ê²°ì±…: {result['solution']}")
    print(f"ì°¸ì—¬ ì—ì´ì „íŠ¸: {result['agents_involved']}")

asyncio.run(main())
```

---

## ì´ˆë³´ìë¥¼ ìœ„í•œ ë‹¨ê³„ë³„ ì‹¤ìŠµ

### ğŸ“ ë ˆë²¨ 1: Hello Agent! (ì²« ë²ˆì§¸ ì—ì´ì „íŠ¸)

```python
# step1_hello_agent.py
"""
ëª©í‘œ: ê°€ì¥ ê°„ë‹¨í•œ AI ì—ì´ì „íŠ¸ ë§Œë“¤ê¸°
ì‹œê°„: 10ë¶„
"""

class MyFirstAgent:
    def __init__(self, name):
        self.name = name
        self.memory = []  # ê¸°ì–µ ì €ì¥ì†Œ

    def listen(self, user_input):
        """ì‚¬ìš©ì ì…ë ¥ ë“£ê¸°"""
        self.memory.append(user_input)
        return f"{self.name}ì´(ê°€) ë“¤ì—ˆìŠµë‹ˆë‹¤: {user_input}"

    def think(self):
        """ìƒê°í•˜ê¸° (ê°„ë‹¨í•œ ì²˜ë¦¬)"""
        if self.memory:
            last_input = self.memory[-1]
            if "ì•ˆë…•" in last_input:
                return "ì¸ì‚¬"
            elif "?" in last_input:
                return "ì§ˆë¬¸"
            else:
                return "ì¼ë°˜"
        return "ì—†ìŒ"

    def respond(self):
        """ì‘ë‹µí•˜ê¸°"""
        thought = self.think()

        responses = {
            "ì¸ì‚¬": "ì•ˆë…•í•˜ì„¸ìš”! ë°˜ê°‘ìŠµë‹ˆë‹¤ ğŸ˜Š",
            "ì§ˆë¬¸": "ì¢‹ì€ ì§ˆë¬¸ì´ë„¤ìš”! í•¨ê»˜ ìƒê°í•´ë´ìš”.",
            "ì¼ë°˜": "í¥ë¯¸ë¡­ë„¤ìš”. ë” ë§ì”€í•´ì£¼ì„¸ìš”.",
            "ì—†ìŒ": "ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?"
        }

        return responses.get(thought, "ì´í•´í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")

# ì‹¤ìŠµí•˜ê¸°
agent = MyFirstAgent("ë„ìš°ë¯¸")

print(agent.listen("ì•ˆë…•í•˜ì„¸ìš”!"))
print(agent.respond())

print(agent.listen("ì˜¤ëŠ˜ ë‚ ì”¨ ì–´ë•Œ?"))
print(agent.respond())

# ë„ì „ ê³¼ì œ:
# 1. ì—ì´ì „íŠ¸ê°€ ì‚¬ìš©ì ì´ë¦„ì„ ê¸°ì–µí•˜ê²Œ ë§Œë“¤ê¸°
# 2. ëŒ€í™” ë§¥ë½ì„ ì´í•´í•˜ê²Œ ë§Œë“¤ê¸°
# 3. ê°ì •ì„ í‘œí˜„í•˜ê²Œ ë§Œë“¤ê¸°
```

### ğŸ“ ë ˆë²¨ 2: ì²´ì¸ ë§Œë“¤ê¸° (ì‘ì—… ì—°ê²°)

```python
# step2_chain_agent.py
"""
ëª©í‘œ: ì—¬ëŸ¬ ë‹¨ê³„ë¥¼ ì—°ê²°í•˜ëŠ” ì—ì´ì „íŠ¸
ì‹œê°„: 20ë¶„
"""

class ChainAgent:
    def __init__(self):
        self.steps = []
        self.results = {}

    def add_step(self, name, function):
        """ë‹¨ê³„ ì¶”ê°€"""
        self.steps.append({
            'name': name,
            'function': function
        })
        return self

    def execute(self, initial_input):
        """ì²´ì¸ ì‹¤í–‰"""
        current_data = initial_input

        print("ğŸš€ ì²´ì¸ ì‹œì‘!")
        print("-" * 30)

        for i, step in enumerate(self.steps, 1):
            print(f"Step {i}: {step['name']}")

            try:
                # ì´ì „ ê²°ê³¼ë¥¼ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì „ë‹¬
                current_data = step['function'](current_data)
                self.results[step['name']] = current_data
                print(f"âœ… ê²°ê³¼: {current_data[:50]}...")  # ì²˜ìŒ 50ìë§Œ
            except Exception as e:
                print(f"âŒ ì˜¤ë¥˜ ë°œìƒ: {e}")
                break

            print("-" * 30)

        print("ğŸ‰ ì²´ì¸ ì™„ë£Œ!")
        return current_data

# ì‹¤ìŠµ: ë¸”ë¡œê·¸ í¬ìŠ¤íŠ¸ ìƒì„± ì²´ì¸
def generate_title(topic):
    """ì œëª© ìƒì„±"""
    return f"ì´ˆë³´ìë¥¼ ìœ„í•œ {topic} ì™„ë²½ ê°€ì´ë“œ"

def create_outline(title):
    """ê°œìš” ì‘ì„±"""
    return f"""
    ì œëª©: {title}

    1. ì„œë¡ 
    2. ê¸°ë³¸ ê°œë…
    3. ì‹¤ìŠµ ì˜ˆì œ
    4. í™œìš© ë°©ë²•
    5. ê²°ë¡ 
    """

def write_intro(outline):
    """ì„œë¡  ì‘ì„±"""
    return f"""
    {outline}

    ì„œë¡ :
    ì´ ê¸€ì—ì„œëŠ” ì´ˆë³´ìë„ ì‰½ê²Œ ì´í•´í•  ìˆ˜ ìˆë„ë¡...
    """

def add_examples(content):
    """ì˜ˆì œ ì¶”ê°€"""
    return f"""
    {content}

    ì˜ˆì œ 1: Hello World
    ì˜ˆì œ 2: ì‹¤ì „ í™œìš©
    """

# ì²´ì¸ êµ¬ì„± ë° ì‹¤í–‰
blog_chain = ChainAgent()
blog_chain.add_step("ì œëª© ìƒì„±", generate_title) \
          .add_step("ê°œìš” ì‘ì„±", create_outline) \
          .add_step("ì„œë¡  ì‘ì„±", write_intro) \
          .add_step("ì˜ˆì œ ì¶”ê°€", add_examples)

result = blog_chain.execute("Python")
print("\nìµœì¢… ê²°ê³¼:")
print(result)

# ë„ì „ ê³¼ì œ:
# 1. ì—ëŸ¬ ë°œìƒ ì‹œ ì¬ì‹œë„ ê¸°ëŠ¥ ì¶”ê°€
# 2. ê° ë‹¨ê³„ ì‹¤í–‰ ì‹œê°„ ì¸¡ì •
# 3. ì¤‘ê°„ ê²°ê³¼ ì €ì¥ ê¸°ëŠ¥
```

### ğŸ“ ë ˆë²¨ 3: ë„êµ¬ ì‚¬ìš© ì—ì´ì „íŠ¸

```python
# step3_tool_agent.py
"""
ëª©í‘œ: ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ë˜‘ë˜‘í•œ ì—ì´ì „íŠ¸
ì‹œê°„: 30ë¶„
"""

import random
import json
from datetime import datetime

class ToolAgent:
    def __init__(self, name):
        self.name = name
        self.tools = {}

    def register_tool(self, tool_name, tool_function, description):
        """ë„êµ¬ ë“±ë¡"""
        self.tools[tool_name] = {
            'function': tool_function,
            'description': description
        }
        print(f"ğŸ”§ ë„êµ¬ ë“±ë¡: {tool_name}")

    def list_tools(self):
        """ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬ ëª©ë¡"""
        print(f"\nğŸ“¦ {self.name}ì˜ ë„êµ¬ìƒì:")
        for name, tool in self.tools.items():
            print(f"  - {name}: {tool['description']}")

    def use_tool(self, tool_name, *args, **kwargs):
        """ë„êµ¬ ì‚¬ìš©"""
        if tool_name not in self.tools:
            return f"âŒ ë„êµ¬ '{tool_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

        try:
            result = self.tools[tool_name]['function'](*args, **kwargs)
            return f"âœ… {tool_name} ê²°ê³¼: {result}"
        except Exception as e:
            return f"âŒ ì˜¤ë¥˜: {e}"

    def auto_select_tool(self, task):
        """ì‘ì—…ì— ë§ëŠ” ë„êµ¬ ìë™ ì„ íƒ"""
        task_lower = task.lower()

        # ê°„ë‹¨í•œ í‚¤ì›Œë“œ ë§¤ì¹­
        if "ê³„ì‚°" in task_lower or "+" in task_lower or "-" in task_lower:
            return "calculator"
        elif "ë‚ ì”¨" in task_lower:
            return "weather"
        elif "ì‹œê°„" in task_lower or "ëª‡ì‹œ" in task_lower:
            return "clock"
        elif "ì£¼ì‚¬ìœ„" in task_lower or "ëœë¤" in task_lower:
            return "dice"
        else:
            return None

    def process_task(self, task):
        """ì‘ì—… ì²˜ë¦¬"""
        print(f"\nğŸ“‹ ì‘ì—…: {task}")

        # ì ì ˆí•œ ë„êµ¬ ì„ íƒ
        tool = self.auto_select_tool(task)

        if tool:
            print(f"ğŸ¯ ì„ íƒëœ ë„êµ¬: {tool}")

            # ë„êµ¬ë³„ íŒŒë¼ë¯¸í„° ì¶”ì¶œ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•˜ê²Œ)
            if tool == "calculator":
                # ê°„ë‹¨í•œ ê³„ì‚°ì‹ ì¶”ì¶œ
                import re
                numbers = re.findall(r'\d+', task)
                if len(numbers) >= 2:
                    return self.use_tool(tool, int(numbers[0]), int(numbers[1]))
            else:
                return self.use_tool(tool)
        else:
            return "ğŸ¤” ì´ ì‘ì—…ì— ì í•©í•œ ë„êµ¬ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."

# ë„êµ¬ í•¨ìˆ˜ë“¤
def calculator(a, b, operation="+"):
    """ê³„ì‚°ê¸°"""
    ops = {
        "+": a + b,
        "-": a - b,
        "*": a * b,
        "/": a / b if b != 0 else "0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŒ"
    }
    return ops.get(operation, a + b)

def weather_tool():
    """ë‚ ì”¨ ì •ë³´ (ì‹œë®¬ë ˆì´ì…˜)"""
    weathers = ["ë§‘ìŒ â˜€ï¸", "íë¦¼ â˜ï¸", "ë¹„ ğŸŒ§ï¸", "ëˆˆ â„ï¸"]
    temp = random.randint(10, 30)
    return f"{random.choice(weathers)}, {temp}ë„"

def clock_tool():
    """í˜„ì¬ ì‹œê°„"""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def dice_tool(sides=6):
    """ì£¼ì‚¬ìœ„ ë˜ì§€ê¸°"""
    return f"ğŸ² {random.randint(1, sides)}"

# ì—ì´ì „íŠ¸ ìƒì„± ë° ë„êµ¬ ë“±ë¡
agent = ToolAgent("ë˜‘ë˜‘ì´")

agent.register_tool("calculator", calculator, "ìˆ«ì ê³„ì‚°")
agent.register_tool("weather", weather_tool, "ë‚ ì”¨ í™•ì¸")
agent.register_tool("clock", clock_tool, "í˜„ì¬ ì‹œê°„")
agent.register_tool("dice", dice_tool, "ì£¼ì‚¬ìœ„ ë˜ì§€ê¸°")

# ë„êµ¬ ëª©ë¡ í™•ì¸
agent.list_tools()

# ë‹¤ì–‘í•œ ì‘ì—… ì²˜ë¦¬
tasks = [
    "10 + 20 ê³„ì‚°í•´ì¤˜",
    "ì§€ê¸ˆ ëª‡ì‹œì•¼?",
    "ì˜¤ëŠ˜ ë‚ ì”¨ ì–´ë•Œ?",
    "ì£¼ì‚¬ìœ„ ë˜ì ¸ì¤˜",
    "ì´ë©”ì¼ ë³´ë‚´ê¸°"  # ë„êµ¬ ì—†ìŒ
]

for task in tasks:
    result = agent.process_task(task)
    print(f"ê²°ê³¼: {result}\n")

# ë„ì „ ê³¼ì œ:
# 1. ìƒˆë¡œìš´ ë„êµ¬ ì¶”ê°€ (ë²ˆì—­ê¸°, ê²€ìƒ‰ ë“±)
# 2. ì—¬ëŸ¬ ë„êµ¬ë¥¼ ì¡°í•©í•´ì„œ ì‚¬ìš©
# 3. ë„êµ¬ ì‚¬ìš© ê¸°ë¡ ì €ì¥
```

---

## ì‹¤ì „ í”„ë¡œì íŠ¸ - ë‚˜ë§Œì˜ AI ë¹„ì„œ ë§Œë“¤ê¸°

### ğŸš€ í”„ë¡œì íŠ¸: ê°œì¸ ì—…ë¬´ ë„ìš°ë¯¸ ì—ì´ì „íŠ¸

```python
# personal_assistant.py
"""
ì‹¤ì „ í”„ë¡œì íŠ¸: ëª¨ë“  íŒ¨í„´ì„ í™œìš©í•œ ê°œì¸ ë¹„ì„œ
- ì¼ì • ê´€ë¦¬
- ì‘ì—… ìë™í™”
- ì •ë³´ ê²€ìƒ‰
- ë¦¬ë§ˆì¸ë”
"""

import asyncio
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any

class PersonalAssistant:
    def __init__(self, user_name):
        self.user_name = user_name
        self.memory = []  # ëŒ€í™” ê¸°ë¡
        self.tasks = []   # í•  ì¼ ëª©ë¡
        self.schedule = {}  # ì¼ì •
        self.tools = self._initialize_tools()
        self.agents = self._initialize_agents()

    def _initialize_tools(self):
        """ë„êµ¬ ì´ˆê¸°í™”"""
        return {
            'calendar': CalendarTool(),
            'todo': TodoTool(),
            'search': SearchTool(),
            'reminder': ReminderTool(),
            'email': EmailTool()
        }

    def _initialize_agents(self):
        """ì „ë¬¸ ì—ì´ì „íŠ¸ ì´ˆê¸°í™”"""
        return {
            'scheduler': SchedulerAgent(),
            'researcher': ResearchAgent(),
            'writer': WriterAgent(),
            'analyzer': AnalyzerAgent()
        }

    async def process_command(self, command: str):
        """ëª…ë ¹ ì²˜ë¦¬ - ë¼ìš°íŒ… íŒ¨í„´"""

        # 1. ì˜ë„ íŒŒì•…
        intent = self.analyze_intent(command)

        # 2. ì ì ˆí•œ ì²˜ë¦¬ ë°©ë²• ì„ íƒ
        if intent == 'schedule':
            return await self.handle_schedule(command)
        elif intent == 'task':
            return await self.handle_task(command)
        elif intent == 'search':
            return await self.handle_search(command)
        elif intent == 'complex':
            return await self.handle_complex(command)
        else:
            return await self.handle_general(command)

    def analyze_intent(self, command: str) -> str:
        """ì˜ë„ ë¶„ì„"""
        command_lower = command.lower()

        schedule_keywords = ['ì¼ì •', 'ì•½ì†', 'ë¯¸íŒ…', 'íšŒì˜']
        task_keywords = ['í• ì¼', 'ì‘ì—…', 'todo', 'í•´ì•¼']
        search_keywords = ['ê²€ìƒ‰', 'ì°¾ì•„', 'ì•Œë ¤ì¤˜', 'ë­ì•¼']

        if any(k in command_lower for k in schedule_keywords):
            return 'schedule'
        elif any(k in command_lower for k in task_keywords):
            return 'task'
        elif any(k in command_lower for k in search_keywords):
            return 'search'
        elif len(command.split()) > 10:  # ë³µì¡í•œ ìš”ì²­
            return 'complex'
        else:
            return 'general'

    async def handle_complex(self, command: str):
        """ë³µì¡í•œ ì‘ì—… ì²˜ë¦¬ - ë©€í‹° ì—ì´ì „íŠ¸ + ë³‘ë ¬ ì²˜ë¦¬"""

        print("ğŸ¤– ë³µì¡í•œ ì‘ì—… ê°ì§€. íŒ€ êµ¬ì„± ì¤‘...")

        # ì‘ì—… ë¶„í•´ (Planning íŒ¨í„´)
        subtasks = self.decompose_task(command)

        # ë³‘ë ¬ ì²˜ë¦¬ (Parallelization íŒ¨í„´)
        results = await asyncio.gather(*[
            self.process_subtask(subtask)
            for subtask in subtasks
        ])

        # ê²°ê³¼ í†µí•© ë° ê²€ì¦ (Reflection íŒ¨í„´)
        final_result = self.integrate_and_validate(results)

        return final_result

    def decompose_task(self, command: str) -> List[Dict]:
        """ì‘ì—… ë¶„í•´"""
        # ì‹¤ì œë¡œëŠ” AIë¥¼ ì‚¬ìš©í•˜ì—¬ ë” ì •êµí•˜ê²Œ
        subtasks = []

        if "ë³´ê³ ì„œ" in command:
            subtasks = [
                {'type': 'research', 'topic': 'ì£¼ì œ ì¡°ì‚¬'},
                {'type': 'write', 'content': 'ì´ˆì•ˆ ì‘ì„±'},
                {'type': 'review', 'target': 'ê²€í†  ë° ìˆ˜ì •'}
            ]
        elif "ë¶„ì„" in command:
            subtasks = [
                {'type': 'collect', 'data': 'ë°ì´í„° ìˆ˜ì§‘'},
                {'type': 'analyze', 'method': 'ë¶„ì„ ì‹¤í–‰'},
                {'type': 'visualize', 'format': 'ì‹œê°í™”'}
            ]

        return subtasks

    async def process_subtask(self, subtask: Dict):
        """í•˜ìœ„ ì‘ì—… ì²˜ë¦¬"""
        task_type = subtask.get('type')

        if task_type == 'research':
            return await self.agents['researcher'].research(subtask)
        elif task_type == 'write':
            return await self.agents['writer'].write(subtask)
        elif task_type == 'analyze':
            return await self.agents['analyzer'].analyze(subtask)
        else:
            return f"ì²˜ë¦¬ë¨: {subtask}"

    def integrate_and_validate(self, results: List) -> str:
        """ê²°ê³¼ í†µí•© ë° ê²€ì¦"""
        # Reflection íŒ¨í„´ - ê²°ê³¼ ê²€í† 
        integrated = "\n".join(str(r) for r in results)

        # ìê¸° ê²€ì¦
        issues = self.validate_results(integrated)

        if issues:
            # ë¬¸ì œ ë°œê²¬ ì‹œ ê°œì„ 
            integrated = self.improve_results(integrated, issues)

        return f"""
        âœ… ì‘ì—… ì™„ë£Œ!

        {integrated}

        ì²˜ë¦¬ëœ í•˜ìœ„ ì‘ì—…: {len(results)}ê°œ
        """

    def validate_results(self, results: str) -> List[str]:
        """ê²°ê³¼ ê²€ì¦"""
        issues = []

        if len(results) < 50:
            issues.append("ë‚´ìš©ì´ ë„ˆë¬´ ì§§ìŒ")

        # ì¶”ê°€ ê²€ì¦ ë¡œì§...

        return issues

    def improve_results(self, results: str, issues: List[str]) -> str:
        """ê²°ê³¼ ê°œì„ """
        improved = results

        for issue in issues:
            if "ì§§ìŒ" in issue:
                improved += "\n\n[ì¶”ê°€ ë‚´ìš©...]"

        return improved

# ì „ë¬¸ ì—ì´ì „íŠ¸ë“¤
class SchedulerAgent:
    """ì¼ì • ê´€ë¦¬ ì „ë¬¸ ì—ì´ì „íŠ¸"""

    async def schedule(self, task):
        # ì¼ì • ìµœì í™” ë¡œì§
        return f"ì¼ì • ë“±ë¡: {task}"

class ResearchAgent:
    """ì¡°ì‚¬ ì „ë¬¸ ì—ì´ì „íŠ¸"""

    async def research(self, topic):
        # ì‹¤ì œë¡œëŠ” ì›¹ ê²€ìƒ‰, DB ì¡°íšŒ ë“±
        await asyncio.sleep(1)  # ì‹œë®¬ë ˆì´ì…˜
        return f"ì¡°ì‚¬ ì™„ë£Œ: {topic}"

class WriterAgent:
    """ì‘ì„± ì „ë¬¸ ì—ì´ì „íŠ¸"""

    async def write(self, content):
        await asyncio.sleep(1)
        return f"ì‘ì„± ì™„ë£Œ: {content}"

class AnalyzerAgent:
    """ë¶„ì„ ì „ë¬¸ ì—ì´ì „íŠ¸"""

    async def analyze(self, data):
        await asyncio.sleep(1)
        return f"ë¶„ì„ ì™„ë£Œ: {data}"

# ë„êµ¬ë“¤
class CalendarTool:
    def add_event(self, event):
        return f"ğŸ“… ì¼ì • ì¶”ê°€: {event}"

class TodoTool:
    def add_task(self, task):
        return f"âœ… í• ì¼ ì¶”ê°€: {task}"

class SearchTool:
    def search(self, query):
        return f"ğŸ” ê²€ìƒ‰ ê²°ê³¼: {query}"

class ReminderTool:
    def set_reminder(self, reminder):
        return f"â° ë¦¬ë§ˆì¸ë” ì„¤ì •: {reminder}"

class EmailTool:
    def send(self, email):
        return f"ğŸ“§ ì´ë©”ì¼ ì „ì†¡: {email}"

# ì‹¤ì œ ì‚¬ìš©
async def main():
    # ë¹„ì„œ ìƒì„±
    assistant = PersonalAssistant("ì‚¬ìš©ì")

    # ë‹¤ì–‘í•œ ëª…ë ¹ ì²˜ë¦¬
    commands = [
        "ë‚´ì¼ ì˜¤í›„ 2ì‹œì— íšŒì˜ ì¼ì • ì¡ì•„ì¤˜",
        "Python ê³µë¶€í•˜ê¸°ë¥¼ í• ì¼ ëª©ë¡ì— ì¶”ê°€í•´",
        "AI ì—ì´ì „íŠ¸ì— ëŒ€í•´ ê²€ìƒ‰í•´ì¤˜",
        "ë‹¤ìŒ ì£¼ í”„ë¡œì íŠ¸ ì§„í–‰ ìƒí™© ë³´ê³ ì„œë¥¼ ì‘ì„±í•˜ê³  íŒ€ì›ë“¤ì—ê²Œ ì´ë©”ì¼ë¡œ ë³´ë‚´ì¤˜"
    ]

    for cmd in commands:
        print(f"\nğŸ‘¤ ì‚¬ìš©ì: {cmd}")
        result = await assistant.process_command(cmd)
        print(f"ğŸ¤– ë¹„ì„œ: {result}")

# ì‹¤í–‰
if __name__ == "__main__":
    asyncio.run(main())
```

---

## ìš©ì–´ ì‚¬ì „ - ì–´ë ¤ìš´ ë§ ì‰½ê²Œ ì´í•´í•˜ê¸°

### ğŸ“š í•µì‹¬ ìš©ì–´ ì„¤ëª…

| ìš©ì–´ | ì–´ë ¤ìš´ ì„¤ëª… | ì‰¬ìš´ ì„¤ëª… | ë¹„ìœ  |
|------|------------|----------|------|
| **Agent (ì—ì´ì „íŠ¸)** | ììœ¨ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” AI ì‹œìŠ¤í…œ | ìŠ¤ìŠ¤ë¡œ íŒë‹¨í•˜ê³  í–‰ë™í•˜ëŠ” AI | ğŸ¤– ë¡œë´‡ ë¹„ì„œ |
| **LLM** | Large Language Model | ë§ì´ í•™ìŠµí•œ AI ì–¸ì–´ ëª¨ë¸ | ğŸ“š ë°±ê³¼ì‚¬ì „ì„ ë‹¤ ì™¸ìš´ ì¹œêµ¬ |
| **Prompt** | AIì—ê²Œ ì£¼ëŠ” ëª…ë ¹ì´ë‚˜ ì§ˆë¬¸ | AIì™€ ëŒ€í™”í•˜ëŠ” ë°©ë²• | ğŸ’¬ ë§ ê±¸ê¸° |
| **Chain** | ìˆœì°¨ì  ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ | ì‘ì—…ì„ ìˆœì„œëŒ€ë¡œ ì—°ê²° | ğŸ”— ë„ë¯¸ë…¸ |
| **Routing** | ì¡°ê±´ë¶€ ë¶„ê¸° ì²˜ë¦¬ | ìƒí™©ì— ë”°ë¼ ë‹¤ë¥¸ ê¸¸ ì„ íƒ | ğŸš¦ êµí†µ ì‹ í˜¸ |
| **Parallelization** | ë³‘ë ¬ ì²˜ë¦¬ | ì—¬ëŸ¬ ì¼ì„ ë™ì‹œì— | ğŸ¯ ë©€í‹°íƒœìŠ¤í‚¹ |
| **Reflection** | ìê¸° ê²€í†  ë° ê°œì„  | ìŠ¤ìŠ¤ë¡œ í™•ì¸í•˜ê³  ê³ ì¹˜ê¸° | ğŸª ê±°ìš¸ ë³´ê¸° |
| **Tool Use** | ë„êµ¬ í™œìš© | í•„ìš”í•œ ë„êµ¬ ì°¾ì•„ ì“°ê¸° | ğŸ§° ê³µêµ¬ìƒì |
| **Planning** | ê³„íš ìˆ˜ë¦½ | ë¯¸ë¦¬ ê³„íš ì„¸ìš°ê¸° | ğŸ“‹ ì—¬í–‰ ì¼ì •í‘œ |
| **Multi-Agent** | ë‹¤ì¤‘ ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ | ì—¬ëŸ¬ AIê°€ í˜‘ë ¥ | ğŸ‘¥ íŒ€ì›Œí¬ |
| **Context** | ë§¥ë½, ë¬¸ë§¥ | ëŒ€í™”ì˜ íë¦„ê³¼ ìƒí™© | ğŸ“– ì´ì•¼ê¸° ë°°ê²½ |
| **Token** | í…ìŠ¤íŠ¸ ì²˜ë¦¬ ë‹¨ìœ„ | AIê°€ ì´í•´í•˜ëŠ” ê¸€ì ì¡°ê° | ğŸ§© í¼ì¦ ì¡°ê° |
| **Embedding** | ë²¡í„° ë³€í™˜ | ê¸€ì„ ìˆ«ìë¡œ ë°”ê¾¸ê¸° | ğŸ”¢ ì•”í˜¸í™” |
| **Fine-tuning** | ëª¨ë¸ ë¯¸ì„¸ ì¡°ì • | AIë¥¼ íŠ¹ë³„íˆ í›ˆë ¨ì‹œí‚¤ê¸° | ğŸ¯ ë§ì¶¤ êµìœ¡ |
| **API** | Application Programming Interface | í”„ë¡œê·¸ë¨ë¼ë¦¬ ëŒ€í™”í•˜ëŠ” ë°©ë²• | ğŸ“ ì „í™”ë²ˆí˜¸ |
| **Async/Await** | ë¹„ë™ê¸° ì²˜ë¦¬ | ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ë‹¤ë¥¸ ì¼ í•˜ê¸° | â±ï¸ ìš”ë¦¬í•˜ë©° ë¹¨ë˜ |
| **Exception** | ì˜ˆì™¸, ì˜¤ë¥˜ | ë­”ê°€ ì˜ëª»ëì„ ë•Œ | âš ï¸ ê²½ê³ ë“± |
| **Recursion** | ì¬ê·€ | ìê¸° ìì‹ ì„ ë‹¤ì‹œ ë¶€ë¥´ê¸° | ğŸ”„ ë§ˆíŠ¸ë£Œì‹œì¹´ ì¸í˜• |
| **Orchestration** | ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ | ì—¬ëŸ¬ ìš”ì†Œë¥¼ ì¡°í™”ë¡­ê²Œ ê´€ë¦¬ | ğŸ¼ ì§€íœ˜ì |
| **Pipeline** | íŒŒì´í”„ë¼ì¸ | ë°ì´í„°ê°€ íë¥´ëŠ” í†µë¡œ | ğŸš° ìˆ˜ë„ê´€ |
| **Fallback** | ëŒ€ì²´ ë°©ì•ˆ | ì‹¤íŒ¨í–ˆì„ ë•Œ í”Œëœ B | ğŸª‚ ì˜ˆë¹„ ë‚™í•˜ì‚° |

### ğŸ’¡ ìì£¼ ë‚˜ì˜¤ëŠ” ì½”ë“œ íŒ¨í„´ ì„¤ëª…

```python
# 1. async/await - ë¹„ë™ê¸° ì²˜ë¦¬
async def í•¨ìˆ˜():
    ê²°ê³¼ = await ì˜¤ë˜ê±¸ë¦¬ëŠ”ì‘ì—…()
    # "ì˜¤ë˜ê±¸ë¦¬ëŠ”ì‘ì—… ëë‚  ë•Œê¹Œì§€ ë‹¤ë¥¸ ì¼ í•˜ë‹¤ê°€ ì™€"

# 2. try/except - ì˜¤ë¥˜ ì²˜ë¦¬
try:
    ìœ„í—˜í•œ_ì‘ì—…()
except:
    ì•ˆì „í•œ_ëŒ€ì•ˆ()
    # "í˜¹ì‹œ ì‹¤íŒ¨í•˜ë©´ ì´ë ‡ê²Œ í•´"

# 3. List Comprehension - ë¦¬ìŠ¤íŠ¸ ê°„ë‹¨íˆ ë§Œë“¤ê¸°
numbers = [x*2 for x in range(10)]
# "0ë¶€í„° 9ê¹Œì§€ ê°ê° 2ë°° í•´ì„œ ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ì–´"

# 4. Lambda - ê°„ë‹¨í•œ í•¨ìˆ˜
add = lambda x, y: x + y
# "ì´ë¦„ ì—†ëŠ” ì‘ì€ í•¨ìˆ˜"

# 5. *args, **kwargs - ìœ ì—°í•œ ë§¤ê°œë³€ìˆ˜
def í•¨ìˆ˜(*args, **kwargs):
    # args: ê°œìˆ˜ ëª¨ë¥¼ ë•Œ
    # kwargs: ì´ë¦„ ìˆëŠ” ê²ƒ ë°›ì„ ë•Œ
```

---

## ë” ë‚˜ì•„ê°€ê¸° - ì„±ì¥ ë¡œë“œë§µ

### ğŸ—ºï¸ í•™ìŠµ ê²½ë¡œ

#### ğŸ“ 1ë‹¨ê³„: ê¸°ì´ˆ ë‹¤ì§€ê¸° (1-2ê°œì›”)
- [ ] Python ê¸°ë³¸ ë¬¸ë²•
- [ ] í•¨ìˆ˜ì™€ í´ë˜ìŠ¤ ì´í•´
- [ ] ê¸°ë³¸ ë°ì´í„° êµ¬ì¡°
- [ ] íŒŒì¼ ì…ì¶œë ¥

#### ğŸ“ 2ë‹¨ê³„: AI ê¸°ì´ˆ (2-3ê°œì›”)
- [ ] API ì‚¬ìš©ë²• (OpenAI, Claude)
- [ ] í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§
- [ ] ê°„ë‹¨í•œ ì±—ë´‡ ë§Œë“¤ê¸°
- [ ] ê¸°ë³¸ íŒ¨í„´ 1-2ê°œ êµ¬í˜„

#### ğŸ“ 3ë‹¨ê³„: ì—ì´ì „íŠ¸ ê°œë°œ (3-4ê°œì›”)
- [ ] ëª¨ë“  íŒ¨í„´ ì‹¤ìŠµ
- [ ] ì‹¤ì œ í”„ë¡œì íŠ¸ êµ¬í˜„
- [ ] ì˜¤ë¥˜ ì²˜ë¦¬ ë° ìµœì í™”
- [ ] ë°°í¬ ë° ìš´ì˜

#### ğŸ“ 4ë‹¨ê³„: ê³ ê¸‰ ê¸°ìˆ  (ì§€ì†ì )
- [ ] ë³µì¡í•œ ë©€í‹° ì—ì´ì „íŠ¸
- [ ] ì‹¤ì‹œê°„ ì²˜ë¦¬
- [ ] ëŒ€ê·œëª¨ ì‹œìŠ¤í…œ
- [ ] ì˜¤í”ˆì†ŒìŠ¤ ê¸°ì—¬

### ğŸ“š ì¶”ì²œ í•™ìŠµ ìë£Œ

#### ì˜¨ë¼ì¸ ê°•ì˜
- ğŸ“ **Coursera**: "AI For Everyone" - Andrew Ng
- ğŸ“ **Fast.ai**: ì‹¤ìš©ì ì¸ ë”¥ëŸ¬ë‹
- ğŸ“ **ìœ íŠœë¸Œ**: "Two Minute Papers" - AI ìµœì‹  ë™í–¥

#### ì±…
- ğŸ“– **ì…ë¬¸**: "ì í”„ íˆ¬ íŒŒì´ì¬"
- ğŸ“– **ì¤‘ê¸‰**: "Hands-On Machine Learning"
- ğŸ“– **ê³ ê¸‰**: "Designing Data-Intensive Applications"

#### ì‹¤ìŠµ í™˜ê²½
- ğŸ’» **Google Colab**: ë¬´ë£Œ í´ë¼ìš°ë“œ í™˜ê²½
- ğŸ’» **Replit**: ì˜¨ë¼ì¸ ì½”ë”© í™˜ê²½
- ğŸ’» **GitHub**: ì½”ë“œ ê³µìœ  ë° í˜‘ì—…

### ğŸ¯ í”„ë¡œì íŠ¸ ì•„ì´ë””ì–´

#### ì´ˆê¸‰ í”„ë¡œì íŠ¸
1. **ì¼ê¸° ì‘ì„± ë„ìš°ë¯¸**: ë§¤ì¼ ì§ˆë¬¸í•˜ê³  ì¼ê¸° ì‘ì„± ë„ì›€
2. **ë ˆì‹œí”¼ ì¶”ì²œë´‡**: ì¬ë£Œ ì…ë ¥í•˜ë©´ ìš”ë¦¬ ì¶”ì²œ
3. **ê³µë¶€ ë„ìš°ë¯¸**: ë¬¸ì œ ë‚´ê³  ì„¤ëª…í•´ì£¼ëŠ” ì„ ìƒë‹˜ ë´‡

#### ì¤‘ê¸‰ í”„ë¡œì íŠ¸
1. **ê°œì¸ ë¹„ì„œ**: ì¼ì •, ë©”ëª¨, ë¦¬ë§ˆì¸ë” í†µí•© ê´€ë¦¬
2. **ë‰´ìŠ¤ ìš”ì•½ë´‡**: ë§¤ì¼ ë‰´ìŠ¤ ìˆ˜ì§‘í•˜ê³  ìš”ì•½
3. **ì½”ë“œ ë¦¬ë·°ì–´**: ì½”ë“œ ë¶„ì„í•˜ê³  ê°œì„ ì  ì œì•ˆ

#### ê³ ê¸‰ í”„ë¡œì íŠ¸
1. **íŒ€ í˜‘ì—… ì‹œìŠ¤í…œ**: ì—¬ëŸ¬ ì—ì´ì „íŠ¸ê°€ í”„ë¡œì íŠ¸ ê´€ë¦¬
2. **ìë™ ê±°ë˜ ì‹œìŠ¤í…œ**: ì‹œì¥ ë¶„ì„ ë° ìë™ ê±°ë˜
3. **êµìœ¡ í”Œë«í¼**: ê°œì¸ ë§ì¶¤í˜• í•™ìŠµ ê²½ë¡œ ìƒì„±

---

## ë§ˆë¬´ë¦¬ - ë‹¹ì‹ ë„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

### ğŸŒŸ ê¸°ì–µí•´ì•¼ í•  í•µì‹¬

1. **ì‘ê²Œ ì‹œì‘í•˜ê¸°**: ì™„ë²½í•œ ì‹œìŠ¤í…œë³´ë‹¤ ì‘ë™í•˜ëŠ” í”„ë¡œí† íƒ€ì…
2. **ì‹¤íŒ¨ëŠ” í•™ìŠµ**: ì˜¤ë¥˜ëŠ” ì„±ì¥ì˜ ê¸°íšŒ
3. **ê³µìœ í•˜ê³  ë°°ìš°ê¸°**: ì»¤ë®¤ë‹ˆí‹° ì°¸ì—¬
4. **ê¾¸ì¤€í•œ ì‹¤ìŠµ**: ë§¤ì¼ ì¡°ê¸ˆì”©

### ğŸ’¬ ê²©ë ¤ì˜ ë§

> "ëª¨ë“  ì „ë¬¸ê°€ë„ í•œë•ŒëŠ” ì´ˆë³´ìì˜€ìŠµë‹ˆë‹¤.
> ì¤‘ìš”í•œ ê²ƒì€ ì‹œì‘í•˜ëŠ” ìš©ê¸°ì™€ ê³„ì†í•˜ëŠ” ëˆê¸°ì…ë‹ˆë‹¤.
> ë‹¹ì‹ ì˜ ì²« AI ì—ì´ì „íŠ¸ê°€ 'Hello World'ë¥¼ ì¶œë ¥í•˜ëŠ” ìˆœê°„,
> ë‹¹ì‹ ì€ ì´ë¯¸ AI ê°œë°œìì…ë‹ˆë‹¤!"

### ğŸ¤ ë‹¤ìŒ ë‹¨ê³„

1. ì´ ë…¸íŠ¸ì˜ ì½”ë“œë¥¼ í•˜ë‚˜ì”© ì‹¤í–‰í•´ë³´ì„¸ìš”
2. ì‘ì€ ë¶€ë¶„ì„ ìˆ˜ì •í•´ë³´ì„¸ìš”
3. ìì‹ ë§Œì˜ ì•„ì´ë””ì–´ë¥¼ ì¶”ê°€í•´ë³´ì„¸ìš”
4. ë§Œë“  ê²ƒì„ ê³µìœ í•˜ê³  í”¼ë“œë°± ë°›ìœ¼ì„¸ìš”

**í–‰ìš´ì„ ë¹•ë‹ˆë‹¤! ğŸš€**

---

## ì—°ê²°ëœ ë…¸íŠ¸
- [[AI ì—ì´ì „íŠ¸ ê°œë°œ ì‹¤ì „ ê°€ì´ë“œ]]
- [[í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ë§ˆìŠ¤í„° í´ë˜ìŠ¤]]
- [[Python í”„ë¡œê·¸ë˜ë° ê¸°ì´ˆ]]
- [[LLM API í™œìš©ë²•]]
- [[ë©€í‹° ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ ì„¤ê³„]]
- [[ì‹¤ì „ í”„ë¡œì íŠ¸ ëª¨ìŒ]]

## ì°¸ê³  ìë£Œ
- ì›ë³¸: "Agentic Design Patterns" by Antonio Gulli
- OpenAI Documentation
- LangChain Framework
- AutoGen Microsoft
- Claude API Documentation

---

*ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2025-10-11*
*ì‘ì„±ì: Claude AI Assistant*
*ê²€í†  ë° í”¼ë“œë°± í™˜ì˜: [GitHub Issues]*
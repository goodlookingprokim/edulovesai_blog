---
title: "Claude Code: 생산성 향상의 핵심"
date: 2025-06-15
created: '2026-01-27'
last_modified: '2026-01-27'
status: "published"
slug: "claude-code-everything-you-need-to-know-원문"
category: "claude-code"
excerpt: "[→ Open in Slid](https://app.slid.cc/docs/6f382865aff5499cb5928103dd7df266) ..."
tags:
  - claude-code
  - ai-coding
reading_time: 63
journalist: "tech-expert"
priority: "medium"
type: "guide"
---

[→ Open in Slid](https://app.slid.cc/docs/6f382865aff5499cb5928103dd7df266)


---

# Claude Code: 생산성 향상의 핵심

## Claude Code 소개

- Claude Code는 Cursor 출시 이후 가장 큰 생산성 향상을 가져다줌.

- 많은 사용자가 Claude Code의 강력함을 아직 인지하지 못하고 있음.

## 숨겨진 명령어: `Claude -- resume`

- 터미널에서 `Claude -- resume` 명령어를 입력하여 이전 채널 채팅을 볼 수 있음.

- 이 명령어는 공식 문서에 없으며 매우 비밀스러운 기능임.

## 명령어의 특징

- `/resume` 슬래시 명령어로 사용할 수 없음.

- 명령어에 대한 기록이나 정보가 존재하지 않음.

- Reddit에서 개발자가 발견함.

# Claude 사용 팁

## 이전 채팅 기록 확인

- `Claude -- resume` 명령어를 터미널에 입력

- 이전 채팅, 메시지 수 확인 가능

- Cursor를 실수로 닫았을 때 유용함

- 공식 문서에 없는 숨겨진 기능임

## Claude 버전 다운그레이드

- Claude 1.0.17 버전으로 다운그레이드 권장

- 최신 버전의 팝업 박스 때문임

## Cloud Code 버전 다운그레이드

- 최신 버전의 Cloud Code에는 계획 모드에서 작업 시작을 제안하는 팝업 박스가 나타남.

  - 이 팝업은 문제에 대한 명확성이 확보될 때까지 대화를 유지하려는 경우에 방해가 될 수 있음.

- **해결 방법**:

  - Cloud Code를 1.0.17 버전으로 다운그레이드하면 이 팝업을 피할 수 있음.

## Shift + Tab 단축키

- Shift + Tab 키를 누르면 작업을 시작할 수 있음.

  - 문제에 대한 이해가 완전히 끝난 후에 이 단축키를 사용하면 편리함.

# Cloud Code 자동 업데이트 비활성화

- Cloud Code가 자동으로 업데이트되는 것을 막아야 함.

  - `cloud config set dash g auto update status disabled` 명령어를 사용해서 자동 업데이트를 비활성화해야 함.

- 버전 확인

  - `/status` 명령어를 실행해서 버전이 `1.0.17`인지 확인해야 함. 이 버전이 현재 최고임.

# 생산성 극대화를 위한 팁

- 이전 팁들이 어디에서도 볼 수 없는 유용한 정보임.

- 생산성 향상을 위해 제시된 방법들을 활용해야 함.

# 로컬 서버 작업 소개

- 로컬 호스트 서버에서 진행할 작업이 있음.

- 새로운 기능 개선 및 버그 수정이 주요 목표임.

# 기능 개선 목표

- MVP(Minimum Viable Product)로 개발된 새로운 기능을 개선하는 데 집중함.

- 개발자에게 감사를 표하며, 버그를 수정하고 기능을 다듬을 예정임.

# 품질 향상 (Quality of Life)

- **쉬운 마감일 변경**: 마감일에 마우스를 올려서 쉽게 날짜를 변경할 수 있음. 예를 들어, 내일로 변경하거나 다시 오늘로 변경하는 것이 매우 편리함.

- **프로젝트 연결 시 제한 사항**: 프로젝트가 연결된 경우에는 마감일 변경 기능이 작동하지 않음. 예를 들어, "개인" 프로젝트인 경우에만 가능함.

# 향후 개선 사항

- **버그 수정**: 버그를 수정할 예정임.

- **UI 개선**: 사용자 인터페이스(UI)를 개선할 예정임.

- **리팩토링**: 코드 리팩토링을 진행할 예정임.

- **인증 방식 변경**: 인증 방식을 변경할 수도 있음.

# 프롬프트 엔지니어링

- **AI 에이전트 프롬프트 능력**: AI 에이전트에게 프롬프트를 제공하는 능력, 즉 프롬프트 엔지니어링에 매우 뛰어남.

# 오늘의 집중 목표

- 매일 명확한 목표 설정이 중요함.

## 프롬프트 엔지니어링 접근 방식

- 프롬프트를 정리하고 조사하는 방법에 대한 접근 방식을 보여줄 예정임.

## 앱 개발 시 맥락의 중요성

- 대부분의 앱은 맥락과 관련된 정보를 수집하지 못함.

## 완전 자율 AI의 한계

- 완전 자율 AI는 현재 AI 모델의 한계로 인해 실수할 가능성이 높음.

- 생산성 측면에서 다른 앱들과 유사한 문제점을 가질 수 있음.

# 인간 중심 루프 (Human-in-the-Loop)

## 기능 부족 앱 vs. 사용자 중심 앱

- 대부분의 앱은 기능이 부족하거나, 사용자에만 초점을 맞춤.

- **인간 중심 루프**가 가장 이상적인 접근 방식임.

  - AI가 모든 것을 자동으로 처리하는 것은 현재 모델의 한계로 인해 적합하지 않음.

## 의사 결정 시 현재 목표와 주요 과제 고려

- 오늘 무엇에 집중할지 결정할 때, 다음 사항을 고려해야 함.

  - 현재 목표 (업데이트 가능)

  - 최우선 과제 목록

- 이 두 가지가 의사 결정에 필요한 가장 중요한 정보임.

# 클라우드 코드 마스터리 워크숍

- 클라우드 코드를 심도 있게 배우고 싶다면, **클라우드 코드 마스터리** 워크숍을 참고하면 됨.

- New Society 강의실에서 워크숍을 찾을 수 있음.

# New Society 혜택

- 클라우드 코드를 활용한 코딩 생산성 향상에 대한 세부적인 내용 제공함.

  - 코딩 생산성을 3배 향상시킬 수 있다고 함 (보수적인 추정일 수 있음).

- Cursor 출시 이후 가장 큰 생산성 향상을 가져다줌.

## 독점 콘텐츠

- AI 에이전트 구축 방법 제공함.

- 프롬프트 템플릿 및 프리셋 제공함.

  - 프롬프트를 복사 및 붙여넣기하여 활용 가능함.

# Cloud Code의 장점

- IDE 내에서 작업이 가능함.

  - 이는 생산성 향상에 크게 기여함.

# 비동기적 에이전트의 단점

- 집중력 저하를 유발함.

  - Cursor background agent, OpenAI Codex, ChatGPT Codex 등이 해당됨.

- 멀티태스킹을 유도함.

  - 이는 작업 효율성을 떨어뜨릴 수 있음.

# Cloud Code의 장점

- **IDE 통합**: Cloud Code는 IDE 내에서 작동하여 현재 작업에 더 빠르게 집중할 수 있도록 도와줌.

  - Cursor와 같은 IDE에 내장되어 개발 흐름을 방해하지 않음.

  - 외부 도구로 전환할 필요 없이 코드 작성에만 집중 가능.

- **집중력 향상**: Cloud Code는 개발자의 집중력을 높여 생산성을 향상시킴.

  - 비동기적인 다른 AI 도구와 달리, 현재 작업에 집중하도록 유도.

# AI 제안 기능

- **Vectal Agent**: AI 에이전트가 현재 목표, 최우선 작업, 사용자 맥락을 분석하여 작업 제안.

  - 사용자에게 가장 중요한 작업이 무엇인지 알려줌.

  - 예시: "오늘의 Focus 기능 UI 개선"과 같이 구체적인 작업 제시.

  - 제품 품질 향상 및 수익 증대에 직접적인 도움을 줌.

# 일일 우선순위 및 콘텐츠 제작

## 일일 목표 설정

- 매일 주요 목표를 설정하는 것이 중요함.

- 오늘은 Cloud Code 사용법에 대한 비디오를 제작하는 것을 목표로 함.

## 가치 중심 콘텐츠

- 최소 3시간 분량의 가치 있는 콘텐츠를 제작해야 함.

- 초보자보다는 AI 에이전트 구축, AI 스타트업에 관심 있는 사람들을 대상으로 함.

## 목표 청중

- AI 에이전트 구축, AI 스타트업, 콘텐츠 극대화에 관심 있는 사람들을 타겟으로 함.

# 목표 편집 UI 개선

- 목표 편집 UI를 개선할 예정임.

  - 불필요한 버튼들을 제거할 것임.

  - 버튼 텍스트를 "Update"로 변경할 것임.

# 작업 효율을 위한 환경 설정

- 작업 효율을 높이기 위해 다음과 같은 환경 설정을 수행할 것임.

  - 현재 작업과 관련 없는 탭들을 닫을 것임.

  - 작업에 필요한 파일(예: `daily focus model`)을 열 것임.

# 코드 베이스 이해의 중요성

- **코드 구조에 대한 이해**: AI 도구를 사용하더라도 코드 베이스의 구조를 파악하는 것이 중요함.

  - AI에 모든 것을 맡기는 것은 지양해야 함. 특히 코드 구조 결정에 있어서는 더욱 그러함.

  - 코드에 대한 이해 부족은 "나쁜 바이브 코더"로 이어질 수 있음.

- **AI에 대한 맹목적인 의존성 경계**: AI는 도구일 뿐이며, 개발자가 코드와 시스템을 이해하는 것을 대체할 수 없음.

- **다른 개발자의 코드 또는 오픈 소스 프로젝트 작업 시 고려사항**:

  - 다른 사람이 구현한 기능이나 오픈 소스 프로젝트에 참여할 때는 코드 베이스를 이해하는 것이 특히 중요함.

# Claude의 Plan Mode 활용

- 문제 해결 시 Claude의 **Plan Mode**를 사용하면 매우 빠른 답변을 얻을 수 있음.

- 빠른 속도 덕분에 작업에 필요한 파일 정보를 즉시 파악 가능함.

# UI 업데이트 시 Local Server와 Cloud Code 사용

- UI를 업데이트할 때는 **Local Server**와 **Cloud Code**를 함께 활용하는 것이 효율적임.

- Local Server를 통해 즉각적인 변경 사항을 확인하고 Cloud Code로 통합 관리함.

# ChatGPT O3의 한계

- ChatGPT O3는 응답 시간이 **5분에서 20분**까지 소요될 수 있어 UI를 빠르게 수정하는 데는 적합하지 않음.

- ChatGPT O3는 심각한 버그 해결이나 대규모 리팩토링과 같이 시간이 오래 걸리는 작업에 사용하는 것이 좋음.

# Cloud Code의 생산성 이점

- **O3 대비 Cloud Code의 장점**

  - O3는 생산성이 낮아 사용하지 않음.

  - Cloud Code는 생산성 극대화 및 빌드 속도 향상에 도움을 줌.

  - Cloud Code는 UI를 빠르게 수정할 수 있게 해줌.

- **UI 업데이트 작업**

  - 현재 목표 UI 업데이트를 시작함.

  - 편집 버튼 변경을 우선적으로 진행함.

## UI 개선 작업

- **"Update" 텍스트 버튼 적용**:

  - 기존 아이콘 대신 "Update" 텍스트를 사용해서 클릭을 유도함.

- **아이콘 변경**:

  - Lucid Icons에서 새로운 아이콘을 선택하고 적용함.

- **편집 시 전체 화면 필요**:

  - 편집 모드에서 입력 필드가 전체 화면으로 확장되도록 UI를 개선할 예정임.

# UI 업데이트 계획

## 버튼 제거 및 기능 변경

- 목표 편집 시 불필요한 버튼 두 개 제거함.

  - 텍스트 입력 필드 외부 클릭 시 **취소** 기능 수행.

  - 우측 상단 체크 마크 버튼은 **저장** 기능으로 사용.

- UI 공간 확보 및 직관성 향상 목표임.

## 스크롤바 변경

- 기본 스크롤바 대신 커스텀 스크롤바 적용 예정임.

  - UI 일관성 및 시각적 만족도 향상 목표임.

# UI/UX 중요성 강조

- UI/UX는 매우 중요한 요소임.

  - 사용자 경험에 직접적인 영향을 미치기 때문임.

# UI/UX 중요성

## UI/UX의 중요성에 대한 강조

- UI/UX는 매우 중요함.

- Y Combinator도 UI/UX의 중요성을 인식하고 있음.

## Y Combinator의 UI/UX에 대한 인식

- Y Combinator는 UI/UX 디자인 능력을 갖춘 창업자를 찾고 있음.

## 사용자 경험에 있어서 UI의 역할

- ChatGPT의 성공 요인은 부드러운 UI임.

- 좋은 UI는 사용자 만족도를 높임.

# UI/UX 중요성

- UI/UX는 매우 중요한 요소임. 사용자 경험에 큰 영향을 미침.

# UI 업데이트 구현

- 텍스트 입력 필드 외부를 클릭하면 변경 사항이 저장되도록 구현함.

  - 사용자 편의성을 높이는 방법임.

# GitHub 푸시의 중요성

- GitHub에 자주 푸시하는 것이 중요함.

  - 코드 변경 사항을 꾸준히 백업하고 공유해야 함.

# LLM을 이용한 GitHub 푸시 자동화 프로토콜

- LLM을 사용하여 GitHub 푸시를 자동화하는 프로토콜이 존재함.

  - 일관성 있는 푸시를 위해 필요함.

# Git 커밋의 중요성

- **버전 관리**: Git의 핵심은 버전 관리임.

  - 하루에 두 번 커밋하는 것은 매우 부족함.

  - 의미 있는 변경 후에는 반드시 커밋해야 함.

  - 변경 사항을 되돌릴 수 있기 때문임.

- **커밋 빈도**:

  - 15-20분마다 커밋하는 것이 이상적임.

  - 커밋하지 않으면 불편함을 느껴야 함.

- **의미 있는 변경**:

  - 아이콘 변경, 버튼 제거, 기능 개선 등

  - 이러한 변경 후에 커밋하는 것이 좋음.

# GitHub 커밋 자동화

- LLM을 사용해서 Git 작업을 자동화할 수 있음.

  - 파일을 태깅하면 LLM이 pull, stage, commit을 알아서 수행함.

- AI를 이용해서 상세한 커밋 메시지를 작성하는 것이 중요함.

  - 직접 작성하는 것보다 시간을 절약하고 더 명확한 메시지를 만들 수 있음.

- 커밋 메시지를 대충 작성하면 안 됨.

  - AI는 어떤 작업을 하고 있는지 정확히 파악하고 있기 때문에 좋은 커밋 메시지를 작성할 수 있음.

# UI 개선

## 커스텀 스크롤바 적용

- 목표: 현재 목표 편집 시 기본 스크롤바 대신 커스텀 스크롤바를 사용함.

- 방법: `global CSS` 파일에서 스크롤바 스타일을 정의함.

- 이유: 기본 스크롤바의 흰색 배경이 UI를 해치기 때문임.

## 읽기 라인 수 제한

- 문제점: AI가 파일을 읽을 때 20줄만 읽는 제한이 있음.

- 목표: 파일 전체를 읽도록 라인 수 제한을 늘려야 함.

# UI 개선: Current Goals 텍스트 영역 확장

- 목표: 편집 모드에서 Current Goals 텍스트 영역을 사용 가능한 전체 너비와 높이로 확장해야 함.

  - 현재 텍스트 영역 아래에 불필요한 빈 공간이 많음.

  - 텍스트 영역이 더 크게 확장되도록 수정해야 함.

- 고려 사항:

  - 텍스트 영역의 높이 제한이 있을 수 있음.

  - 메인 텍스트 입력 필드에 확장 버튼 추가를 고려할 수 있음.

  - 텍스트 영역이 공간을 채우도록 구조를 업데이트해야 함.

# UI 개선

## 텍스트 영역 높이 제한 문제 해결

- 마진이나 패딩 문제가 아니라 높이가 제한되어 있었음.

- Cloud Code로 쉽게 수정 가능함.

## 즉각적인 테스트의 중요성

- 변경 사항 적용 후 즉시 테스트해야 함.

- 시니어 개발자와 "바이브 코더"의 차이점 중 하나는 테스트 빈도임.

## UI 개선 반복

- 개선 후에도 추가적인 개선 여지 검토.

- 여백 공간을 줄여 더 나은 UI를 만들 수 있는지 고민해야 함.

# UI 공간 최적화

## 편집 모드에서 텍스트 입력 필드 크기 조정

- 편집 모드에서 텍스트 필드 위의 공간을 활용해야 함.

- 목표: 텍스트 입력 필드를 약간 더 크게 만들기.

- 다른 UI 요소는 변경하지 않아야 함.

## 명확한 프롬프트의 중요성

- 프롬프트가 명확하지 않으면 원하는 "바이브 코딩" 결과를 얻기 어려움.

- 프롬프트 작성 시 명확성을 유지하는 것이 중요함.

# Vibe Learning

- Vibe learning은 코딩하면서 배우는 것을 의미함.

- 이해도를 높여서 더 나은 프롬프트를 작성할 수 있도록 도와줌.

- 즉흥적인 코딩을 통해 배우는 방식임.

# 프롬프트 엔지니어링

- AI가 이해할 수 있도록 명확하고 간결한 프롬프트를 작성하는 것이 중요함.

- 복잡하고 긴 프롬프트는 AI가 이해하기 어려울 수 있음.

- 간단하고 짧게 작성해야 함.

# UI 개선 및 개발 환경 배포

## UI 개선 사항 요약

- 목표 입력 및 스크롤바 기능 향상됨.

- 여러 목표 추가 가능해짐.

## 개발 환경으로 푸시

- 개선 사항을 개발 서버에 배포함.

## 컴팩트 기능 소개

- 컴팩트 기능 데모 예정임.

## AI 에이전트의 미래

- 향후 6~18개월 내에 AI 에이전트가 모든 것을 할 수 있게 될 것임.

- AI 사용 능력의 보편화 예상됨.

# AI 에이전트 시대의 차별화 요소

- 앞으로 AI 에이전트 접근성은 높아질 것임.

  - 중요한 것은 AI를 얼마나 잘 활용하고, UI/UX를 얼마나 잘 판단하는가임.

  - 결국, **학습**을 통해 이러한 능력을 키우는 것이 핵심임.

- 명확하고 효과적인 프롬프트 작성 능력 또한 중요함.

  - 이는 결국 **끊임없는 학습**을 통해 얻을 수 있음.

# Vibe Coding 시 학습의 중요성

- AI가 작업을 수행하는 동안 딴짓하지 말고 **계속 학습**해야 함.

  - 파일에 대해 질문하고 코드 베이스를 더 잘 이해해야 함.

  - 이해가 안 되는 부분을 AI에게 설명하도록 요청해야 함.

- Vibe Coder들이 흔히 저지르는 실수: AI가 코딩하는 동안 아무것도 안 함.

# 데이터 포커스 모델 상세 정보

- 크기: 690 바이트

- 가시성: `is open`이 참일 때만 보임.

- 데이터 흐름:

  - API Redux로부터 focus, goals, today's task를 불러옴.

  - 텍스트, 목표, 로딩 플래그, 편집 토글에 대한 로컬 상태를 유지함.

# AI 활용 학습 극대화

- AI 도구를 활용하여 학습 능력을 극대화할 수 있음.

  - **O3, Cloud for Opus** 등의 최첨단 AI 모델 활용

- 매일 3시간 투자 시 기술 습득 및 미래 성공 가능성 증대

  - 나이에 상관없이 효과적임 (10대, 40대, 70대 모두 해당)

## 프론트엔드 개념 학습

- AI에게 프론트엔드 개념 설명을 요청하여 학습 가능

  - "I don't know what these front end concepts are, explain them." 과 같이 질문

## 시간 투자와 성공 가능성

- AI 도구 활용에 시간 투자 시 미래에 성공할 가능성이 높아짐

  - 꾸준한 학습 및 기술 습득이 중요함

# AI 활용 극대화를 위한 꾸준한 학습

- 매일 3시간씩 AI 리즈닝 모델을 활용하여 꾸준히 학습하면 2~3년 후 삶의 질이 크게 향상될 것임.

- AI 학습을 통해 꾸준히 실력 향상을 꾀해야 함.

# UI/UX 개선 (Hover 효과)

- 버튼에 hover 효과를 추가하여 사용자 경험을 개선할 수 있음.

  - 배경색을 녹색으로 변경하고 아이콘을 흰색으로 변경하는 것이 좋은 아이디어가 될 수 있음.

# `sash clear` 명령어

- Cloud Code 작업 시 `sash clear` 명령어를 사용하여 초기화하고 다른 작업을 시작할 수 있음.

# Context Window 관리

- Context Window가 가득 차지 않았을 때 `/compact` 명령어를 사용해서 작업을 계속할 수 있음.

- Context Window가 얼마나 찼는지 확인해야 함. 30% 정도 남았을 때 확인하는 것이 좋음.

## `/compact` 명령어

- 작업을 이어서 할 때 사용함.

## Context Window 확인

- Context Window가 30% 정도 남았을 때 확인하는 것이 좋음.

# Cloud4 모델 성능

- Cloud4 모델(Opus, Sonnet)은 토큰 수에 따라 성능이 달라짐.

## Opus 및 Sonnet

- Cloud4 모델에 해당함.

## 토큰 제한

- 80k-100k 토큰 이후에는 성능이 크게 저하될 수 있음.

# AI 모델 토큰 한계

- AI 모델은 **200,000 토큰** 윈도우를 가짐.

  - **100,000 토큰** 이후에는 성능이 저하될 수 있음.

  - 자동 축소 기능이 나타나기 전에 `slash compact`를 사용하는 것이 좋음.

- `slash compact` 명령어 활용법

  - `slash compact`를 사용할 때는 **커스텀 메시지**를 함께 입력하는 것이 효율적임.

    - 예시: `/compact heavily summarize everything, ignore the git stuff, answer in short`

    - 이렇게 하면 AI가 Git 관련 내용을 무시하고 더 빠르게 요약할 수 있음.

# 모델 사용 및 CloudMax 구독

## 모델별 사용 권장 사항

- Opus 모델:

  - 강력하지만 속도가 느리고 비용이 비쌈.

- Sonnet 모델:

  - 대부분의 사용자에게 더 적합할 수 있음.

  - Opus에 비해 비용 효율적임.

## CloudMax 구독 정보

- Cloud Code 사용자에게 가장 좋은 가치를 제공함.

- API 키를 사용하는 경우, CloudMax 구독이 유리함.

# CloudMax 구독 정보

- CloudMax 요금제

  - 월 $100 요금제: 대부분의 사용자에게 적합함.

  - 월 $200 요금제: 더 높은 사용량을 제공 (20배), 사실상 무제한에 가까움.

- CloudMax 업그레이드의 장점

  - API 키 사용 시 과도한 비용 발생을 방지함.

  - 장기적으로 비용 절감 효과가 있음.

  - Cloud Code 에이전트의 가치를 높임.

  - API 사용량 제한에 자주 도달하는 경우 유용함.

# DailyModal UI 개선

## 버튼 Hover 효과 추가

- 목표: 현재 목표 편집 시, 저장 버튼에 hover 효과를 추가하여 UI 반응성 향상

  - 배경색 변경: 밝은 초록색으로 변경

  - 아이콘 색상 변경: 흰색으로 변경

  - 중요: 기본 스타일은 변경하지 않고, **hover 시에만** 스타일 변경 적용

# 사용자 피드백의 중요성

- 변경 사항 적용 시 사용자에게 **피드백 루프** 제공이 중요함.

  - 예: 초록색으로 변경하여 "저장 완료" 시각적 효과 제공.

  - 사용자가 변경 사항이 잘 적용되었는지 즉시 알 수 있도록 함.

# Dogfooding (자체 제품 사용)

- **Dogfooding**: 자신의 제품을 직접 사용하면서 버그 및 개선점을 찾는 과정임.

  - 제품 개발자는 반드시 Dogfooding을 해야함.

# UI/UX 개선

- 버튼 아래 여백(Margin) 또는 패딩(Padding) 과다 문제점 확인 필요함.

  - UI 디자인 시 Margin 및 Padding 값 조정 중요함.

# UI 디버깅

## Inspect Element 활용

- Inspect Element를 사용하여 UI 문제 (margin, padding 등)를 디버깅함.

- 브라우저의 개발자 도구를 활용하여 요소 검사함.

# 프롬프트 활용 팁

## "Answer in short" 프롬프트

- "Answer in short" 프롬프트를 사용하여 AI로부터 간결한 답변을 얻음.

- 효율적인 정보 획득에 유용함.

# AI 응답 제어

## 응답 중단: Escape 키

- AI 응답 중 Escape 키를 두 번 눌러 응답을 즉시 중단함.

- 불필요하거나 잘못된 응답을 빠르게 제어함.

## 이전 메시지 접근

- Escape 키를 사용하여 이전 메시지에 접근함.

- 이전 대화 내용을 다시 확인하거나 참고할 때 유용함.

## 디버깅 팁

- **전체 파일 읽기**: AI가 파일의 일부분만 읽는 경향이 있으므로, 정확한 분석을 위해 전체 파일을 읽도록 지시해야 함.

## 이전 메시지 편집

- **Escape 키 두 번 누르기**: Escape 키를 두 번 누르면 이전 메시지를 편집할 수 있으며, 이는 프롬프트를 개선하는 데 유용함.

# UI 스타일 변경

- P6 스타일을 적용함.

  - 구체적인 변경 사항은 추가 확인 필요함.

# 개발 브랜치 푸시

- 최신 UI 변경 사항을 `dev` 브랜치에 푸시함.

# O3 모델을 사용한 분석

- Daily focus 모델 분석에 O3 모델을 활용함.

  - 분석 목적 및 내용은 추가 확인 필요함.

# 단기 목표 업데이트 시점 확인

- 유저가 단기 목표를 마지막으로 업데이트한 시점을 알아내는 방법 찾기.

  - 코드베이스 전체를 분석함.

  - `/clear` 명령어를 사용하여 분석을 초기화할 수 있음.

- 데이터베이스 구조 분석 결과, 업데이트 시점을 직접적으로 알 수 있는 방법은 없음.

  - 브라우저의 로컬 스토리지에 업데이트 시점을 저장하는 방안을 고려할 수 있음.

# 사용자 목표 업데이트 강제화

- 목표를 강제로 업데이트하도록 유도하는 방법 고민함.

- 목표 업데이트는 매우 중요함.

# UI 조정

- 아이콘 디자인 및 배치 조정 고려함.

  - 아이콘 유사성으로 인한 혼동 방지.

  - 아이콘 간 간격 조정.

# Daily Focus Model 업데이트

- Daily Focus Model에서 편집 아이콘의 UI를 개선하고 있음.

## 편집 아이콘에 padding 추가

  - 편집 아이콘 옆에 padding-right: 2를 추가하여 간격을 넓힘.

## 다른 아이콘 시도

  - 현재 아이콘이 마음에 들지 않아 다른 아이콘으로 교체하는 것을 고려 중임.

## PR 없이 구현 목표

  - 코드 변경 사항을 PR 없이 바로 적용할 수 있도록 작업 중임.

# Cloud Code vs. Cursor

- Cloud Code가 Cursor보다 성능이 더 좋음.

- Cursor 에이전트는 느리고 context를 잘 잃어버림.

# Local Storage를 이용한 사용자 데이터 저장

- 사용자 스토리지를 활용하여 새로운 값을 저장할 수 있음. (aka 로컬 스토리지의 custom abstraction)

- 사용자 context 모델과 daily hook's 모델을 동기화하여 추적 가능함.

# 단기 목표 업데이트 장려를 위한 구현 계획

## 마지막 업데이트 시간 저장

- 사용자가 단기 목표를 마지막으로 업데이트한 시간을 저장해야 함.

- 7일 이상 업데이트하지 않은 경우 UI 변경을 통해 업데이트를 유도할 수 있음.

- `user storage` (aka custom abstraction of local storage)에 새로운 값을 저장하여 추적할 수 있음.

## UI 변경 사항

- 편집 버튼 애니메이션과 같은 UI 변경을 통해 업데이트를 장려할 수 있음.

## 단계별 구현 계획

- 관련된 모든 파일을 분석해야 함.

- 필요한 변경 사항을 단계별로 계획해야 함.

- 계획은 최대한 간단하게 작성해야 함.

# UI 디버깅 중 발생한 문제점

- 패딩이 버튼 안쪽에 잘못 추가됨.

  - 수정 사항: 패딩을 버튼 바깥쪽에만 적용해야 함.

# 임시 공격 계획 (Attack Plan)

- 문제 해결을 위한 임시 계획을 세우는 방법

  - 마크다운 파일을 사용하여 문제 해결 과정을 기록하고 계획함.

  - "좋았어, 이제 PR을 추가해 (good, but now add the PR)"와 같이 계획에 대한 코멘트를 추가할 수 있음.

# UI 조정

## 패딩/마진 조정

- 버튼의 오른쪽에만 패딩/마진을 추가해야 함.

- `MR1`을 사용하여 마진을 조정할 수 있음.

  - `MR1`은 특정 단위의 마진을 설정하는 것으로 보임.

## 코드 편집기 비교

- Cloud Code와 Cursor를 비교함.

  - Cloud Code가 Cursor보다 더 지능적이고 에이전트적인 것으로 판단됨.

  - Cursor는 문맥을 잃는 경향이 있다고 함.

# UI 높이 문제 조사

## 문제 설명

- 현재 목표 수정 버튼 클릭 시 전체 박스 높이가 낮아지는 현상 발생함.

- 목표 영역에 할당된 공간이 줄어드는 문제임.

## 조사 중점

- Cloud Code를 사용하여 문제 원인 파악 예정임.

- 클릭 이벤트 발생 시 UI 높이 변경 원인 조사해야 함.

# UI 높이 유지 방법

- 목표 편집 모드에서도 UI 높이를 동일하게 유지하는 것이 중요함.

  - 편집 시 높이 변경으로 인한 사용자 경험 저하 방지

# Cloud Code vs Cursor Agent

- Cloud Code: 에이전트 디코딩에 더 효과적임.

- Cursor Agent: 코드 베이스 이해 및 변경 사항 구현에 유용함.

  - Cloud Code가 다른 작업을 수행하는 동안 사용 가능

  - 여전히 유용한 도구임.

# IDE disconnected 경고

- 해결 방법이 존재함 (구체적인 내용은 추가 정보 필요).

# 건강 개선 및 생산성 향상을 위한 스탠딩 데스크와 워킹 패드

## 스탠딩 데스크의 장점

- 스탠딩 데스크는 건강을 해치지 않고 더 오래 일할 수 있게 해줌.

- 장시간 앉아 있는 것의 단점을 보완함.

- 8시간, 10시간, 심지어 6시간 동안 앉아 있는 것도 건강에 좋지 않음.

## 워킹 패드의 활용

- 스탠딩 데스크 밑에 워킹 패드를 놓으면 앉기, 서기, 걷기를 번갈아 할 수 있음.

- 걷는 동안 칼로리를 소모하면서 12시간 동안 일할 수 있음.

- 건강을 개선하면서 일할 수 있다는 장점이 있음.

## 자세 변화의 중요성

- 앉기, 서기, 걷기를 번갈아 하면서 작업 효율을 높일 수 있음.

- 장시간 같은 자세로 있는 것보다 건강에 좋음.

- 스탠딩 데스크와 워킹 패드를 함께 사용하면 더욱 효과적임.

# UI 이슈 및 해결책

## 이슈: 편집 모드에서 높이 변경

- 편집 모드에서 current goals 박스의 높이가 낮아지는 문제 발생함.

## 해결책: 명시적인 item text area 설정

- 명시적인 item text area를 설정하여 높이 변경 문제를 해결하고자 함.

# 버전 관리

## 버전 1.0.17의 중요성

- 특정 버전(1.0.17)을 사용해야 함.

- 새로운 버전에서 Plan mode 관련 문제가 발생할 수 있음.

# 작업 흐름

## 자동 승인 모드로 전환

- 변경 사항을 자동적으로 승인하는 모드로 전환함.

# UI 문제 해결 과정

## 텍스트 영역 높이 문제

- 편집 모드에서 박스 크기가 줄어드는 문제 발생함.

- 텍스트 영역의 높이가 너무 작아지는 문제 발생함.

- 280px로 높이를 설정했지만, 너무 과도함.

## 높이 값 조정 필요

- 적절한 픽셀 값으로 조정해야 함.

# UI 조정 및 개선

## 높이 조정

- 초기 280px에서 시작하여 UI 요소의 높이를 조정함.

- 240px 시도 후, 여전히 높다고 판단함.

- 220px로 추가 조정 후, 만족스러운 결과 얻음.

## 폰트 크기 조정

- 작업 제목 폰트 크기를 1px 늘릴 예정임.

- 다른 변경 사항은 적용하지 않음.

## 개발 프로토콜 푸시

- 변경 사항을 "dev protocol"에 푸시함.

- 이는 개발 환경에 변경 사항을 적용하는 것을 의미함.

# 워크플로우 최적화

## 푸시 중 프롬프트 엔지니어링

- 코드 푸시 중에도 프롬프트를 작성해서 시간을 절약해야 함.

- 틱톡이나 트위터를 보지 말고 생산적인 일을 해야 함.

## IDE 재연결

- IDE 연결이 끊어졌을 때 `/ID` 명령어를 사용해야 함.

- `/ID` 입력 후 커서 또는 VS Code를 선택하면 재연결됨.

# 임시 공격 계획 (Temporary Attack Plan)

- 중간에서 큰 규모의 변경사항에 유용함.

# 단기 목표 업데이트 추적

- 방법: 로컬 스토리지 사용

- 데이터: 마지막 업데이트 타임스탬프

- 목적: 사용자가 목표를 마지막으로 업데이트한 시간을 추적

# Local Storage Tracking 간소화

- 목표 업데이트 시점만 추적하면 됨.

  - 타임스탬프 불필요함.

  - User storage variable에 마지막 업데이트 날짜만 저장하면 됨.

- AI 제안에 대한 비판적 사고 중요함.

  - AI의 제안을 맹목적으로 수용하지 말아야 함.

  - 개발자의 직관과 판단력이 중요함.

  - 복잡하다고 느껴지면 더 간단한 방법을 찾아야 함.

# AI 제안에 대한 비판적 사고

- AI가 제시하는 해결책을 맹목적으로 수용하지 않아야 함.

- 제안이 과도하게 복잡하다고 느껴진다면, 자신의 직관을 믿고 재고해야 함.

- AI의 제안을 비판적으로 검토하고, 프로젝트의 맥락에 맞게 조정하는 것이 중요함.

# 목표 업데이트의 중요성

- 현재 목표를 지속적으로 업데이트하는 것이 매우 중요함.

- 목표를 방치하지 않고 꾸준히 관리해야 함.

- 목표 업데이트는 프로젝트의 진행 상황을 반영하고, 방향성을 유지하는 데 도움이 됨.

# 현재 목표 업데이트의 중요성

- 목표를 stale 상태로 두지 않고 **꾸준히 업데이트**하는 것이 중요함.

# Cloud Code 명령어 해석

- Cloud Code는 특정 명령어를 인식하고 그에 따라 작동함.

  - **"전체 파일 읽기"**: Cloud Code가 파일의 모든 라인을 읽도록 지시함. 단순한 프롬프트 엔지니어링 팁이 아님.

  - **"확장된 사고 사용"**: Cloud Code가 확장된 사고 방식을 사용하도록 지시함. Anthropic에서 Cloud Code가 이러한 명령을 듣고 수행에 영향을 미치도록 구축함.

# "확장된 사고"가 Cloud Code 추론 노력에 미치는 영향

- "확장된 사고 사용" 명령어를 사용하면 Cloud Code가 **더 많은 추론 노력**을 기울임.

- 단순한 몇 문장 작성 대신, 사고 속성을 활용하여 더 깊이 있는 추론을 수행함.

# 프롬프트 엔지니어링과 AI 추론

- "extended thinking" 프롬프트 사용 시 AI가 더 많은 추론 노력을 기울임.

  - AI는 프롬프트에 따라 사고 속성을 활용하여 장시간 추론을 수행함.

# 목표 추적을 위한 최소 계획

- 단기 목표 업데이트 추적을 위한 최소 계획이 수립됨.

  - "Enhance, save, blah, blah, blah, add, date" 단계를 포함함.

  - 일일 포커스 모델에 적용될 예정임.

# 사용자 스토리지 구현

- 사용자 스토리지에 변수를 추가하는 데 집중함.

  - 애니메이션이나 툴팁은 고려하지 않음.

  - 두 모델이 변수를 적절히 활용하도록 함.

# MD 파일 사용의 중요성

- 계획을 기록하고 추적하는 데 MD 파일이 매우 중요함.

  - 파일을 태깅하여 계획을 상기시키기 쉬움.

  - 계획의 어느 단계에 있는지 추적 가능함.

- 변경 사항의 크기에 따라 MD 파일의 필요성이 달라짐.

  - 작은 UI 변경과 같은 경우에는 필요하지 않음.

  - 중간 크기 이상의 변경 사항에는 MD 파일이 필요함.

# 지속적인 프롬프트 (Continual Prompt)

- 정의: 특정 조건이 충족될 때까지 계속 작업을 수행하도록 AI에게 지시하는 프롬프트임.

- 사용법: 목표를 명확히 제시하고, 완료될 때까지 멈추지 않도록 조건을 설정함.

- 목표 지향적 실행

  - Last Goals에 명시된 계획이 완전하게 실행될 때까지 계속 진행함.

  - 기능이 깔끔하고 적절하게 추가될 때까지 멈추지 않음.

  - 10x 엔지니어처럼 최소한의 변경으로 구현하는 것을 목표로 함.

# 프롬프트 엔지니어링 팁

- "Do not do anything else"로 프롬프트를 끝내는 것이 효과적임.

- 이 방법은 내가 가장 선호하는 문제 해결 방식임.

# 클라우드 코드와 커서

- 클라우드 코드와 커서를 사용하면 클라우드 코드가 무엇을 하고 있는지 실시간으로 대화할 수 있음.

- 터미널이 클라우드 코드를 참조하고 있음을 알 수 있음.

# 모델 상담

- O3, Gemini와 같은 여러 모델을 사용하여 상담하면 더 나은 결과를 얻을 수 있음.

- 하나의 모델만 사용하는 것보다 다양한 모델을 활용하는 것이 좋음.

- 클라우드 포 소넷을 많이 사용함.

# 모델 통합을 통한 오류 감소

- 여러 모델(Claude Opus, O3, Gemini 2.5 Pro)을 함께 사용하면 오류 발생 가능성이 크게 줄어듦.

  - 특히 대규모 리팩토링이 아닌 경우에 효과적임.

  - 세 가지 최첨단 추론 모델 활용: Claude Opus (사고), O3, Gemini 2.5 Pro (6월 버전).

# 코드 위치 오류 조사

- `user context model` 관련 코드가 장기 목표(long term goals) 섹션에 있는 이유를 조사해야 함.

  - `user context model`의 구성 요소: `import user storage`, `previous shoulder focus`, `set shoulder focus`, `use state`, `set previous shoulder focus`.

  - 해당 파일의 구현이 올바른지 확인해야 함.

# 디버깅

- 프론트엔드 디버깅을 통해 문제점 파악해야 함.

  - 장기 목표(long term goals)에서 단기 목표(short term focus)로 변경된 이유 조사해야 함.

- 코드 변경 사항 이해하는 것이 중요함.

  - 모든 코드를 이해할 필요는 없지만, 변경 사항이 어떤 영향을 미치는지 알아야 함.

- 목표 업데이트 시점 확인 및 stale 여부 확인해야 함.

  - 목표가 마지막으로 업데이트된 시점을 확인하고, stale 상태인지 판단해야 함.

  - `since days` 변수를 사용하여 목표 업데이트 이후 경과된 시간 계산해야 함.

# Daily Focus Model 업데이트 및 테스트

## 로컬 스토리지 확인

- 목표가 마지막으로 업데이트된 시점 확인: `last updated await` 사용.

- 날짜 계산 로직: `since days`를 사용하여 업데이트 날짜 계산.

- 이전 단기 목표 상태 추적 기능 추가됨.

- 로컬 스토리지를 확인하여 문제점 파악 및 해결해야 함.

## 문제점 발견 및 해결

- 로컬 스토리지에서 문제 발견.

- Daily Focus Model 업데이트 필요.

- 구현 테스트를 통해 문제 해결.

# Custom Scroll Bar

## Custom Scroll Bar 구현

- 좁은 브라우저 창 (모바일, 노트북)에서 모델 전체에 스크롤 바가 필요할 때, 기본 흰색 스크롤 바 대신 **custom scroll bar**를 사용해야 함.

- `Globals`에서 제공하는 custom scroll bar를 적용해야함.

# 스타트업 조언

## 스스로의 도구를 사용해야 함

- 스타트업을 만들 때, **스스로가 number one user**가 될 계획이 없다면 시작하지 않는 것이 좋음.

- 직접 도구를 사용해야 작은 UI/UX 문제들을 발견하고 개선할 수 있음.

- 도구를 직접 사용하지 않으면 시간 낭비일 가능성이 높음.

# 제품 개발 시 주요 고려 사항

- **스스로의 문제 해결**: 개발하는 제품은 자신이 겪는 문제를 해결해야 함.

- **넘버원 사용자**: 자신이 제품의 핵심 사용자가 되어야 함. 그렇지 않으면 경쟁에서 뒤쳐질 가능성이 큼.

# 사용자 컨텍스트 확인

- 사용자 컨텍스트를 확인하는 것은 중요함.

# 단기 목표 업데이트

- 단기 목표를 업데이트하여 프로젝트 진행 상황을 반영해야 함.

# 새로운 `userStorage` 변수 위치 찾기

- 프론트엔드 디버거를 사용하여 새로운 `userStorage` 변수의 위치를 찾아야 함.

# 사용자 저장 변수 위치 및 이름

- 프론트엔드 애플리케이션 디버거에서 변수를 찾을 수 있음.

  - **로컬 스토리지**에서 사용자 ID로 접근함.

  - 변수 이름은 **'short'** 와 **'goals updated at'** 임.

  - 값은 **암호화**되어 있음.

# 암호화 이유

- 동일한 브라우저에서 **여러 사용자**를 지원하기 위함임.

# 암호화된 값과 디버깅

- 값은 암호화되어 저장됨.

  - 동일한 브라우저를 여러 사용자가 사용할 수 있기 때문임. 보안상의 이유임.

- 프론트엔드 콘솔에 임시 콘솔 로그를 추가해야 함.

  - 업데이트/저장 시 콘솔에 출력하여 디버깅을 용이하게 하기 위함임.

# 디버깅 및 아이디어 관리

- **디버깅을 위한 콘솔 로그 활용:**

  - 콘솔 로그를 사용하여 암호화되지 않은 형식으로 디버깅 정보를 확인해야 함.

- **Vectl을 이용한 아이디어 기록:**

  - Vectl과 같은 도구를 사용하여 떠오르는 아이디어를 즉시 기록해야 함.

- **Elixir Focus Reminder로 Nice Chips 교체:**

  - "Nice Chips"를 "Elixir Focus Reminder"로 교체하는 아이디어를 기록해야 함.

# 디버깅 및 코드 유지보수

## 콘솔 로그 가시성 향상

- 콘솔 로그에 **불 이모지 🔥🔥** 를 추가하여 더 눈에 띄게 함.

  - 디버깅 시 로그를 쉽게 찾을 수 있도록 함.

## 코드 정리 필요

- 주기적으로 `**/compact**` 명령어를 실행해야 함.

  - 코드베이스를 정리하고 최적화하는 데 도움을 줌.

  - 최근에 실행하지 않은 것 같다는 느낌이 들면 실행해야 함.

## 코딩 컨벤션보다 기능 우선

- 엄격한 코딩 컨벤션보다 **실제로 작동하는 코드**가 더 중요함.

  - 코딩 컨벤션에 얽매이지 않고 문제 해결에 집중.

  - 나중에 문제가 발생하면 그때 수정해도 됨.

# 코딩 관행 및 문제 해결

- 코딩 관행보다 **기능성**을 우선시함.

- **어떤 문제를 해결**하고 있는지 항상 자문하는 것이 중요함.

# UI/UX 고려 사항

- UI 디자인에 대한 **개인적인 선호도**가 있을 수 있음.

- UI가 축소된 형태를 선호하지 않음.

# 목표 및 컨텍스트 업데이트

- 목표 크기가 업데이트되었는지 확인해야 함. 예: 0.50

- 단기 컨텍스트 업데이트가 예상대로 작동하는지 확인해야 함.

# 사용자 컨텍스트 업데이트 테스트

- 단기 사용자 컨텍스트 업데이트 테스트 진행함.

  - 업데이트가 안 되는 경우 확인 (정상 작동)

  - 현재 시간으로 저장되는지 확인 (정상 작동)

  - 변경 없이 저장 시 업데이트 안 되는지 확인 (정상 작동)

- 목표 업데이트 관련 버그 발견함.

  - 수정 필요함.

# 버그 수정 및 개발 푸시

- 버그 수정 완료 후 저장 로직이 올바르게 동작하는지 확인했음.

  - 변경 사항 저장 시 업데이트되는지 확인

  - 변경 사항 없을 시 업데이트되지 않는지 확인

- 새로운 사용자 저장 변수를 개발 환경(dev)으로 푸시함.

# 콘솔 로그 관리

- 콘솔 로그를 일시적으로 유지하거나 제거하는 것을 고려함.

  - 디버깅 편의를 위해 콘솔 로그를 남겨둘 수 있음

  - 최종 배포 전 콘솔 로그 제거 고려

# 코드 압축 (Compaction)

- 코드 압축(Compaction)을 통해 코드 정리 및 최적화 필요.

  - 불필요한 코드 제거 및 코드 간결화

  - `slash compact` 명령어 사용 고려

# AutoSend 문제점 조사

- AutoSend 기능에서 주요 문제 발생함.

- 프롬프트 조사 필요함.

# DB Context Table 구조 확인

- DB의 Context Table 구조를 검토해야 함.

- 데이터 구조 파악이 중요함.

# Gemini 모델로 전환

- o3 모델 사용에 지쳐 Gemini 모델로 전환함.

- 최신 Gemini 모델 사용함.

# Superbase 설정 파일 읽기

- Gemini 모델을 사용하여 Superbase 설정 파일을 읽을 예정임.

- 설정 파일 분석을 통해 문제점 파악 및 개선 시도함.

# 컨텍스트 테이블 구조

- 컨텍스트 테이블 구조에 대한 설명이 있음.

# 데일리 모델 애니메이션 추가

- 목표: 미묘하지만 강력한 애니메이션 추가.

- 애니메이션 발생 시점: 데일리 모델이 열린 후 5초 뒤.

- 애니메이션 효과: 현재 목표 상자 안의 편집 버튼 주변에 애니메이션이 실행됨.

## 애니메이션 트리거 조건

- 단기 목표를 7일 이상 업데이트하지 않은 경우에만 발생.

- 로직은 이미 구현되어 있어야 함.

# 디버깅 및 문제 해결

## 컨텍스트 테이블 구조 이해

- 컨텍스트 테이블 구조를 파악하는 것이 중요함.

- 테이블 구조를 이해해야 데이터 로딩 문제를 해결할 수 있음.

## 애니메이션 확인

- 새로운 기능(애니메이션)이 제대로 작동하는지 확인해야 함.

- 데일리 포커스 모델에서 애니메이션을 확인해야 함.

## 파일 업데이트 시 주의사항

- 파일을 업데이트할 때 항상 올바른 파일을 수정하는지 확인해야 함.

- 잘못된 파일을 수정하면 예기치 않은 문제가 발생할 수 있음.

# 엣지 케이스 테스트: 사용자 저장소 변수 누락

## 시나리오: 변수 삭제 시

- `short term goals updated at` 변수를 사용자 저장소에서 삭제함.

- 목표: 해당 변수가 없을 때 애니메이션이 여전히 실행되는지 확인해야 함.

## 예상되는 동작: 애니메이션 실행 여부 확인

- 사용자 저장소에 필요한 변수가 없을 경우의 앱 동작을 파악하는 것이 중요함.

- 애니메이션이 예상대로 동작하는지 확인해야 함.

# 애니메이션 조정 필요함

- 현재 애니메이션이 다소 거슬림. 개선이 필요함.

- 펄스 효과를 **3번**만 반복하도록 제한해야 함.

- 각 펄스의 크기가 너무 커지지 않도록 스케일을 축소해야 함.

- 애니메이션이 더 차분하게 느껴지도록 조정해야 함.

# Global CSS 파일 및 코딩 관행

- Global CSS 파일의 길이가 너무 길어지는 것을 방지해야 함.

- 깨끗한 코딩 관행을 유지하는 것이 중요함.

# 애니메이션 트리거 조건 및 테스트

- 애니메이션이 특정 조건에서만 트리거되는지 확인해야 함.

- 저장 후에는 애니메이션이 실행되지 않도록 테스트해야 함.

- 애니메이션이 의도치 않게 계속 실행되는 버그를 수정해야 함.

# 애니메이션 트리거 및 저장

## 저장 후 올바른 애니메이션 동작

- 데이터베이스에 값이 존재하면 애니메이션이 실행되지 않아야 함.

- 목표를 수정한 후 저장할 때 애니메이션이 트리거되지 않도록 해야 함.

## 애니메이션 트리거 테스트

- 데이터베이스에서 관련 값을 삭제하여 애니메이션이 올바르게 트리거되는지 확인해야 함.

- 5초 후에 모델을 열어 애니메이션이 사용자에게 목표 변경을 유도하는지 확인해야 함.

# 개발 환경으로 애니메이션 푸시

- 애니메이션을 개발 환경(dev)으로 푸시함. 좀 더 일찍 푸시했어야 했음.

- 완벽주의에 빠지지 않고, 현재 상태로도 충분히 좋다고 판단함.

## 빌드 에러 모니터링

- 개발 환경(dev)에서 빌드 에러가 발생하는지 지속적으로 모니터링해야 함.

- 빌드 에러 발생 시 Vercel을 통해 확인하고 있음.

## Vercel 활용

- Vercel을 사용하여 빌드 상태를 모니터링함.

## 애니메이션 추가로 빌드 에러 해결 가능성

- 애니메이션 추가가 빌드 에러를 해결할 수 있을 것으로 예상됨.

- 이전에 사용되지 않던 코드가 애니메이션 추가로 인해 사용될 수 있음.

# 구현 성공 및 주요 이슈

- 기능 구현이 성공적으로 완료됨.

- 컨텍스트 테이블 정의 완료.

- 하지만 여전히 해결해야 할 **주요 이슈**가 존재함.

# 코드 리팩토링 및 정리

- 코드베이스를 정리하고 리팩토링할 필요가 있음.

  - **코드 압축 프롬프트**를 활용하여 코드 요약 및 정리.

  - 파일 길이가 **650줄**이나 되는 긴 파일을 정리해야 함.

  - 코드의 가독성과 유지보수성을 높이는 것이 목표임.

# daily focus more 컴포넌트 리팩토링

- 목표: 코드 라인 수를 줄이고 모듈성을 높임.

- 액션: `components` 폴더 안에 `Today's Focus`라는 새 폴더를 생성함.

- 모델과 새로운 파일을 새 폴더로 이동시킴.

# 코드 리팩토링 계획

## Daily focus model 분할

- 현재 Daily focus model 파일은 **650줄**로 너무 김.

- 파일을 더 작고 관리하기 쉽게 분할할 계획임.

  - 구체적인 분할 기준은 아직 정해지지 않음 (예: 기능별, 컴포넌트별).

## `/compact` 명령어 사용

- `/compact` 명령어를 사용하여 AI 모델이 **전체 컨텍스트**를 이해하도록 함.

  - 이를 통해 모델이 파일 전체의 내용을 기반으로 분석하고 제안할 수 있음.

## 파일 구조 분석

- 현재 파일 구조를 분석하여 코드를 재구성하는 **최적의 방법**을 결정함.

- 목표는 코드의 **모듈화**를 높이고 유지 관리성을 향상시키는 것임.

# 코드 분할 및 프롬프트 팁

## 두 개의 파일로 분할

- 세 개가 아닌 **두 개의 파일**로 분할하는 것을 목표로 함.

- 목표 섹션과 오늘 섹션으로 분할하는 것이 좋음.

## 프롬프트 팁

- 코드 리팩토링을 위해 프롬프트를 사용할 때, **세 개 또는 네 개의 옵션**을 요청하고 가장 적합한 것을 선택하는 것이 좋음.

- 이는 좋은 코딩 습관을 유지하는 데 도움이 됨.

# "Today's Focus" 폴더 생성

- `components` 폴더 안에 `today's focus`라는 새 폴더를 생성함.

  - 특수 문자는 사용하지 않음.

# 모델 분할

- 모델을 더 작은 파일로 분할할 계획임.

## 데이터 가져오기 및 로직

- 데이터 가져오기 로직을 추출하여 `useDailyFocusData` 커스텀 훅을 사용함.

## 훅 및 사용자 집중

- 훅과 사용자 집중 및 콜백 효과를 추출함.

- `useDailyFocusHandlers` 및 `dailyFocusContent`로 분리하는 것을 고려함.

# 파일 분할 및 리팩토링

- `daily focus model` 파일을 더 작게 분할하는 방법 논의

  - 코드 구성을 개선하기 위함임.

- Gemini를 사용한 파일 분할 제안

  - Gemini에게 파일 분할 옵션에 대한 조언을 구함.

- 로직과 UI 분리 중요

  - 로직과 UI를 분리하는 것이 좋음.

  - Option 1과 Option 3이 합리적인 선택으로 보임.

- Option 1이 가장 합리적인 선택

  - 데이터 가져오기 로직을 custom hook으로 분리하는 것이 가장 좋다고 판단됨.

  - 깨끗하고 분리된 코드를 유지할 수 있음.

# 파일 이동 및 폴더 구성

- 컴포넌트 폴더 안에 **Today's Focus**라는 새로운 폴더를 만들겠음.

- Modal 파일을 **Today's Focus** 폴더로 이동시키겠음.

- `mv` 명령어를 사용할 예정임.

# AI 모델 활용

- 의사 결정을 위해 두 가지 AI 모델을 참고했음:

  - Claude Opus

  - Gemini 2.5 Pro (June 버전)

- Option 1을 선택하기 전에 두 모델의 의견을 수렴했음.

# 파일 이동 및 리팩토링

## 파일 이동

- `mv` 명령어를 사용하여 파일을 새로운 폴더로 이동함.

- 예: `mv 파일명 폴더명`

## 새로운 파일 생성 및 리팩토링 준비

- DailyFoxModal 리팩토링을 위해 새로운 파일을 생성해야 함.

- 새 파일에 적절한 헤더 주석을 추가하는 것이 중요함.

- 리팩토링 전에 DailyFoxModal 파일을 완전히 읽어야 함.

## 리팩토링 실행

- 파일을 분할하여 코드를 정리하고 모듈화함.

- 마치 숙련된 개발자처럼 코드를 분할하고 리팩토링해야 함.

# 다중 추론 모델 활용

## 다중 모델 컨설팅의 이점

- **코드 변경 결정 시** 두 개 이상의 최첨단 추론 모델을 활용하는 것은 매우 효과적임.

- 모델들이 계획에 동의할 경우, 성공적인 변경 가능성이 크게 높아짐.

- 예시: Claude와 Gemini 같은 모델을 사용하여 최적의 코드 분할 방안을 결정함.

## 시니어 개발자의 마음가짐

- 코드 리팩토링 시, 계획을 상기하고 심호흡을 한 후 작업에 집중하는 것이 중요함.

- 마치 시니어 개발자처럼 코드를 분할하고, 다른 작업은 수행하지 않도록 함.

# 파일 이동 후 임포트 수정

- 파일 이동 후에는 반드시 임포트를 수정해야 함.

  - `dailyFocusModel` 파일을 새 폴더로 이동한 후, 관련된 모든 임포트 경로를 수정해야 함.

  - 임포트 수정 누락은 코드 오류를 발생시킬 수 있음.

- AI 어시스턴트의 작업 흐름 수정

  - 새 파일 생성 전에, 이동으로 인해 영향을 받는 모든 임포트를 먼저 수정하도록 지시함.

  - 이는 코드의 일관성을 유지하고 오류를 방지하기 위함임.

# 파일 이동 후 Import 수정

- 파일 이동으로 인해 `model container`와 같은 다른 파일들의 import가 깨질 수 있음.

- Cloud code가 import 수정을 완벽하게 처리함.

# 잦은 Commit의 중요성

- Refactor 작업 중 문제가 발생했을 경우, 이전 commit으로 돌아가기 위함임.

- 작은 변경사항 후에도 commit을 수행하여 변경 이력을 관리하는 것이 중요함.

# 코드 리팩토링 후속 단계

## Compact 명령 사용

- 목적: 컨텍스트를 효과적으로 요약함.

- 방법: `/compact` 명령어를 사용함.

- 추가 설명: 깃(Git) 커밋 관련 명령어를 무시하고, 답변을 간결하게 요약해야 함.

## 압축(Compaction) 후 프롬프트 실행

- 중요성: 타겟팅된 프롬프트를 통해 AI 모델 활용도를 높임.

- 목표: AI 모델이 콘텐츠를 어떻게 처리하는지 이해하고, 이를 바탕으로 프롬프트를 최적화함.

# 컨텍스트 윈도우 관리

- 컨텍스트 윈도우 관리가 매우 중요함.

## 컨텍스트 테이블

- 에이전트를 위한 메모리를 저장하는 컨텍스트 테이블이 있음.

### 컨텍스트 테이블 구조

- 키(Keys): 콘텐츠

- 텍스트: 컨텍스트 또는 메모리 내용

- 검색 벡터(Search Vector): 의미 검색을 위한 벡터

- 사용자 ID(User ID): 사용자 식별자

- 객체 ID(Object ID): 객체 식별자

- 객체 타입(Object Type): 객체 타입 (작업, 노트 등)

### 오브젝트 타입 설정의 중요성

- 객체 타입(Object Type)을 반드시 설정해야 함. 현재 NULL로 설정되어 있는 문제 발견.

### 만료 시간 설정의 중요성

- 만료 시간(Expires At)을 반드시 설정해야 함.

# Context Memory 설정

- `expires at` 설정이 필요함.

  - 30일 후로 설정해야 함.

- `object types`을 "today's focus"로 설정해야 함.

# 새 파일 생성 과정

- 새 파일을 만들기 전에 헤더 주석을 먼저 추가해야 함.

- 그런 다음 파일 내용을 작성해야 함.

# 데이터베이스 문제점

- 현재 구현 방식의 문제점

  - 데이터베이스에 Null 값이 존재함.

  - Context Table을 제대로 활용하지 못하고 있음.

  - 특정 객체 타입 추출 로직에 문제 발생.

# 해결 계획

- 버그 수정

  - Context Table 관련 버그 수정으로 두 가지 문제 해결 기대.

- 프롬프트 개선

  - AI 모델에게 더 명확하고 효과적인 지시를 내리도록 프롬프트 개선.

- AI 제안 작업 개선

  - AI가 제안하는 작업의 정확성과 관련성을 높임.

  - 불필요한 제안 제거 (예: "precise chip")

# V2 기능

- 언급된 개선 사항들은 V2 기능에 해당함.

# 스타트업 개발 시 MVP와 V2 기능의 중요성

- MVP (Minimum Viable Product) 기능과 V2 기능 구분은 매우 중요함.

  - 많은 개발자들이 모든 기능을 한 번에 구현하려 하지만, MVP에 집중해야 함.

  - 핵심 가치 제공에 우선순위를 두어야 함.

- V2 기능은 MVP 이후에 고려해야 할 기능임.

  - 사용자 피드백을 기반으로 개선 및 확장.

  - 불필요한 기능 추가를 방지.

# 리팩토링 시 파일 크기 고려 사항

- 파일 크기는 리팩토링 시 중요한 고려 사항임.

  - 너무 큰 파일은 유지보수를 어렵게 만들 수 있음.

  - 적절한 크기로 분할하여 관리 효율성을 높여야 함.

- 파일 크기 예상 및 계획

  - 리팩토링 전에 예상 파일 크기를 고려해야 함.

  - 목표 파일 크기를 설정하고, 그에 맞춰 리팩토링 진행.

# 파일 구조에서 로직 vs UI

- 로직과 UI 분리는 코드 유지보수성을 향상시킴.

  - 로직 변경이 UI에 미치는 영향을 최소화.

  - UI 변경이 로직에 미치는 영향을 최소화.

- 파일 구조 설계 시 고려 사항

  - 로직 관련 파일과 UI 관련 파일을 분리하여 관리.

  - 각 파일의 역할과 책임을 명확히 정의.

# MVP의 중요성

## 스타트업에서 MVP의 역할

- MVP(Minimum Viable Product)는 스타트업 구축 시 **필수적인 기술**임.

- 기능 추가에 매몰되지 않고, **출시 시기를 늦추지 않도록** 도와줌.

## 사용자 피드백 활용

- 중요한 기능은 사용자가 **알아서 요구**함.

- 불확실한 기능은 **과감하게 제거**해도 괜찮음.

- 사용자 피드백은 **기능 우선순위 결정**에 중요한 지표가 됨.

# 사용자 피드백

- 스타트업을 만들 때 사용자와의 대화가 매우 중요함.

  - 사용자 피드백을 적극적으로 수렴해야 함.

  - Discord 서버를 통해 사용자와 소통하고 있음.

# 리팩토링 전략

- 큰 변경 사항은 한 번에 처리하지 않아야 함.

  - 여러 단계로 나누어 진행하는 것이 좋음.

  - 실패할 경우를 대비하여 MD 파일을 만들어야 함.

# 리팩토링 전략

## 단계별 리팩토링의 중요성

- 한번에 너무 많은 코드를 변경하지 않도록 함.

  - 400줄 이상의 변경은 되돌려야 할 수도 있음.

- 작은 단계로 나누어 리팩토링을 진행하는 것이 안전함.

## 빌드 검증 및 테스트

- `**npm run lint**` 명령어를 사용하여 코드 스타일 및 오류를 검사함.

- 리팩토링 후에는 반드시 빌드가 성공하는지 확인해야 함.

# 리팩토링 후 테스트 단계

- 모든 부분을 테스트하여 예상대로 작동하는지 확인해야 함.

- 브라우저에서 직접 테스트하여 사용자 경험을 검증하는 것이 중요함.

# AI 제안 테스트

- AI 제안 로딩 확인

  - AI 제안이 제대로 로딩되는지 확인했음.

- 채팅 프롬프트 조사

  - 채팅 프롬프트 및 채팅 엔진 프롬프트 조사에 집중해야 함.

# 저장 기능 평가

- 저장 속도 확인

  - 저장 기능이 즉시 작동해야 하는지 확인해야 함.

  - AI 모델 때문에 즉시 저장이 불가능할 수도 있음.

# 현재 목표 업데이트

- 목표 저장 확인

  - 현재 목표를 업데이트하고 저장 기능이 제대로 작동하는지 확인해야 함.

  - 예: "5kg 감량" 목표를 설정하고 저장되는지 확인했음.

# 저장 및 취소 업데이트 테스트

- 저장 후 취소 시에도 데이터가 보존되는지 확인해야 함.

- 5kg -> 50kg 변경 후 취소해도 50kg이 저장되는지 확인했음. 아주 중요함.

- 현재 UTC 시간이 표시되고 있음.

- 작업은 5개로 제한되어 있음.

# AI 작업 제안

## 소프트웨어 디버깅 관련 작업

- AI에게 소프트웨어 디버깅과 관련된 작업 3가지 추가 요청함.

- 작업 UI가 제대로 로드되는지 확인해야 함.

## UI/UX 개선

- 작업 목록 앞에 붙는 번호의 글꼴 크기가 일관성이 있어야 함.

- 글꼴 크기 업데이트 필요: `daily focus model` 수정.

# UI 문제 수정 필요

- Daily Focus 모델의 숫자 폰트 크기를 조정해야 함.

- 작업 이름과 동일한 폰트 크기로 수정해야 함.

- 숫자 위치가 약간 낮게 표시되는 문제 수정이 필요함.

# 버그 수정 시 맥락의 중요성

- 문제 해결을 요청할 때 충분한 맥락을 제공해야 함.

- 단순히 "수정해"라고 말하는 것보다 구체적인 상황 설명이 필요함.

- 예: "숫자가 작업 이름보다 약간 아래로 이동했습니다."와 같이 설명해야 함.

# UI 개선

## 작업 이름 텍스트 정렬 문제 해결

- 작업 이름 텍스트가 숫자와 정렬되지 않는 문제 수정함.

- 텍스트 위치를 조정하여 시각적 균형을 맞춤.

- 최종적으로 정렬이 잘 되었는지 확인했음.

## 편집 아이콘 크기 조정

- 현재 목표 내 편집 아이콘의 크기를 약간 키움.

- 아주 작은 픽셀 단위로 조정하여 UI의 미묘한 개선을 꾀함.

- 아이콘이 너무 커지지 않도록 주의함.

# UI 조정

- 아이콘 크기 조정은 반복적인 작업임.

  - 1픽셀 변경이 실제로는 4픽셀로 적용되는 경우가 있음.

  - UI 변경은 여러 번의 수정이 필요할 수 있음.

# 개발 환경에 코드 푸시

- 리팩토링된 코드를 개발 환경(`dev`)에 푸시함.

# 테스트 및 데이터 정리

- 테스트 애플리케이션 데이터 삭제를 통해 정리함.

  - `students` 값 삭제.

# 코드 변경 사항 개발 브랜치에 푸시

- 큰 파일 리팩토링을 개발(dev) 브랜치에 푸시함.

- 이는 코드 변경 사항을 통합하는 중요한 단계임.

# UI 개선: 아이콘 크기 조정

- 현재 목표(current goals) 내 편집(edit) 아이콘의 크기를 조정함.

  - 아이콘이 너무 작다고 판단되어 크기를 약간 더 크게 조정함.

  - 1 픽셀씩 점진적으로 크기를 늘려 시각적 균형을 맞춤.

# 사용자 경험: 업데이트 알림 확인

- 애플리케이션을 닫았다가 다시 열었을 때 업데이트 알림이 제대로 표시되는지 확인.

  - 5~7일 동안 업데이트되지 않은 경우 알림이 나타나도록 설정됨.

  - 이는 사용자에게 최신 정보를 제공하고 참여를 유도하기 위함임.

# 자동 전송 기능 문제 해결

- UI 개선에서 핵심 기능 디버깅으로 초점 이동함.

- **주요 문제**: AI 자동 메시지 전송 시 잘못된 컨텍스트가 제공되고 있음.

  - AI가 사용자에게 부적절하거나 관련 없는 정보를 제공할 수 있음.

- **문제 발생 시점**: 사용자가 데일리 포커스 모델을 작성한 직후임.

  - 데일리 포커스 모델 작성 내용이 AI에게 정확하게 전달되지 않을 가능성이 있음.

- **해결 방안**: 문제 발생 위치를 정확히 조사해야 함.

  - 데이터 흐름을 추적하여 컨텍스트가 손실되거나 왜곡되는 지점을 찾아야 함.

# 데이터 저장 문제 디버깅

## 문제 조사 필요

- 자동 전송(auto send) 관련 문제 발생

- 문제 발생 시점: 사용자가 일일 집중 모델(daily focus model) 작성 직후

- 문제 원인: AI에 제공되는 컨텍스트(context)가 정확하지 않음

## 데이터베이스 컨텍스트 테이블

- 컨텍스트 테이블에서 데이터를 저장하고 추출하는 방식에 문제 있을 가능성 높음

- **중요**: 객체 유형(object type)을 저장하지 않음 → "오늘의 집중(today's focus)"과 같은 유형으로 저장해야 검색 용이

- **중요**: 만료 날짜(expires at date)를 설정하지 않음 → 데이터 항목에 만료 날짜 추가 필요

## 해결책

- 문제 발생 위치 및 관련 파일 조사 필요

- 어떤 정보가 로드되는지 정확히 파악해야 함

# 데이터베이스 컨텍스트 테이블 문제점

- **객체 타입 저장 누락:**

  - `today's focus`와 같은 객체 타입 저장이 안 되고 있음.

  - 쉬운 검색 및 검색을 위해 반드시 필요함.

- **만료 날짜 미설정:**

  - 컨텍스트가 영구적으로 저장되는 문제 발생.

  - 만료일을 30일로 설정해야 함.

# 부정확한 컨텍스트 로딩

- **AI 자동 전송 메시지 문제:**

  - 컨텍스트 테이블에서 잘못된 정보(작업, 목표 등)를 가져옴.

  - Daily Focus Model 작성 직후 AI 프롬프트에 부정확한 정보가 전달됨.

# 문제 해결을 위한 조사 필요

- **관련 파일 조사:**

  - 어떤 파일에서 문제가 발생하는지 파악해야 함.

- **근본적인 원인 해결:**

  - 데이터 저장 및 추출 방식 조사 필요.

  - 특히, 컨텍스트 테이블의 데이터 처리 방식에 집중해야 함.

# 프롬프트 파일 및 Context Agent

- 프롬프트 파일, Context Agent, 채팅 메시지 로딩 필요함.

- Context: AI가 사용하는 정보의 집합임.

## 네이밍 규칙

- 네이밍 규칙은 매우 중요함.

- "ContextSuggestion.System.Chat\_chat\_user\_that\_message"와 같은 복잡한 이름은 지양해야 함.

## Context Agent 이름 변경

- "Context Agent"를 "Today's Focus Agent"로 변경해야 함.

- 백엔드 이름도 "Today's Agent"로 변경해야 함.

## 필요한 Context Agent 식별

- Content 필요함.

- Context Agent (필수)

- Follow-up question (Conversation)

# 문제 해결 및 프롬프트 개선

- 오토샌드 문제의 원인이 되는 파일들을 찾아야 함.

  - 문제의 핵심 파일들을 식별해야 함.

- AI가 문맥을 더 잘 이해하도록 프롬프트를 개선해야 함.

# 오토샌드 속도 개선

- 오토샌드 기능의 속도와 효율성을 개선해야 함.

  - 사용자 경험을 개선하기 위해 응답 시간을 단축해야 함.

# 디버깅 및 로깅

## 주요 문제점

- AI 에이전트가 잘못된 사용자 데이터를 가져올 가능성이 있음. 이는 심각한 문제로 이어질 수 있음.

- 현재 AI에 데이터를 보내기 전에 로깅이 이루어지지 않아 문제 발생 시 추적이 어려움.

## 해결 방안

- **AI에 데이터를 보내기 전에 반드시 로깅을 추가해야 함.** 이를 통해 문제 발생 시 원인을 쉽게 파악할 수 있음.

- 프롬프트 재작성을 통해 AI가 더 정확한 응답을 생성하도록 유도해야 함.

- 데이터를 추출할 때 **동일한 단위**를 사용하는지 확인해야 함. 사용자 ID 또는 세션 정보가 일관되게 유지되어야 함.

- `Agent debugging.MD` 파일을 생성하여 디버깅 과정을 기록하고 관리해야 함.

# 사용자 컨텍스트 확인

- **동일 사용자 데이터 사용 중요**

  - AI 자동 메시지가 올바른 컨텍스트를 사용하도록 보장해야 함.

  - 빠른 모델 사용 및 사용자 정의 목적 정의.

# 명명 규칙 문제 해결

- **혼란스러운 이름으로 인한 문제점**

  - 잘못된 프롬프트 이름으로 인해 혼동 발생.

  - 명확하고 직관적인 이름으로 변경 필요.

# AI 제안과 실제 문제 구분

- **조사 방향 명확화**

  - AI 제안 자체는 문제가 아님.

  - 실제 문제(잘못된 컨텍스트 로딩)에 집중해야 함.

# AutoSend와 AI Suggestion 구분 명확화

- AutoSend와 AI Suggestion의 차이점을 명확히 이해해야 함.

- 각 기능을 담당하는 파일 및 함수를 식별해야 함.

  - 코드베이스 전체를 분석하여 완전한 이해를 목표로 함.

# 파일 이름 변경

- 명확성을 위해 백엔드 폴더 및 파일 이름을 변경해야 함.

# AutoSend와 AI Suggestion 분리

- AutoSend와 AI Suggestion 간의 완전한 분리를 목표로 함.

### Vectl에 작업 목록 추가

- Vectl에 새로운 기능으로 작업 목록을 추가함.

- 자동 전송과 AI 제안 사이의 구분을 명확히 해야 함.

### '오늘의 에이전트'로 이름 변경

- 백엔드 폴더 및 파일을 '오늘의 에이전트'로 이름 변경할 계획임.

- 코드베이스의 명확성을 높이기 위함임.

### 프롬프트 이름 변경 및 파일 분할 고려

- 프롬프트 이름 변경을 고려 중임.

- 필요에 따라 파일을 분할할 수도 있음.

- 단일 파일로 유지하는 것도 고려 중임.

### LLM 응답 컨텍스트

- 이는 LLM 응답을 위한 것임.

# 데이터베이스 문제

- AI 제안 분리 고려 사항

  - AI 제안을 분리할 필요가 있는지 검토함.

  - 동일한 목적으로 사용될 수 있다고 판단됨.

- 로딩 문제의 근본 원인

  - AI 자동 메시지가 잘못된 정보를 사용하는 원인은 데이터베이스에서 일일 초점을 로드하지 않기 때문임.

- 데이터베이스 저장 문제

  - 데이터베이스에 일일 초점 정보가 저장되지 않는 문제 발생.

    - 객체 유형이 설정되지 않음.

# 문제점 요약

- 일일 집중(Daily Focus) DB에 필드가 누락되어 흐름이 깨짐.

- AI 자동 전송이 AI 제안을 사용할 가능성이 있음.

# 해결 방안

## 분리 (Decoupling)

- 명확성을 위해 폴더와 파일 이름 변경.

- 자동 전송(AutoSend)과 AI 제안(AI Suggestion)을 완전히 분리해야 함.

## 로깅 추가

- 어떤 데이터가 사용되는지 로깅을 통해 확인해야 함.

# 디버깅 및 명확성 확보

## 데이터 로깅 및 자동 전송 메시지 확인

- 자동 전송 메시지에 로드되는 데이터를 로깅하고 확인해야 함.

- 로깅을 통해 어떤 데이터가 문제인지 파악하는 것이 중요함.

## 혼란스러운 컨텍스트 이름 변경

- 현재 컨텍스트 관련 이름들이 혼란스러움을 야기함.

- 클라우드 코드를 활용하여 이름 변경을 통해 명확성을 확보해야 함.

- 이름 변경은 문제 해결에 도움을 줄 수 있음.

## 핵심 문제 위치 파악

- 문제의 핵심이 특정 폴더에 있음을 인지함.

- 해당 폴더를 집중적으로 조사해야 함.

# 디버깅 과정

## 관련 파일 태깅

- 디버깅을 위해 관련 파일들을 태깅함.

  - Today's agent

  - Context agent

  - Suggestion system

  - Context agent suggestion message

  - Context agent suggestion system chat user message

## Gemini 2.5 Pro 활용

- 100만 컨텍스트 창을 가진 Gemini 2.5 Pro를 사용하여 명확성을 확보하고자 함.

## 관련 파일들

- `contextagent.py`

- `context service`

- \`context operations

# AI 기능 혼동 해소

## Modal AI Suggestion 정상 작동 확인

- Modal AI Suggestion 기능이 현재 정상적으로 작동하고 있음을 확인했음.

- 혼동을 야기했던 다른 AI 기능과의 차이점을 명확히 인지해야 함.

## 관련 파일 확인

- Modal이 열릴 때 트리거되는 모델 에이전트 프롬프트 파일들이 정확한지 확인했음.

- `context agent suggestion.system` 파일이 올바르게 설정되어 있음을 확인함.

# 문제점 요약

- **잘못된 이름 규칙**: `context user suggestions underscore system chat and user.message`와 같은 이름은 혼란을 야기함.

- **자동 메시지 전송 기능 오류**: 자동 메시지가 의도한 대로 작동하지 않음.

- **데이터 손실**: 데이터베이스에서 LLM으로 데이터를 전송하는 과정에서 데이터가 손실됨.

- **불완전한 데이터**: LLM이 불완전한 데이터를 받아 비효율적인 응답을 생성함.

# 문제 원인 분석

- **프롬프트 기대**: 프롬프트가 최신 컨텍스트 변수를 통해 일일 포커스를 기대함.

- **데이터 로드 실패**: `context-gpl`이 LLM으로 이동하기 전에 데이터베이스에서 데이터를 로드하지 못함.

- **결과**: 작업 및 목표는 수신되지만 중요한 정보가 누락되어 비효율적인 응답이 생성됨.

# Auto-Send 기능 문제 추적

- Auto-Send 기능의 전체 흐름을 이해하고 문제 추적을 시작함.

- 문제의 핵심은 사용자의 daily focus가 제대로 로드되지 않는 것임.

## 문제 발생 위치 특정

- `context Agent.py` 파일의 103번째 라인에서 문제가 발생하는 것을 확인함.

- `mode user`가 `generate task base suggestion template`에서 사용될 때 컨텍스트가 로드되지 않는 문제임.

## 흐름 이해

- 두 가지 흐름이 존재함: focus 흐름과 model 흐름.

- `context agent.py`는 `mode agent`와 함께 사용되어 tasks와 goals를 가져옴.

## 보안 문제 관련 언급

- 다른 사람의 컨텍스트를 로드하는 심각한 보안 문제는 아님.

# `context_agent.py` 수정 필요

## 문제 발생 위치 및 원인

- 문제 위치: `context_agent.py`의 103번째 줄임.

- 근본 원인: 템플릿 컨텍스트 에이전트 제안이 최신 컨텍스트를 기반으로 예상하지만, 에이전트가 사용자 데이터를 로드하지 않음.

  - 사용자가 저장한 데일리 포커스 컨텍스트 테이블에 객체 유형이 누락됨.

  - 자동 메시지 전송 시 데일리 포커스 텍스트를 가져오지 않음.

## 해결 방안

- `context_agent.py`를 업데이트하여 데일리 데이터를 로드해야 함.

# 요약

## 문제 요약 및 정리

- 근본적인 문제에 대한 요약을 간결하게 작성해야 함.

- 문제 해결을 위해 수행한 조사 내용을 바탕으로 요약 작성해야 함.

## 요약본을 bullet list로 만들기

- 요약 내용을 bullet list 형식으로 정리해야 함.

- 텍스트 내용은 변경하지 않고, 형식만 변경해야 함.

# 파일 이름 변경 및 백엔드 정리

- 파일 이름이 엉망이므로 관련 파일 이름 변경 및 백엔드 구성을 시작해야 함.

  - 프롬프트 이름이 특히 엉망임.

- 인-모달 AI 제안과 자동 전송 메시지 간의 명확한 분리를 위해 관련 파일의 로직을 분리해야 함.

# 우선적으로 해야 할 세 가지

- 달성해야 할 첫 세 가지 제안.

# 코드 명확성, 구성, 논리 분리

- 코드의 명확성, 구성, 논리 분리가 중요함.

- 이해하기 쉽고 유지보수가 용이한 코드를 작성하는 데 필수적임.

  - 명확성: 코드가 읽기 쉽고 이해하기 쉬워야 함.

  - 구성: 코드가 체계적이고 일관성 있게 구성되어야 함.

  - 논리 분리: 각 기능이 명확하게 분리되어야 함.

## 프롬프트 이름

- 프롬프트 이름이 혼란스러우면 변경해야 함.

- 명확하고 설명적인 이름이 중요함.

## Focus Agent 폴더

- Focus Agent 폴더 구조가 좋음.

- 폴더를 분리해서 관리하는 것이 좋음.

# 폴더 이름 변경

## 단계별 접근 방식

- 폴더 이름 `context-agent`를 `Today's focus agent`로 변경함.

- 모든 import 구문을 수정해야 함.

- 한 번에 한 단계씩 진행하는 것이 중요함.

## 수동 리팩토링의 중요성

- 파일 구조 및 리팩토링은 AI에만 의존할 수 없음.

- 수동으로 관리하는 것이 중요함.

# 폴더 이름 변경 완료

## `mv` 명령어 사용

- 폴더 이름 변경 시 `mv` 명령어를 사용했음.

- `mv` 명령어는 파일을 삭제하고 다시 추가하는 방식으로 동작함.

- Git에서 지원하는 명령어임.

## Git과 IDE의 파일 이동 인식 차이

- Git 로그는 파일 이동을 인지함.

- IDE(통합 개발 환경)에서는 파일이 새로 생성된 것처럼 보일 수 있음.

## Import 수정 필요

- 폴더 이름 변경 후에는 import 경로를 수정해야 함.

## Cloud Code를 사용한 리팩토링

- Cloud Code를 사용하면 리팩토링이 더 쉬워짐.

# 코드 변경 시 위험 감소 방법

## 점진적인 리팩토링

- 코드 변경을 작은 단계로 나누어 진행해야 함.

- 예: 50줄의 코드 변경 후 테스트, 다음 50-100줄 변경 후 다시 테스트.

## 작은 변경 후 테스트의 중요성

- 각 단계 후에는 반드시 테스트를 수행하여 변경 사항을 검증해야 함.

- 모든 것이 제대로 작동하는지 확인하는 것이 중요함.

## 이전의 위험한 작업과 비교

- 과거에 380줄의 코드를 한 번에 이동하는 위험한 작업을 수행했었음.

- 앞으로는 더 작은 단계로 나누어 안전하게 진행해야 함.

# 컨텍스트 윈도우 관리

## `slash compact` 사용

- 컨텍스트 윈도우 공간이 부족할 때 `slash compact` 명령어를 사용하여 요약하고 정리함.

- 깃(Git) 명령어는 무시하고 요약해야 함.

## 리팩토링 전 압축의 중요성

- 컨텍스트 윈도우가 21%밖에 남지 않았기 때문에 리팩토링 전에 `slash compact`를 실행하는 것이 중요함.

- 컨텍스트 부족 문제를 해결하고 리팩토링 작업을 효율적으로 진행할 수 있음.

# 작업 추적

- 완료된 작업에 대해 녹색 체크 이모티콘을 추가하여 추적함.

# 로직 분리

- 모델 제안 및 자동 메시지 전송 로직을 **별도의 파일**로 분리해야 함.

  - `model suggest`

  - `auto send message`

# Anthropic의 컨텍스트 압축 방법

- Anthropic에서 컨텍스트를 압축하는 효과적인 방법을 사용하고, 이를 참고할 수 있음.

  - 짧은 요약으로 많은 컨텍스트를 압축하는 방식임.

# 세션 지속

- 이번 세션은 이전 대화에서 이어지고 있음.

# 대화 요약 및 분석

## 대화 요약의 핵심 요소

- 엔지니어링 팀에서 설계한 강력한 요약 방식 참고함.

- 문제 해결에 집중: 자동 시작 메시지 관련 이슈 수정.

- 요약 내용: 문제의 핵심, 기술적 개념, 코드 선택, 에러 및 수정 사항 포함.

## 에이전트 파일 분리

- 두 개의 분리된 에이전트 파일 생성함.

- 파일 분리를 통해 코드의 가독성 및 유지보수성을 향상시킴.

## 요약 구조

- 보류 중인 작업 (pending tasks)

- 현재 작업 (current work)

- 선택적 다음 단계 (optional next step)요약 구조를 통해 진행 상황을 명확하게 파악하고 다음 단계를 효율적으로 계획할 수 있음.

# Context Agent 파일 분할 후 처리 방향

- Context Agent 파일(.py) 로직 분할 후 완전 대체할지, 아니면 부분적으로 사용할지 명확히 해야 함.

  - 완전 대체: 기존 파일 완전히 제거.

  - 부분 사용: 기존 파일의 일부 기능 유지.

- 향후 진행할 3가지 옵션을 고려해야 함.

  - 명확한 목표 설정 중요.

# Context Agent 파일 완전 대체 옵션

- Modal suggestion 파일 사용

# Modal suggestion.py 및 auto send message.py 파일

- 관련 파일 누락

# Model suggestion 및 auto send message 파일 업데이트

- 적절한 헤더 주석 추가

# 새로운 파일에 헤더 코멘트 추가

- `modal_suggestion.py`와 `auto_send_message.py` 파일에 적절한 헤더 코멘트를 추가해야 함.

- 표준 MDC 형식을 따르는 코멘트를 사용할 것.

# 옵션 1 실행

- 기존 `context_agent.py` 파일을 완전히 대체하는 옵션 1을 사용하기로 함.

# 기존 파일 삭제

- 기존 `context_agent.py` 파일을 삭제하는 단계를 명확히 언급해야 함.

- 이는 전체 계획의 중요한 부분임.

# Agent 작업 검토 및 문제점

- Agent가 수행한 작업 결과 검토가 필요함.

- **문제점**:

  - 새 파일에 필요한 헤더 주석이 누락됨.

  - Claude for Sonnet 모델이 헤더 주석 추가 작업에 실패함.

  - 자동 승인(auto accept)을 할 수 없는 상황임.

# `context_agent.py` 파일 주석 처리

- 파일을 바로 삭제하는 대신, 모든 내용을 주석 처리함.

  - 이렇게 하면 다른 곳에서 해당 파일을 실수로 사용하는 것을 방지할 수 있음.

  - 테스트를 먼저 진행하고 삭제 여부를 결정하기 위함임.

# 진행 상황 업데이트

- 이미 완료한 단계 앞에 초록색 체크 이모티콘을 추가하여 계획을 업데이트함.

  - 진행 상황을 시각적으로 추적하고 관리하기 위함임.

# 추가 디버깅 및 계획 업데이트

- 현재 상황이 마음에 들지 않아 `/compact` 대신 `/clear` 명령어를 고려 중임.

  - `/clear`는 컨텍스트를 완전히 초기화하는 명령어임.

  - `/compact`는 컨텍스트를 요약하는 명령어임.

- 이전 컨텍스트가 시각적으로 계속 보이는 버그가 있어 에디터를 닫았다가 다시 열었음.

- 현재 진행 중인 작업은 관련 파일들을 분석하여 문제점을 파악하는 것임.

# 새로운 세션 시작 및 방향 재설정

- 새로운 세션으로 시작했으니, 에이전트가 현재 상황을 다시 파악하도록 함.

- 에이전트가 관련 파일을 분석하여 현재 위치를 정확히 파악해야 함.

# 파일 이름 변경 재고

- 파일 이름 변경을 다시 고려 중임.

- 모든 파일을 변경할 필요는 없을 수 있음.

- `context service` 파일은 이름 변경 대상에서 제외될 수 있음.

# 디버깅 지속

- 디버깅 및 리팩토링 과정이 계속 진행 중임.

- 이전 프롬프트들을 재적용할지 고려 중임.

# 파일 이름 변경 및 GitHub 푸시

## 파일 이름 변경 전략

- 필요없는 프롬프트 파일 이름 변경함.

- **Context Service**는 당분간 이름 변경하지 않기로 함.

## GitHub에 변경 사항 푸시

- 로직 분리 후 GitHub에 푸시해야 함.

- 두 개의 새로운 파일 생성 사실을 푸시함.

## 커서 챗 사용

- 현재 잘 작동하므로 **커서 챗**을 사용하여 푸시함.

## 개발 프로토콜 준수

- 개발 서버에 푸시할 때 프로토콜을 정확히 준수해야 함.

# GitHub 푸시 연기 고려

- 앱 오류로 인해 GitHub 푸시를 연기할 수 있음을 고려함.

- 앱 오류 수정 우선임.

# 계획 실행

- 프롬프트 정리해야 함.

- 파일 이름 변경 (명확성을 위해) 해야 함.

# AI 프롬프트 생성

- AI가 프롬프트를 완전히 작성하는 것을 신뢰하지 않음.

  - AI는 피드백에는 유용하지만, 직접 프롬프트를 작성하는 데에는 부적합하다고 생각함.

  - 프롬프트 최적화에 많은 시간을 투자했기 때문임.

# MV 명령어의 위험성

- `mv` 명령어는 파일 이동과 관련된 위험이 큼.

  - 자동 실행을 막기 위해 허용 명령어 목록에 추가하지 않음.

  - 허용되지 않은 명령은 거부해야 함.

# 권한 제어

- 클라우드 환경에서는 `settings local JSON` 파일을 통해 권한을 관리함.

  - 이 파일에서 AI가 자체적으로 실행할 수 있는 명령어를 설정함.

# 코스 자료의 이점

- 코스에서 제공하는 Cloth MD 파일과 `settings local JSON` 파일은 매우 유용함.

- 실제 워크플로우에 바로 복사-붙여넣기하여 사용할 수 있는 자료를 제공함.

- `settings local JSON` 설정을 통해 시간을 절약할 수 있음.

# MV 명령어 사용 시 보안 문제

- `MV` 명령어와 같이 파일 이동 관련 명령어는 자동 실행 권한을 주지 않아야 함.

- 보안상 위험이 따르므로 주의해야 함.

# Context Service 수정의 중요성

- Context Service가 주석 처리된 파일을 가리키고 있으므로, ASAP 수정해야 함.

- 현재 Context Service가 올바른 파일을 참조하도록 수정하는 것이 중요함.

# 파일 이름 변경 확인

- 모든 파일 이름이 계획대로 변경되었는지 확인해야 함.

- `auto send` 관련 파일 이름 변경 상태를 점검해야 함.

# Git 푸시 및 다음 단계

- 프롬프트 파일 이름 변경 후 Git 푸시를 수행해야 함.

  - `오늘의 에이전트 디버깅`에 따라 이름이 변경된 프롬프트 파일을 `dev` 브랜치에 푸시.

  - 프로토콜을 준수하고 다른 작업은 수행하지 않음.

- 커서 에이전트를 사용하여 Git 푸시를 수행하는 것이 좋음.

  - 컨텍스트 창이 채워지는 것을 방지.

- 완료된 단계는 녹색 체크 표시로 표시해야 함.

  - `에이전트 디버깅`에서 완료된 작업에 녹색 체크 표시를 추가.

- 다음 단계를 결정해야 함.

  - 남은 필요한 단계를 모두 나열하여 다음 단계를 파악.

# Plan 모드와 Auto Accept 모드

- Plan 모드는 Cursor 내에서 **ask**와 유사함.

- Auto Accept 모드는 **agent**와 유사함.

- Plan 모드와 Auto Accept 모드 간 전환은 매우 중요함.

# 깨진 Import 수정 및 Dev에 Push

- 깨진 import를 수정해야 함.

- import 수정 후 dev에 push해야 함.

# 에이전트 디버깅 로그 업데이트

## 중요 업데이트 시기

- 다른 사용자가 손상된 앱을 사용하지 않도록 즉시 업데이트해야 함.

- 시간 절약을 위해 예측을 통해 미리 수행함.

## 녹색 체크 이모티콘 사용

- 진행 상황을 명확하고 눈에 띄게 표시하기 위해 사용함.

- LM(Language Model)도 이모티콘을 인식할 수 있음.

- 시각적인 명확성이 중요함.

# 중요: 명확성을 확보하는 것의 중요성

- 명확성을 확보하는 것은 개발만큼 중요함.

- 문제 발생 시 현재 상황을 파악하는 것이 중요함.

- 전체적인 그림을 이해하고, 다음에 무엇을 해야 할지 아는 것이 중요함.

# 디버깅 과정 및 관련 파일 분석

- 디버깅 과정과 관련된 모든 파일을 철저히 분석해야 함.

- 누락된 단계와 실행 순서를 파악하여 효율적인 문제 해결을 해야 함.

- AI에게 물어보는 것이 중요함.

# Backend 배포 문제 해결

## Render.com 배포 실패

- Backend가 Render.com에서 배포되지 않고 있음.

- 배포 로그를 확인하여 오류 원인을 파악해야 함.

- Backend 배포가 완료되기 전까지 다른 작업을 중단해야 함.

## 로그 분석 및 오류 조사

- 배포 로그를 복사하여 오류 메시지를 분석함.

- 관련 파일을 조사하여 문제 해결 방법을 찾아야 함.

- 오류의 원인을 자세히 설명하고, 해결 방법을 제시하도록 Chat에 요청함.

## Chat을 이용한 문제 해결

- Chat 기능을 사용하여 오류 분석 및 해결 방안 모색.

- O3 모델을 사용하여 Chat에 질문함.

- Backend 배포 오류의 원인과 해결책을 Chat으로부터 얻음.

# 백엔드 배포 문제 해결

## 깨진 Import 수정

- 여전히 깨진 import가 존재함.

- 문제 해결을 위해 심호흡하고 선임 개발자처럼 접근해야 함.

- 이전과 동일한 버그일 가능성이 있음.

## 백엔드 배포 오류 조사

- 백엔드 배포가 오류로 인해 실패함.

- 오류의 원인을 파악하고 해결 방법을 찾아야 함.

# 백엔드 배포 문제 해결

- **에러 원인 조사:**

  - Render.com 배포 에러의 근본 원인을 철저히 조사해야 함.

  - 이전에 수정된 문제와 동일한 문제인지 확인해야 함.

- **이전 파일 Import 확인:**

  - 백엔드가 이전 폴더나 파일을 import하려고 시도하는지 분석해야 함.

  - 이전 파일 참조가 남아있는지 확인하는 것이 중요함.

- **배포 상태 검증 중요:**

  - 백엔드 배포 상태를 지속적으로 확인해야 함.

  - 배포가 성공적으로 완료되었는지 확인하는 것이 중요함.

# Import 수정사항 Dev에 푸시

- Import 수정사항을 Dev 브랜치에 푸시함.

- 프로토콜 준수: 다른 작업은 수행하지 않음.

# 프롬프트 간소화

- 더 깊이 이해하기 위해 프롬프트를 단순하고 짧게 만들기.

- 이해도를 높이기 위해 쉬운 용어를 사용하고, 필요시 기술적인 세부사항을 추가함.

# 백엔드 배포 디버깅

## Gemini를 사용한 로그 분석

- 백엔드가 여전히 배포되지 않는 문제 발생

- Gemini를 사용하여 로그를 분석하고 오류 원인 파악

## 누락된 단계 식별

- 디버깅 파일 및 관련 파일을 다시 읽고 분석

- 현재 상태와 누락된 부분 정확히 파악

- 짧은 계획 모드로 답변

# 순환 참조 오류 (Circular Import Error)

- 정의: 두 개 이상의 모듈이 서로를 import하는 상황임.

- 원인: 모듈 간의 상호 의존성 때문에 발생함.

- 중요성: 즉시 해결해야 함.

  - 프로그램 실행을 방해하고 예기치 않은 동작을 유발할 수 있음.

# 배포 모니터링 (Deployment Monitoring)

- 중요성: 배포 과정에서 발생하는 오류를 즉시 감지하고 대응하기 위함임.

  - 오류 발생 시 추가 진행을 멈추고 문제 해결에 집중해야 함.

- 조치:

  - 오류 발생 시 로그를 확인하고 원인을 분석함.

  - 오류를 수정하고 재배포를 시도함.

# 워크플로우 및 도구

## Gemini 2.5 Pro 'Ask' 모드

- Gemini 2.5 Pro를 'Ask' 모드에서 사용하여 코드 및 문제에 대한 설명을 얻음.

- 코드 생성 및 문제 해결에 유용함.

## Claude를 사용한 코드 생성

- Claude를 사용하여 실제 코드를 생성함.

- Gemini와 Claude를 함께 사용하여 효율성을 높임.

# 개발 프로세스

## 'Dev' 환경으로 수정사항 푸시

- 수정된 코드를 'Dev' 환경으로 푸시하여 테스트 및 통합을 진행함.

- 프로토콜을 준수하고 다른 작업은 수행하지 않도록 함.

## 남은 작업

- 서비스 메서드 분할 (Split service method)

- 객체 포커스 설정 (Setting object focus)

## 'Plan' 모드의 중요성

- 'Plan' 모드를 사용하여 코드 실행을 제어하고 의도치 않은 변경을 방지함.

- 작업 계획을 세우고 단계를 신중하게 실행함.

# 백엔드 배포 모니터링 및 디버깅

## 백엔드 배포 모니터링

- 백엔드 배포가 성공적인지 지속적으로 모니터링해야 함.

- 개발자들이 이미 문제를 발견했는지 확인하는 것이 중요함.

## 디버깅 파일 분석

- 오늘 에이전트 디버깅 파일을 전체적으로 다시 읽어야 함.

- 가장 관련성이 높은 파일들을 분석하고, 전체 내용을 파악해야 함.

## 필요한 단계 식별

- 디버깅 과정에서 아직 완료되지 않은, 반드시 필요한 단계들을 식별해야 함.

- 남은 단계를 파악하여 문제 해결 로드맵을 완성해야 함.

# 디버깅 및 배포 시 고려사항

## 파일 변경 후 재분석 필요

- 파일이 변경되면 반드시 재분석을 해야 함.

- 변경된 내용에 맞춰 필요한 단계를 파악해야 함.

## Cloud Max 요금 효율성

- Cloud Max 요금제가 다른 서비스에 비해 효율적일 수 있음.

- AP 사용 시 예상되는 비용과 비교하면 더 유리할 수 있음.

## 프롬프트 영향

- 프롬프트가 모델 분석에 영향을 줄 수 있다는 점을 인지해야 함.

- 모델이 프롬프트에 의해 편향되지 않도록 주의해야 함.

# 디버깅 과정에서 Gemini 활용

- Gemini를 사용하여 디버깅 과정에서 누락된 부분을 파악함.

  - 관련 파일 분석 및 읽기를 통해 누락된 부분 식별

  - 답변은 간결하게 제시

- **최첨단 추론 모델** 활용

  - 두 개의 최고 AI 모델을 사용하여 답변을 얻음

  - 남은 작업 명확히 파악

- 단순히 이름 변경 작업이 아님

  - 디버깅은 복잡한 문제 해결 과정임

# 코드 분리의 중요성

- 복잡한 프로젝트에서는 코드 분리가 매우 중요함.

  - 코드 분리를 통해 여러 에이전트 또는 기능 간의 혼란을 피할 수 있음.

  - 클라우드 코드가 무엇이 무엇인지 혼동하는 것을 방지함.

- 서비스 레이어 리팩토링 함수가 누락되었을 수 있음.

  - 이는 프로젝트 구조와 관련하여 추가적인 분석이 필요함을 시사함.

# 리팩토링 및 데이터베이스 수정

## 서비스 레이어 리팩토링

- 서비스 레이어를 두 개의 분리된 함수로 리팩토링함.

- 함수 분할을 통해 코드의 가독성과 유지보수성을 향상시킴.

## 데이터베이스 쓰기 수정

- 데이터베이스 쓰기 오류를 수정함.

- 저장해야 할 코드 업데이트가 필요함.

## 객체 타입 업데이트

- `today's focus expires ad fields` 객체 타입을 업데이트함.

- 관련 필드 추가 및 수정 작업 수행함.

# 파일 관리

## 오래된 파일 삭제

- 더 이상 필요하지 않은 오래된 파일을 삭제함.

- 불필요한 파일 제거를 통해 시스템 정리.

## 저장 및 업데이트

- 변경 사항을 저장하고 관련 파일을 업데이트함.

- 데이터 일관성 유지.

# AI 상호 작용

## "Execute" 프롬프트

- AI 모델에게 특정 작업을 실행하도록 지시하는 "Execute" 프롬프트 사용함.

- AI의 작업 수행을 제어.

## 잠재적인 AI 버그

- "close" 기능에서 잠재적인 버그가 발견됨.

- AI 도구의 동작을 면밀히 관찰하고 문제 해결.

# ContextService 리팩토링

## ContextService 문제점

- `ContextService`가 복잡하고 관리하기 어려워짐.

- `generate task based suggestion` 메서드가 과도한 기능 수행.

## 해결책: 메서드 이름 변경

- `generate task based suggestion` -> `generate model suggestion`으로 변경.

  - 더 명확하고 이해하기 쉬운 이름으로 변경.

  - `Mode agent or user`로 에이전트 또는 사용자 모드 명시.

## 개발 환경에 푸시

- 리팩토링된 코드를 개발(`dev`) 환경에 푸시.

  - 다른 작업에 영향 주지 않도록 주의.

## 요약

- 변경 사항을 요약하여 전달.

# Cloud Code 마스터클래스 (8시간)

## 강의 개설 조건

- **8시간** 강의에 대한 댓글이 많을 경우 제작 고려함.

- 댓글을 통해 수요를 파악하고, 마스터클래스 제작 여부를 결정함.

## 강의 내용 특징

- 다른 곳에서는 찾기 힘든 Cloud Code 팁들을 다룰 예정임.

- 실질적인 사용 경험을 바탕으로 얻은 독점적인 정보 제공을 목표로 함.


‏‏‎ ‎
